msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.LessOrEqual.L10le_one
msgid "x โค 1"
msgstr ""

#. ยง0: `tauto`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "ยง0 is good enough to solve this goal."
msgstr ""

#: Game.Levels.Multiplication.L09mul_assoc
msgid "mul_assoc"
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: `succ_inj a b`
#. ยง3: $ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$
#. ยง4: `succ_inj`
#. ยง5: `succ_inj`
#. ยง6: $$a$$
#. ยง7: $$b$$
#. ยง8: $ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$
#. ยง9: `succ_inj`
#. ยง10: `succ`
#. ยง11: `succ_inj`
#. ยง12: $\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$
#. ยง13: `succ_inj`
#. ยง14: `pred`
#: Game.Levels.Implication.L04succ_inj
msgid "# Statement\n"
"\n"
"If ยง0 and ยง1 are numbers, then\n"
"ยง2 is the proof that\n"
"ยง3.\n"
"\n"
"## More technical details\n"
"\n"
"There are other ways to think about ยง4.\n"
"\n"
"You can think about ยง5 itself as a function which takes two\n"
"numbers ยง6 and ยง7 as input, and outputs a proof of\n"
"ยง8.\n"
"\n"
"You can think of ยง9 itself as a proof; it is the proof\n"
"that ยง10 is an injective function. In other words,\n"
"ยง11 is a proof of\n"
"ยง12.\n"
"\n"
"ยง13 was postulated as an axiom by Peano, but\n"
"in Lean it can be proved using ยง14, a mathematically\n"
"pathological function."
msgstr ""

#. ยง0: $a, b$
#. ยง1: $ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$
#: Game.Levels.Addition.L02succ_add
msgid "For all natural numbers ยง0, we have\n"
"ยง1."
msgstr ""

#. ยง0: `h`
#. ยง1: `X = Y`
#. ยง2: `rw [h]`
#. ยง3: `X`
#. ยง4: `Y`
#. ยง5: `Y`
#. ยง6: `X`
#. ยง7: `rw`
#. ยง8: `โ`
#. ยง9: `\\l`
#. ยง10: $2$
#. ยง11: $0$
#. ยง12: `succ (succ 0)`
#. ยง13: `2`
#: Game.Levels.Tutorial.L04rw_backwards
msgid "If ยง0 is a proof of ยง1 then ยง2 will\n"
"turn ยง3s into ยง4s. But what if we want to\n"
"turn ยง5s into ยง6s? To tell the ยง7 tactic\n"
"we want this, we use a left arrow ยง8. Type\n"
"ยง9 and then hit the space bar to get this arrow.\n"
"\n"
"Let's prove that ยง10 is the number after the number\n"
"after ยง11 again, this time by changing ยง12\n"
"into ยง13."
msgstr ""

#. ยง0: `have`
#. ยง1: `a`
#. ยง2: `have ha : a = 0`
#. ยง3: `a = 0`
#. ยง4: `ha : a = 0`
#. ยง5: `have`
#. ยง6: `a`
#. ยง7: `b`
#. ยง8: `have h2 : succ a = succ b โ a = b := succ_inj a b`
#. ยง9: `h2 : succ a = succ b โ a = b`
#. ยง10: `succ_inj a b`
#. ยง11: `have h2 := succ_inj a b`
#. ยง12: `h2 : succ a = succ b โ a = b`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "# Summary\n"
"\n"
"The ยง0 tactic can be used to add new hypotheses to a level, but of course\n"
"you have to prove them.\n"
"\n"
"\n"
"## Example\n"
"\n"
"The simplest usage is like this. If you have ยง1 in your context and you execute\n"
"\n"
"ยง2\n"
"\n"
"then you will get a new goal ยง3 to prove, and after you've proved\n"
"it you will have a new hypothesis ยง4 in your original goal.\n"
"\n"
"## Example\n"
"\n"
"If you already have a proof of what you want to ยง5, you\n"
"can just create it immediately. For example, if you have ยง6 and ยง7\n"
"number objects, then\n"
"\n"
"ยง8\n"
"\n"
"will directly add a new hypothesis ยง9\n"
"to the context, because you just supplied the proof of it (ยง10).\n"
"\n"
"## Example\n"
"\n"
"If you have a proof to hand, then you don't even need to state what you\n"
"are proving. For example\n"
"\n"
"ยง11\n"
"\n"
"will add ยง12 as a hypothesis."
msgstr ""

#. ยง0: `โค`
#: Game.Levels.LessOrEqual.L11le_two
msgid "Nice!\n"
"\n"
"The next step in the development of order theory is to develop\n"
"the theory of the interplay between ยง0 and multiplication.\n"
"If you've already done Multiplication World, you're now ready for\n"
"Advanced Multiplication World. Click on \"Leave World\" to access it."
msgstr ""

#. ยง0: `a + b + c`
#. ยง1: `(a + b) + c`
#. ยง2: `+`
#: Game.Levels.Addition.L04add_assoc
msgid "Remember that when Lean writes ยง0, it means ยง1.\n"
"If you are not sure where the brackets are in an expression, just hover\n"
"your cursor over it and look at what gets highlighted. For example,\n"
"hover over both ยง2 symbols on the left hand side of the goal and\n"
"you'll see where the invisible brackets are."
msgstr ""

#. ยง0: `rw [โ one_eq_succ_zero]`
#. ยง1: `succ 0`
#. ยง2: `1`
#: Game.Levels.Tutorial.L04rw_backwards
msgid "Try ยง0 to change ยง1 into ยง2."
msgstr ""

#. ยง0: `1`
#: Game.Levels.Tutorial.L07add_succ
msgid "Start by unravelling the ยง0."
msgstr ""

#: Game.Levels.Tutorial.L02rw
msgid "the rw tactic"
msgstr ""

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "mul_left_ne_zero"
msgstr ""

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "mul_ne_zero"
msgstr ""

#. ยง0: ```
#. intro h
#. rw [add_succ, add_succ, add_zero] at h
#. repeat apply succ_inj at h
#. apply zero_ne_succ at h
#. exact h
#. ```
#. ยง1: $20 + 20 โ 41$
#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "Here's my proof:\n"
"ยง0\n"
"\n"
"Even though Lean is a theorem prover, right now it's pretty clear that we have not\n"
"developed enough material to make it an adequate calculator. In Algorithm\n"
"World, a more computer-sciency world, we will develop machinery which makes\n"
"questions like this much easier, and goals like ยง1 feasible.\n"
"Alternatively you can do more mathematics in Advanced Addition World, where we prove\n"
"the lemmas needed to get a working theory of inequalities. Click \"Leave World\" and\n"
"decide your route."
msgstr ""

#. ยง0: `2 + 2 = 4`
#: Game.Levels.Tutorial
msgid "Welcome to tutorial world! In this world we learn the basics\n"
"of proving theorems. The boss level of this world\n"
"is the theorem ยง0.\n"
"\n"
"You prove theorems by solving puzzles using tools called *tactics*.\n"
"The aim is to prove the theorem by applying tactics\n"
"in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below\n"
"to begin your quest."
msgstr ""

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "add_left_cancel"
msgstr ""

#: Game.Levels.LessOrEqual.L01le_refl
msgid "You can probably take it from here."
msgstr ""

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "2+2=4"
msgstr ""

#. ยง0: `x โ y`
#. ยง1: `x = y โ False`
#: Game.Levels.Implication.L08ne
msgid "Remember, ยง0 is *notation* for ยง1."
msgstr ""

#. ยง0: `a * b = 0`
#. ยง1: `a = 0`
#. ยง2: `b = 0`
#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "This level proves that if ยง0 then ยง1 or ยง2. It is\n"
"logically equivalent to the last level, so there is a very short proof."
msgstr ""

#. ยง0: $0+n=n$
#. ยง1: $n$
#. ยง2: $n+0=n$
#. ยง3: `add_zero`
#. ยง4: `zero_add`
#. ยง5: `0 + n = n`
#. ยง6: `0 + n`
#. ยง7: `add_zero`
#. ยง8: `add_succ`
#. ยง9: `n`
#. ยง10: `0`
#. ยง11: `induction`
#. ยง12: `0 + 0 = 0`
#. ยง13: `0 + d = d`
#. ยง14: `0 + succ d = succ d`
#. ยง15: `0`
#. ยง16: `>_`
#: Game.Levels.Addition.L01zero_add
msgid "In this level we're going to prove that ยง0, where ยง1 is a secret natural number.\n"
"\n"
"Wait, don't we already know that? No! We know that ยง2, but that's ยง3.\n"
"This is ยง4, which is different.\n"
"\n"
"The difficulty with proving ยง5 is that we do not have a *formula* for\n"
"ยง6 in general, we can only use ยง7 and ยง8 once\n"
"we know whether ยง9 is ยง10 or a successor. The ยง11 tactic splits into these two cases.\n"
"\n"
"The base case will require us to prove ยง12, and the inductive step\n"
"will ask us to show that if ยง13 then ยง14. Because\n"
"ยง15 and successor are the only way to make numbers, this will cover all the cases.\n"
"\n"
"See if you can do your first induction proof in Lean.\n"
"\n"
"(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\n"
"back to \"Typewriter mode\" by clicking the ยง16 button in the top right.)"
msgstr ""

#. ยง0: `โจ`
#. ยง1: `x = 0 โจ x = 1 โจ x = 2`
#. ยง2: `x = 0 โจ (x = 1 โจ x = 2)`
#. ยง3: `left`
#. ยง4: `right`
#: Game.Levels.LessOrEqual.L11le_two
msgid "We'll need this lemma to prove that two is prime!\n"
"\n"
"You'll need to know that ยง0 is right associative. This means that\n"
"ยง1 actually means ยง2.\n"
"This affects how ยง3 and ยง4 work."
msgstr ""

#: Game.Levels.Power.L01zero_pow_zero
msgid "zero_pow_zero"
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#: Game.Levels.Addition.L03add_comm
msgid "Induction on ยง0 or ยง1 -- it's all the same in this one."
msgstr ""

#: Game.Levels.Power.L05pow_two
msgid "Note: this lemma will be useful for the final boss!"
msgstr ""

#: Game.Levels.Implication.L06intro
msgid "intro"
msgstr ""

#. ยง0: `apply eq_succ_of_ne_zero at ha`
#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Use the previous lemma with ยง0."
msgstr ""

#: Game.Levels.Multiplication.L09mul_assoc
msgid "A passing mathematician notes that you've proved\n"
"that the natural numbers are a commutative semiring.\n"
"\n"
"If you want to begin your journey to the final boss, head for Power World."
msgstr ""

#. ยง0: `pow_pow`
#: Game.Levels.Power.L08pow_pow
msgid "One of the best named levels in the game, a savage ยง0\n"
"sub-boss appears as the music reaches a frenzy. What\n"
"else could there be to prove about powers after this?"
msgstr ""

#. ยง0: $x \\leq 0$
#. ยง1: $x=0$
#: Game.Levels.LessOrEqual.L05le_zero
msgid "If ยง0, then ยง1."
msgstr ""

#. ยง0: `apply h`
#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "Now ยง0 and you can probably take it from here."
msgstr ""

#. ยง0: `mul_comm x y : x * y = y * x`
#. ยง1: `zero_mul`
#. ยง2: `mul_zero`
#: Game.Levels.Multiplication.L04mul_comm
msgid "The first sub-boss of Multiplication World is ยง0.\n"
"\n"
"When you've proved this theorem we will have \"spare\" proofs\n"
"such as ยง1, which is now easily deducible from ยง2.\n"
"But we'll keep hold of these proofs anyway, because it's convenient\n"
"to have exactly the right tool for a job."
msgstr ""

#. ยง0: `add_right_comm a b c`
#. ยง1: `(a + b) + c = (a + c) + b`
#. ยง2: `a + b + c`
#. ยง3: `(a + b) + c`
#. ยง4: `a + b + c = a + c + b`
#: Game.Levels.Addition.L05add_right_comm
msgid "ยง0 is a proof that ยง1\n"
"\n"
"In Lean, ยง2 means ยง3, so this result gets displayed\n"
"as ยง4."
msgstr ""

#: Game.Levels.Algorithm.L08decide
msgid "decide"
msgstr ""

#. ยง0: `rw [zero_add] at ยซ{h}ยป`
#. ยง1: `ยซ{h}ยป`
#: Game.Levels.Implication.L02exact2
msgid "You can use ยง0 to rewrite at ยง1 instead\n"
"of at the goal."
msgstr ""

#. ยง0: `add_comm`
#. ยง1: `b`
#. ยง2: `d`
#: Game.Levels.Algorithm.L02add_algo1
msgid "Finally use a targetted ยง0 to switch ยง1 and ยง2"
msgstr ""

#. ยง0: `repeat t`
#. ยง1: `t`
#. ยง2: `repeat rw [add_zero]`
#. ยง3: `a + 0 + (0 + (0 + 0)) = b + 0 + 0`
#. ยง4: `a = b`
#: Game.Levels.Tutorial.L05add_zero
msgid "## Summary\n"
"\n"
"ยง0 repeatedly applies the tactic ยง1\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"ยง2 will turn the goal\n"
"ยง3\n"
"into the goal\n"
"ยง4."
msgstr ""

#: Game.Levels.Addition
msgid "Addition World"
msgstr ""

#. ยง0: `P`
#. ยง1: `exact h`
#. ยง2: `h`
#. ยง3: `P`
#. ยง4: `x = 37`
#. ยง5: `h : x = 37`
#. ยง6: `exact h`
#. ยง7: `x + 0 = x`
#. ยง8: `exact add_zero x`
#. ยง9: `exact add_zero`
#. ยง10: `exact h`
#. ยง11: `h`
#. ยง12: `add_zero`
#. ยง13: `โ n, n + 0 = n`
#. ยง14: `? + 0 = ?`
#. ยง15: `?`
#. ยง16: `rw`
#. ยง17: `apply`
#. ยง18: `x + 0 = x`
#. ยง19: `rw [add_zero]`
#. ยง20: `rw [add_zero x]`
#. ยง21: `x = x`
#. ยง22: `rw`
#. ยง23: `add_zero`
#: Game.Levels.Implication.L01exact
msgid "## Summary\n"
"\n"
"If the goal is a statement ยง0, then ยง1 will close the goal if ยง2 is a proof of ยง3.\n"
"\n"
"### Example\n"
"\n"
"If the goal is ยง4 and you have a hypothesis ยง5\n"
"then ยง6 will solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If the goal is ยง7 then ยง8 will close the goal.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"Note that ยง9 will *not work* in the previous example;\n"
"for ยง10 to work, ยง11 has to be *exactly* a proof of the goal.\n"
"ยง12 is a proof of ยง13 or, if you like,\n"
"a proof of ยง14 where ยง15 needs to be supplied by the user.\n"
"This is in contrast to ยง16 and ยง17, which will \\\\\"guess the inputs\\\\\"\n"
"if necessary. If the goal is ยง18 then ยง19\n"
"and ยง20 will both change the goal to ยง21,\n"
"because ยง22 guesses the input to the function ยง23."
msgstr ""

#. ยง0: `apply succ_inj at h`
#. ยง1: `succ`
#: Game.Levels.Implication.L07intro2
msgid "Now ยง0 to cancel the ยง1s."
msgstr ""

#. ยง0: `induction`
#. ยง1: `x + y = y + x`
#. ยง2: `rw`
#. ยง3: `rfl`
#. ยง4: `induction`
#: Game.Levels.Addition
msgid "Welcome to Addition World! In this world we'll learn the ยง0 tactic.\n"
"This will enable us to defeat the boss level of this world, namely ยง1.\n"
"\n"
"The tactics ยง2, ยง3 and ยง4 are the only tactics you'll need to\n"
"beat all the levels in Addition World, Multiplication World, and Power World.\n"
"Power World contains the final boss of the game.\n"
"\n"
"There are plenty more tactics in this game, but you'll only need to know them if you\n"
"want to explore the game further (for example if you decide to 100%\n"
"the game)."
msgstr ""

#. ยง0: `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`
#. ยง1: `(a + b) + (c + d) = ((a + c) + d) + b`
#. ยง2: `a+b+c+d`
#. ยง3: `a+c+d+b`
#. ยง4: `b`
#. ยง5: `c`
#. ยง6: `b`
#. ยง7: `d`
#. ยง8: `add_left_comm`
#: Game.Levels.Algorithm.L02add_algo1
msgid "In some later worlds, we're going to see some much nastier levels,\n"
"like ยง0.\n"
"Brackets need to be moved around, and variables need to be swapped.\n"
"\n"
"In this level, ยง1,\n"
"let's forget about the brackets and just think about\n"
"the variable order.\n"
"To turn ยง2 into ยง3 we need to swap ยง4 and ยง5,\n"
"and then swap ยง6 and ยง7. But this is easier than you\n"
"think with ยง8."
msgstr ""

#: Game.Levels.Algorithm.L01add_left_comm
msgid "add_left_comm"
msgstr ""

#. ยง0: `symm`
#. ยง1: `X = Y`
#. ยง2: `Y = X`
#. ยง3: `X โ Y`
#. ยง4: `X โ Y`
#. ยง5: `2 + 2 = 4`
#. ยง6: `symm`
#. ยง7: `4 = 2 + 2`
#. ยง8: `h : 2 + 2 โ 5`
#. ยง9: `symm at h`
#. ยง10: `h`
#. ยง11: `5 โ 2 + 2`
#: Game.Levels.Implication.L10one_ne_zero
msgid "## Summary\n"
"\n"
"The ยง0 tactic will change a goal or hypothesis of\n"
"the form ยง1 to ยง2. It will also work on ยง3\n"
"and on ยง4.\n"
"\n"
"### Example\n"
"\n"
"If the goal is ยง5 then ยง6 will change it to ยง7.\n"
"\n"
"### Example\n"
"\n"
"If ยง8 then ยง9 will change ยง10 to ยง11."
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $c$
#. ยง3: $a(b + c) = ab + ac$
#: Game.Levels.Multiplication.L07mul_add
msgid "Multiplication is distributive over addition on the left.\n"
"In other words, for all natural numbers ยง0, ยง1 and ยง2, we have\n"
"ยง3."
msgstr ""

#. ยง0: `apply`
#: Game.Levels.Implication.L03apply
msgid "The ยง0 tactic."
msgstr ""

#. ยง0: `exact h1`
#: Game.Levels.Implication.L01exact
msgid "The goal in this level is one of our hypotheses. Solve the goal by executing ยง0."
msgstr ""

#. ยง0: `โค`
#. ยง1: `a + b = 0`
#. ยง2: `a = 0`
#. ยง3: `b = 0`
#. ยง4: `cases`
#. ยง5: `cases`
#. ยง6: `b = 0`
#. ยง7: `b = succ d`
#. ยง8: `hd`
#. ยง9: `induction b with d hd`
#. ยง10: `cases b with d`
#. ยง11: `b = 0`
#. ยง12: `b = succ d`
#. ยง13: `h : False`
#. ยง14: `cases h`
#. ยง15: `False`
#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "The next result we'll need in ยง0 World is that if ยง1 then ยง2 and ยง3.\n"
"Let's prove one of these facts in this level, and the other in the next.\n"
"\n"
"## A new tactic: ยง4\n"
"\n"
"The ยง5 tactic will split an object or hypothesis up into the possible ways\n"
"that it could have been created.\n"
"\n"
"For example, sometimes you want to deal with the two cases ยง6 and ยง7 separately,\n"
"but don't need the inductive hypothesis ยง8 that comes with ยง9.\n"
"In this situation you can use ยง10 instead. There are two ways to make\n"
"a number: it's either zero or a successor. So you will end up with two goals, one\n"
"with ยง11 and one with ยง12.\n"
"\n"
"Another example: if you have a hypothesis ยง13 then you are done, because a false statement implies\n"
"any statement. Here ยง14 will close the goal, because there are *no* ways to\n"
"make a proof of ยง15! So you will end up with no goals, meaning you have proved everything."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Tutorial.L01rfl
msgid "In order to use the tactic ยง0 you can enter it in the text box\n"
"under the goal and hit \"Execute\"."
msgstr ""

#. ยง0: $x=37$
#. ยง1: $y=42$
#. ยง2: $y=42$
#. ยง3: $x=37$
#: Game.Levels.LessOrEqual.L07or_symm
msgid "If ยง0 or ยง1, then ยง2 or ยง3."
msgstr ""

#: Game.Levels.Algorithm.L09decide2
msgid "Congratulations! You've finished Algorithm World. These algorithms\n"
"will be helpful for you in Even-Odd World (when someone gets around to\n"
"implementing it)."
msgstr ""

#. ยง0: `h : X = Y`
#. ยง1: `rw [h]`
#. ยง2: `X`
#. ยง3: `Y`
#. ยง4: `nth_rewrite 3 [h]`
#: Game.Levels.Tutorial.L08twoaddtwo
msgid "Good luck!\n"
"\n"
"  One last hint. If ยง0 then ยง1 will change *all* ยง2s into ยง3s.\n"
"  If you only want to change one of them, say the 3rd one, then use\n"
"  ยง4."
msgstr ""

#. ยง0: `add_assoc`
#. ยง1: `add_comm`
#: Game.Levels.Addition.L04add_assoc
msgid "A passing mathematician congratulates you on proving that naturals\n"
"are an additive commutative monoid.\n"
"\n"
"Let's practice using ยง0 and ยง1 in one more level,\n"
"before we leave addition world."
msgstr ""

#: Game.Levels.Implication.L05succ_inj2
msgid "Arguing backwards"
msgstr ""

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "mul_right_eq_one"
msgstr ""

#. ยง0: `add_sq a b`
#. ยง1: $(a+b)^2=a^2+b^2+2ab.$
#: Game.Levels.Power.L09add_sq
msgid "ยง0 is the statement that ยง1"
msgstr ""

#. ยง0: $x=y$
#. ยง1: $x \\neq y$
#: Game.Levels.Implication.L08ne
msgid "If ยง0 and ยง1 then we can deduce a contradiction."
msgstr ""

#. ยง0: `2 + 2 = 4`
#. ยง1: $37$
#. ยง2: $x$
#. ยง3: $0$
#. ยง4: `37 + x`
#. ยง5: `37 + 0`
#. ยง6: `37 + succ x`
#. ยง7: `0`
#. ยง8: `37 + 0`
#. ยง9: `37`
#. ยง10: `a + 0`
#. ยง11: `a`
#. ยง12: `a`
#. ยง13: `add_zero a`
#. ยง14: `add_zero 37`
#. ยง15: `37 + 0 = 37`
#. ยง16: `add_zero x`
#. ยง17: `x + 0 = x`
#. ยง18: `add_zero`
#. ยง19: `? + 0 = ?`
#. ยง20: `add_zero x : x + 0 = x`
#. ยง21: `proof : statement`
#: Game.Levels.Tutorial.L05add_zero
msgid "We'd like to prove ยง0 but right now\n"
"we can't even *state* it\n"
"because we haven't yet defined addition.\n"
"\n"
"## Defining addition.\n"
"\n"
"How are we going to add ยง1 to an arbitrary number ยง2? Well,\n"
"there are only two ways to make numbers in this game: ยง3\n"
"and successors. So to define ยง4 we will need\n"
"to know what ยง5 is and what ยง6 is.\n"
"Let's start with adding ยง7.\n"
"\n"
"### Adding 0\n"
"\n"
"To make addition agree with our intuition, we should *define* ยง8\n"
"to be ยง9. More generally, we should define ยง10 to be ยง11 for\n"
"any number ยง12. The name of this proof in Lean is ยง13.\n"
"For example ยง14 is a proof of ยง15,\n"
"ยง16 is a proof of ยง17, and ยง18 is a proof\n"
"of ยง19.\n"
"\n"
"We write ยง20, so ยง21."
msgstr ""

#. ยง0: `t = 0`
#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "Let's warm up with an easy one, which works even if ยง0."
msgstr ""

#. ยง0: $x+1=y+1\\implies x=y$
#: Game.Levels.Implication.L07intro2
msgid "Let's see if you can use the tactics we've learnt to prove ยง0.\n"
"Try this one by yourself; if you need help then click on \"Show more help!\"."
msgstr ""

#. ยง0: `apply zero_ne_succ at h`
#: Game.Levels.Implication.L09zero_ne_succ
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now you can ยง0."
msgstr ""

#. ยง0: $37$
#. ยง1: $x$
#. ยง2: $q$
#. ยง3: $x$
#. ยง4: $37x + q = 37x + q$
#. ยง5: `x q : โ`
#. ยง6: `x`
#. ยง7: `q`
#. ยง8: `rfl`
#. ยง9: $X = X$
#. ยง10: $37x+q=37x+q$
#. ยง11: `rfl`
#: Game.Levels.Tutorial.L01rfl
msgid "# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical theorem (the \"Goal\").\n"
"The goal will be a statement about *numbers*. Some numbers in this game have known values.\n"
"Those numbers have names like ยง0. Other numbers will be secret. They're called things\n"
"like ยง1 and ยง2. We know ยง3 is a number, we just don't know which one.\n"
"\n"
"In this first level we're going to prove the theorem that ยง4.\n"
"You can see ยง5 in the *Objects* below, which means that ยง6 and ยง7\n"
"are numbers.\n"
"\n"
"We solve goals in Lean using *Tactics*, and the first tactic we're\n"
"going to learn is called ยง8, which proves all theorems of the form ยง9.\n"
"\n"
"Prove that ยง10 by executing the ยง11 tactic."
msgstr ""

#. ยง0: ```
#. repeat rw [zero_add] at h
#. exact h
#. ```
#: Game.Levels.Implication.L02exact2
msgid "Here's a two-line proof:\n"
"ยง0"
msgstr ""

#. ยง0: `zero_add x`
#. ยง1: `0 + x = x`
#. ยง2: `zero_add`
#. ยง3: `simp`
#. ยง4: `0 + x`
#. ยง5: `x`
#: Game.Levels.Addition.L01zero_add
msgid "ยง0 is the proof of ยง1.\n"
"\n"
"ยง2 is a ยง3 lemma, because replacing ยง4 by ยง5\n"
"is almost always what you want to do if you're simplifying an expression."
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: `succ_inj a b`
#. ยง3: `succ a = succ b`
#. ยง4: `a = b`
#. ยง5: $x+1=4 \\implies x=3$
#: Game.Levels.Implication.L04succ_inj
msgid "If ยง0 and ยง1 are numbers, then ยง2 is a proof\n"
"that ยง3 implies ยง4. Click on this theorem in the *Peano*\n"
"tab for more information.\n"
"\n"
"Peano had this theorem as an axiom, but in Algorithm World\n"
"we will show how to prove it in Lean. Right now let's just assume it,\n"
"and let's prove ยง5 using it. Again, we will proceed\n"
"by manipulating our hypothesis until it becomes the goal. I will\n"
"walk you through this level."
msgstr ""

#. ยง0: `2 + 2 โ 5`
#. ยง1: `0 โ 1`
#. ยง2: `zero_ne_succ n`
#. ยง3: `0 โ succ n`
#: Game.Levels.Implication.L09zero_ne_succ
msgid "As warm-up for ยง0 let's prove ยง1. To do this we need to\n"
"introduce Peano's last axiom ยง2, a proof that ยง3.\n"
"To learn about this result, click on it in the list of lemmas on the right."
msgstr ""

#. ยง0: $x+y=37$
#. ยง1: $3x+z=42$
#. ยง2: $x+y=37$
#: Game.Levels.Implication.L01exact
msgid "Assuming ยง0 and ยง1, we have ยง2."
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: $a + b = b + a$
#: Game.Levels.Addition.L03add_comm
msgid "On the set of natural numbers, addition is commutative.\n"
"In other words, if ยง0 and ยง1 are arbitrary natural numbers, then\n"
"ยง2."
msgstr ""

#. ยง0: `a * b = a * c`
#. ยง1: `a โ 0`
#. ยง2: `b = c`
#. ยง3: `induction b with d hd`
#. ยง4: `a * d = a * c โ d = c`
#. ยง5: `a * succ d = a * c`
#. ยง6: `a โ 0`
#. ยง7: `b`
#. ยง8: `c`
#. ยง9: `a * b = a * c`
#. ยง10: `b = c`
#. ยง11: `c`
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "In this level we prove that if ยง0 and ยง1 then ยง2. It is tricky, for\n"
"several reasons. One of these is that\n"
"we need to introduce a new idea: we will need to understand the concept of\n"
"mathematical induction a little better.\n"
"\n"
"Starting with ยง3 is too naive, because in the inductive step\n"
"the hypothesis is ยง4 but what we know is ยง5,\n"
"so the induction hypothesis does not apply!\n"
"\n"
"Assume ยง6 is fixed. The actual statement we want to prove by induction on ยง7 is\n"
"\"for all ยง8, if ยง9 then ยง10\". This *can* be proved by induction,\n"
"because we now have the flexibility to change ยง11."
msgstr ""

#. ยง0: `h2`
#. ยง1: `tauto`
#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "Now the goal can be deduced from ยง0 by pure logic, so use the ยง1\n"
"tactic."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Tutorial.L02rw
msgid "Now ยง0 will work."
msgstr ""

#. ยง0: `le_zero x`
#. ยง1: `x โค 0 โ x = 0`
#: Game.Levels.LessOrEqual.L05le_zero
msgid "ยง0 is a proof of the implication ยง1."
msgstr ""

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "2 + 2 โ 5"
msgstr ""

#. ยง0: `โ`
#. ยง1: `0 : โ`
#. ยง2: `succ (n : โ) : โ`
#. ยง3: `MyNat`
#. ยง4: `โ`
#. ยง5: `Nat`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "ยง0 is the natural numbers, just called \\\\\"numbers\\\\\" in this game. It's\n"
"defined via two rules:\n"
"\n"
"* ยง1 (zero is a number)\n"
"* ยง2 (the successor of a number is a number)\n"
"\n"
"## Game Implementation\n"
"\n"
"*The game uses its own copy of the natural numbers, called ยง3 with notation ยง4.\n"
"It is distinct from the Lean natural numbers ยง5, which should hopefully\n"
"never leak into the natural number game.*"
msgstr ""

#. ยง0: `a โ 0`
#. ยง1: `tauto`
#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "Multiplication usually makes a number bigger, but multiplication by zero can make\n"
"it smaller. Thus many lemmas about inequalities and multiplication need the\n"
"hypothesis ยง0. Here is a key lemma that enables us to use this hypothesis.\n"
"To help us with the proof, we can use the ยง1 tactic. Click on the tactic's name\n"
"on the right to see what it does."
msgstr ""

#. ยง0: `cases`
#. ยง1: `hxy`
#: Game.Levels.LessOrEqual.L04le_trans
msgid "In this level, we see inequalities as *hypotheses*. We have not seen this before.\n"
"The ยง0 tactic can be used to take ยง1 apart."
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: `a = b`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `0`
#. ยง6: `a`
#. ยง7: `b`
#. ยง8: `0`
#. ยง9: `0`
#. ยง10: `succ n`
#. ยง11: `a = succ m`
#. ยง12: `b = succ n`
#. ยง13: `m = n`
#. ยง14: `0 = 0`
#. ยง15: `rfl`
#. ยง16: `0 โ succ n`
#. ยง17: `zero_ne_succ n`
#. ยง18: `succ m โ 0`
#. ยง19: `succ_ne_zero m`
#. ยง20: `h : m = n`
#. ยง21: `succ m = succ n`
#. ยง22: `rw [h]`
#. ยง23: `rfl`
#. ยง24: `a โ b`
#. ยง25: `succ a โ succ b`
#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "Here we begin to\n"
"develop an algorithm which, given two naturals ยง0 and ยง1, returns the answer\n"
"to \"does ยง2?\"\n"
"\n"
"Here is the algorithm. First note that ยง3 and ยง4 are numbers, and hence\n"
"are either ยง5 or successors.\n"
"\n"
"*) If ยง6 and ยง7 are both ยง8, return \"yes\".\n"
"\n"
"*) If one is ยง9 and the other is ยง10, return \"no\".\n"
"\n"
"*) If ยง11 and ยง12, then return the answer to \"does ยง13?\"\n"
"\n"
"Our job now is to *prove* that this algorithm always gives the correct answer. The proof that\n"
"ยง14 is ยง15. The proof that ยง16 is ยง17, and the proof\n"
"that ยง18 is ยง19. The proof that if ยง20 then\n"
"ยง21 is ยง22 and then ยง23. This level is a proof of the one\n"
"remaining job we have to do: if ยง24 then ยง25."
msgstr ""

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "x โค y and y โค x implies x = y"
msgstr ""

#. ยง0: `left`
#. ยง1: `P โจ Q`
#. ยง2: `P`
#. ยง3: `P โจ Q`
#. ยง4: `P`
#. ยง5: `apply`
#. ยง6: $P \\implies P \\lor Q.$
#: Game.Levels.LessOrEqual.L07or_symm
#: Game.Levels.LessOrEqual.L07or_symm
msgid "# Summary\n"
"The ยง0 tactic changes a goal of ยง1 into a goal of ยง2.\n"
"Use it when your hypotheses guarantee that the reason that ยง3\n"
"is true is because in fact ยง4 is true.\n"
"\n"
"Internally this tactic is just ยง5ing a theorem\n"
"saying that ยง6\n"
"\n"
"Note that this tactic can turn a solvable goal into an unsolvable\n"
"one."
msgstr ""

#: Game.Levels.Multiplication
msgid "Multiplication World"
msgstr ""

#. ยง0: `le_zero`
#. ยง1: `x โค 0`
#. ยง2: `x = 0`
#. ยง3: `x โค 1`
#. ยง4: `x = 0`
#. ยง5: `x = 1`
#: Game.Levels.LessOrEqual.L10le_one
msgid "We've seen ยง0, the proof that if ยง1 then ยง2.\n"
"Now we'll prove that if ยง3 then ยง4 or ยง5."
msgstr ""

#. ยง0: $\\mathbb{N}$
#: Game
msgid "In this game you recreate the natural numbers ยง0 from the Peano axioms,\n"
"learning the basics about theorem proving in Lean.\n"
"\n"
"This is a good first introduction to Lean!"
msgstr ""

#. ยง0: `Add a b`
#. ยง1: `a + b`
#. ยง2: `add_zero a : a + 0 = a`
#. ยง3: `add_succ a b : a + succ b = succ (a + b)`
#. ยง4: `zero_add a : 0 + a = a`
#: Game.Levels.Tutorial.L05add_zero
msgid "ยง0, with notation ยง1, is\n"
"the usual sum of natural numbers. Internally it is defined\n"
"via the following two hypotheses:\n"
"\n"
"* ยง2\n"
"\n"
"* ยง3\n"
"\n"
"Other theorems about naturals, such as ยง4, are proved\n"
"by induction using these two basic theorems.\""
msgstr ""

#. ยง0: $x+1=4$
#. ยง1: $x=3$
#: Game.Levels.Implication.L04succ_inj
#: Game.Levels.Implication.L05succ_inj2
#: Game.Levels.Algorithm.L05pred
#: Game.Levels.Algorithm.L07succ_ne_succ
#: Game.Levels.AdvAddition.L05add_right_eq_zero
#: Game.Levels.AdvAddition.L06add_left_eq_zero
#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "If ยง0 then ยง1."
msgstr ""

#. ยง0: $x+y+z$
#. ยง1: $(x+y)+z$
#. ยง2: $x+(y+z)$
#. ยง3: $x+y+z$
#. ยง4: $(x+y)+z$
#. ยง5: $(x+y)+z$
#. ยง6: $x+(y+z)$
#: Game.Levels.Addition.L04add_assoc
msgid "We've been adding up two numbers; in this level we will add up three.\n"
"\n"
"  What does ยง0 *mean*? It could either mean ยง1, or it\n"
"  could mean ยง2. In Lean, ยง3 means ยง4.\n"
"\n"
"  But why do we care which one it means; ยง5 and ยง6 are *equal*!\n"
"\n"
"  That's true, but we didn't prove it yet. Let's prove it now by induction."
msgstr ""

#. ยง0: `add_left_eq_self`
#. ยง1: ```
#. rw [add_comm]
#. intro h
#. apply add_left_eq_self at h
#. exact h
#. ```
#. ยง2: ```
#. rw [add_comm]
#. exact add_left_eq_self y x
#. ```
#. ยง3: `x`
#. ยง4: ```
#. induction x with d hd
#. intro h
#. rw [zero_add] at h
#. exact h
#. intro h
#. rw [succ_add] at h
#. apply succ_inj at h
#. apply hd at h
#. exact h
#. ```
#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "Here's a proof using ยง0:\n"
"ยง1\n"
"\n"
"and here's an even shorter one using the same idea:\n"
"ยง2\n"
"\n"
"Alternatively you can just prove it by induction on ยง3:\n"
"\n"
"ยง4"
msgstr ""

#. ยง0: `add_right_eq_zero`
#. ยง1: `symm at`
#: Game.Levels.LessOrEqual.L05le_zero
msgid "You want to use ยง0, which you already\n"
"proved, but you'll have to start with ยง1 your hypothesis."
msgstr ""

#. ยง0: `1`
#. ยง1: `succ 0`
#. ยง2: `rw [one_eq_succ_zero]`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Next turn ยง0 into ยง1 with ยง2."
msgstr ""

#: Game.Levels.Implication.L07intro2
msgid "intro practice"
msgstr ""

#. ยง0: `n : โ`
#. ยง1: `n`
#. ยง2: `induction n with d hd`
#. ยง3: `n`
#. ยง4: `d`
#. ยง5: `hd`
#. ยง6: ```
#. 0 + n = n
#. ```
#. ยง7: `induction n with d hd`
#. ยง8: `0 + 0 = 0`
#. ยง9: `hd : 0 + d = d`
#. ยง10: `0 + succ d = succ d`
#: Game.Levels.Addition.L01zero_add
msgid "## Summary\n"
"\n"
"If ยง0 is an object, and the goal mentions ยง1, then ยง2\n"
"attempts to prove the goal by induction on ยง3, with the inductive\n"
"variable in the successor case being ยง4, and the inductive hypothesis being ยง5.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"ยง6\n"
"\n"
"then\n"
"\n"
"ยง7\n"
"\n"
"will turn it into two goals. The first is ยง8;\n"
"the second has an assumption ยง9 and goal\n"
"ยง10.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""

#: Game.Levels.Implication.L09zero_ne_succ
msgid "zero_ne_succ"
msgstr ""

#. ยง0: $1\\times m=m$
#. ยง1: `succ_mul`
#: Game.Levels.Multiplication.L05one_mul
msgid "You can prove ยง0 in at least three ways.\n"
"Either by induction, or by using ยง1, or\n"
"by using commutativity. Which do you think is quickest?"
msgstr ""

#. ยง0: `succ a + ยซ{d}ยป`
#. ยง1: `(succ a) + ยซ{d}ยป`
#. ยง2: `succ`
#: Game.Levels.Addition.L02succ_add
msgid "Note that ยง0 means ยง1. Put your cursor\n"
"on any ยง2 in the goal or assumptions to see what exactly it's eating."
msgstr ""

#. ยง0: `cases ยซ{h}ยป with hx hy`
#: Game.Levels.LessOrEqual.L07or_symm
msgid "We don't know whether to go left or right yet. So start with ยง0."
msgstr ""

#. ยง0: $2$
#. ยง1: $2 = 37 ร 42.$
#. ยง2: $2$
#. ยง3: $2$
#. ยง4: `mul_left_ne_zero`
#. ยง5: `one_le_of_ne_zero`
#. ยง6: `mul_le_mul_right`
#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "One day this game will have a Prime Number World, with a final boss\n"
"of proving that ยง0 is prime.\n"
"To do this, we will have to rule out things like ยง1\n"
"We will do this by proving that any factor of ยง2 is at most ยง3,\n"
"which we will do using this lemma. The proof I have in mind manipulates the hypothesis\n"
"until it becomes the goal, using ยง4, ยง5 and\n"
"ยง6."
msgstr ""

#. ยง0: `False`
#. ยง1: `True`
#. ยง2: `is_zero (succ a)`
#. ยง3: `rw [โ is_zero_succ a]`
#: Game.Levels.Algorithm.L06is_zero
msgid "We're going to change that ยง0 into ยง1. Start by changing it into\n"
"ยง2 by executing ยง3."
msgstr ""

#. ยง0: `contrapose! h`
#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "Can you take it from here? (note: if you try ยง0 again, it will\n"
"take you back to where you started!)"
msgstr ""

#. ยง0: `pow_two a`
#. ยง1: `a ^ 2 = a * a`
#: Game.Levels.Power.L05pow_two
msgid "ยง0 says that ยง1."
msgstr ""

#: Game.Levels.Implication.L04succ_inj
msgid "In the next level, we'll do the same proof but backwards."
msgstr ""

#. ยง0: ```
#. rw [mul_comm, mul_add]
#. repeat rw [mul_comm c]
#. rfl
#. ```
#: Game.Levels.Multiplication.L08add_mul
#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "Here's my proof:\n"
"ยง0"
msgstr ""

#. ยง0: `exact`
#: Game.Levels.Implication.L03apply
msgid "Now finish using the ยง0 tactic."
msgstr ""

#. ยง0: `37 ^ n`
#. ยง1: `37 ^ 0`
#. ยง2: `37 ^ (succ d)`
#. ยง3: `37 ^ d`
#. ยง4: `pow_zero (a : โ) : a ^ 0 = 1`
#. ยง5: `pow_succ (a b : โ) : a ^ succ b = a ^ b * a`
#: Game.Levels.Power
msgid "This world introduces exponentiation. If you want to define ยง0\n"
"then, as always, you will need to know what ยง1 is, and\n"
"what ยง2 is, given only ยง3.\n"
"\n"
"You can probably guess the names of the general theorems:\n"
"\n"
"  * ยง4\n"
"  * ยง5\n"
"\n"
"Using only these, can you get past the final boss level?\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship\n"
"in the summer of 2019. Thanks to Sian and also thanks to Imperial\n"
"College for funding her."
msgstr ""

#. ยง0: `h`
#. ยง1: `succ x = succ 3`
#. ยง2: `succ_inj`
#. ยง3: `rw [four_eq_succ_three] at h`
#: Game.Levels.Implication.L04succ_inj
msgid "Let's first get ยง0 into the form ยง1 so we can\n"
"apply ยง2. First execute ยง3\n"
"to change the 4 on the right hand side."
msgstr ""

#. ยง0: `rw [โ two_eq_succ_one]`
#. ยง1: `succ 1`
#. ยง2: `2`
#: Game.Levels.Tutorial.L04rw_backwards
#: Game.Levels.Tutorial.L05add_zero
msgid "Now ยง0 will change ยง1 into ยง2."
msgstr ""

#. ยง0: ```
#. intro h
#. apply succ_inj
#. repeat rw [succ_eq_add_one]
#. exact h
#. ```
#: Game.Levels.Implication.L07intro2
msgid "Here's a completely backwards proof:\n"
"ยง0"
msgstr ""

#: Game.Levels.LessOrEqual.L05le_zero
msgid "x โค 0 โ x = 0"
msgstr ""

#: Game.Levels.AdvAddition
msgid "Advanced Addition World"
msgstr ""

#. ยง0: $x$
#. ยง1: $q$
#. ยง2: $37x+q=37x+q.$
#: Game.Levels.Tutorial.L01rfl
msgid "If ยง0 and ยง1 are arbitrary natural numbers, then ยง2"
msgstr ""

#. ยง0: `left`
#: Game.Levels.LessOrEqual.L07or_symm
msgid "This time, use the ยง0 tactic."
msgstr ""

#. ยง0: $(a+b)^2=a^2+b^2$
#: Game.Levels.Power.L09add_sq
msgid "It's all over! You have proved a theorem which has tripped up\n"
"schoolkids for generations (some of them think ยง0:\n"
"this is \"the freshman's dream\").\n"
"\n"
"How many rewrites did you use? I can do it in 12.\n"
"\n"
"But wait! This boss is stirring...and mutating into a second more powerful form!"
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $c$
#. ยง3: $(a + b) \\times c = ac + bc$
#: Game.Levels.Multiplication.L08add_mul
msgid "Addition is distributive over multiplication.\n"
"In other words, for all natural numbers ยง0, ยง1 and ยง2, we have\n"
"ยง3."
msgstr ""

#. ยง0: `one_mul m`
#. ยง1: `1 * m = m`
#: Game.Levels.Multiplication.L05one_mul
msgid "ยง0 is the proof ยง1."
msgstr ""

#: Game.Levels.Algorithm.L03add_algo2
msgid "making life simple"
msgstr ""

#. ยง0: `four_eq_succ_three`
#: Game.Levels.Implication.L05succ_inj2
msgid "Now rewrite ยง0 backwards to make the goal\n"
"equal to the hypothesis."
msgstr ""

#: Game.Levels.Addition.L04add_assoc
msgid "add_assoc (associativity of addition)"
msgstr ""

#. ยง0: `add_assoc a b c`
#. ยง1: `(a + b) + c = a + (b + c)`
#. ยง2: `(a + b) + c`
#. ยง3: `a + b + c`
#: Game.Levels.Addition.L04add_assoc
msgid "ยง0 is a proof\n"
"that ยง1. Note that in Lean ยง2 prints\n"
"as ยง3, because the notation for addition is defined to be left\n"
"associative."
msgstr ""

#. ยง0: `intro h`
#: Game.Levels.Implication.L07intro2
msgid "Start with ยง0 to assume the hypothesis."
msgstr ""

#: Game.Levels.Multiplication.L04mul_comm
msgid "mul_comm"
msgstr ""

#. ยง0: `2 + 2 โ 5`
#: Game.Levels.Algorithm.L09decide2
msgid "We gave a pretty unsatisfactory proof of ยง0 earlier on; now give a nicer one."
msgstr ""

#. ยง0: $n = 0$
#. ยง1: `X = Y`
#: Game.Levels.Addition.L01zero_add
msgid "Now you have two goals. Once you proved the first, you will jump to the second one.\n"
"This first goal is the base case ยง0.\n"
"\n"
"Recall that you can rewrite the proof of any lemma which is visible\n"
"in your inventory, or of any assumption displayed above the goal,\n"
"as long as it is of the form ยง1."
msgstr ""

#. ยง0: `x + 1 = 4`
#. ยง1: `x = 3`
#. ยง2: `apply`
#: Game.Levels.Implication.L05succ_inj2
msgid "In the last level, we manipulated the hypothesis ยง0\n"
"  until it became the goal ยง1. In this level we'll manipulate\n"
"  the goal until it becomes our hypothesis! In other words, we\n"
"  will \"argue backwards\". The ยง2 tactic can do this too.\n"
"  Again I will walk you through this one (assuming you're in\n"
"  command line mode)."
msgstr ""

#. ยง0: `add_zero c`
#. ยง1: `c + 0 = c`
#. ยง2: `b + 0`
#. ยง3: `b`
#. ยง4: `rw [add_zero]`
#. ยง5: `rw [add_zero b]`
#. ยง6: `rw [add_zero]`
#: Game.Levels.Tutorial.L06add_zero2
msgid "ยง0 is a proof of ยง1 so that was what got rewritten.\n"
"You can now change ยง2 to ยง3 with ยง4 or ยง5. You\n"
"can usually stick to ยง6 unless you need real precision."
msgstr ""

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "add_right_cancel"
msgstr ""

#. ยง0: `succ_eq_add_one`
#. ยง1: `h`
#: Game.Levels.Implication.L04succ_inj
msgid "Now rewrite ยง0 backwards at ยง1\n"
"to get the right hand side."
msgstr ""

#. ยง0: `decide`
#: Game.Levels.Algorithm.L08decide
msgid "You can read more about the ยง0 tactic by clicking\n"
"on it in the top right."
msgstr ""

#. ยง0: `a โ b`
#. ยง1: `(a = b) โ False`
#. ยง2: `P`
#. ยง3: `P โ False`
#. ยง4: `P`
#. ยง5: `True โ False`
#. ยง6: `False โ False`
#. ยง7: `a โ b`
#. ยง8: `P โ Q`
#. ยง9: `a โ b`
#. ยง10: `intro h`
#. ยง11: `h`
#. ยง12: `a โ b`
#. ยง13: `apply h at h1`
#. ยง14: `h1`
#. ยง15: `a = b`
#: Game.Levels.Implication.L08ne
msgid "ยง0 is *notation* for ยง1.\n"
"\n"
"The reason this is mathematically\n"
"valid is that if ยง2 is a true-false statement then ยง3\n"
"is the logical opposite of ยง4. Indeed ยง5 is false,\n"
"and ยง6 is true!\n"
"\n"
"The upshot of this is that you can treat ยง7 in exactly\n"
"the same way as you treat any implication ยง8. For example,\n"
"if your *goal* is of the form ยง9 then you can make progress\n"
"with ยง10, and if you have a hypothesis ยง11 of the\n"
"form ยง12 then you can ยง13 if ยง14 is a proof\n"
"of ยง15."
msgstr ""

#. ยง0: `mul_assoc a b c`
#. ยง1: `(a * b) * c = a * (b * c)`
#. ยง2: `a * b * c`
#. ยง3: `(a * b) * c`
#. ยง4: `(a * b) * c = a * (b * c)`
#. ยง5: `(6 - 2) - 1`
#. ยง6: `6 - (2 - 1)`
#: Game.Levels.Multiplication.L09mul_assoc
msgid "ยง0 is a proof that ยง1.\n"
"\n"
"Note that when Lean says ยง2 it means ยง3.\n"
"\n"
"Note that ยง4 cannot be proved by \\\\\"pure thought\\\\\":\n"
"for example subtraction is not associative, as ยง5 is not\n"
"equal to ยง6."
msgstr ""

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "add_left_eq_self"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `h2`
#. ยง1: `x = y โ False`
#. ยง2: `apply`
#. ยง3: `h2`
#. ยง4: `at h1`
#: Game.Levels.Implication.L08ne
msgid "Remember that ยง0 is a proof of ยง1. Try\n"
"ยง2ing ยง3 either ยง4 or directly to the goal."
msgstr ""

#. ยง0: `apply mul_left_cancel at h`
#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "You can now ยง0"
msgstr ""

#. ยง0: `x * y = 1 โ x = 1`
#. ยง1: `x + y = 0 โ x = 0`
#. ยง2: `x โค 1`
#. ยง3: `le_one`
#. ยง4: `โค`
#. ยง5: `have`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "This level proves ยง0, the multiplicative analogue of Advanced Addition\n"
"World's ยง1. The strategy is to prove that ยง2 and then use the\n"
"lemma ยง3 from ยง4 world.\n"
"\n"
"We'll prove it using a new and very useful tactic called ยง5."
msgstr ""

#: Game.Levels.Power.L06pow_add
msgid "pow_add"
msgstr ""

#. ยง0: `rw [add_zero c]`
#: Game.Levels.Tutorial.L06add_zero2
#: Game.Levels.LessOrEqual.L08le_total
msgid "Try ยง0."
msgstr ""

#. ยง0: `{0,1,2,3,4,...}`
#. ยง1: `2 + 2 = 4`
#. ยง2: `x + y = y + x`
#: Game
msgid "# Welcome to the Natural Number Game\n"
"#### An introduction to mathematical proof.\n"
"\n"
"In this game, we will build the basic theory of the natural\n"
"numbers ยง0 from scratch. Our first goal is to prove\n"
"that ยง1. Next we'll prove that ยง2.\n"
"And at the end we'll see if we can prove Fermat's Last Theorem.\n"
"We'll do this by solving levels of a computer puzzle game called Lean.\n"
"\n"
"# Read this.\n"
"\n"
"Learning how to use an interactive theorem prover takes time.\n"
"Tests show that the people who get the most out of this game are\n"
"those who read the help texts like this one.\n"
"\n"
"To start, click on \"Tutorial World\".\n"
"\n"
"Note: this is a new Lean 4 version of the game containing several\n"
"worlds which were not present in the old Lean 3 version. More new worlds\n"
"such as Strong Induction World, Even/Odd World and Prime Number World\n"
"are in development; if you want to see their state or even help out, checkout\n"
"out the [issues in the github repo](https://github.com/leanprover-community/NNG4/issues).\n"
"\n"
"## More\n"
"\n"
"Click on the three lines in the top right and select \"Game Info\" for resources,\n"
"links, and ways to interact with the Lean community."
msgstr ""

#. ยง0: $a$
#. ยง1: $a ^ 1 = a$
#: Game.Levels.Power.L03pow_one
#: Game.Levels.Power.L04one_pow
#: Game.Levels.Power.L05pow_two
msgid "For all naturals ยง0, ยง1."
msgstr ""

#. ยง0: `decide`
#. ยง1: `DecidableEq โ`
#. ยง2: `instance`
#. ยง3: `decide`
#. ยง4: `a = b`
#. ยง5: `a โ b`
#: Game.Levels.Algorithm.L08decide
msgid "# Summary\n"
"\n"
"ยง0 will attempt to solve a goal if it can find an algorithm which it\n"
"can run to solve it.\n"
"\n"
"## Example\n"
"\n"
"A term of type ยง1 is an algorithm to decide whether two naturals\n"
"are equal or different. Hence, once this term is made and made into an ยง2,\n"
"the ยง3 tactic can use it to solve goals of the form ยง4 or ยง5."
msgstr ""

#. ยง0: `apply`
#. ยง1: `apply succ_inj at h`
#. ยง2: `h`
#. ยง3: `x = 3`
#: Game.Levels.Implication.L04succ_inj
msgid "Now let's ยง0 our new theorem. Execute ยง1\n"
"to change ยง2 to a proof of ยง3."
msgstr ""

#. ยง0: `repeat t`
#. ยง1: `t`
#. ยง2: `repeat rw [add_zero]`
#. ยง3: `a + 0 + (0 + (0 + 0)) = b + 0 + 0`
#. ยง4: `a = b`
#. ยง5: `h : X = Y`
#. ยง6: `X`
#. ยง7: `nth_rewrite 3 [h]`
#. ยง8: `X`
#. ยง9: `Y`
#. ยง10: `2 + 2 = 4`
#. ยง11: `nth_rewrite 2 [two_eq_succ_one]`
#. ยง12: `2 + succ 1 = 4`
#. ยง13: `rw [two_eq_succ_one]`
#. ยง14: `succ 1 + succ 1 = 4`
#: Game.Levels.Tutorial.L02rw
msgid "## Summary\n"
"\n"
"ยง0 repeatedly applies the tactic ยง1\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"ยง2 will turn the goal\n"
"ยง3\n"
"into the goal\n"
"ยง4.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If ยง5 and there are several ยง6s in the goal, then\n"
"ยง7 will just change the third ยง8 to a ยง9.\n"
"\n"
"## Example\n"
"\n"
"If the goal is ยง10 then ยง11\n"
"will change the goal to ยง12. In contrast, ยง13\n"
"will change the goal to ยง14."
msgstr ""

#: Game.Levels.Tutorial.L01rfl
msgid "The rfl tactic"
msgstr ""

#. ยง0: ```
#. macro \"simp_add\" : tactic => `(tactic|(
#.   simp only [add_assoc, add_left_comm, add_comm]))
#. ```
#. ยง1: `simp_add`
#. ยง2: `simp only [add_assoc, add_left_comm, add_comm]`
#. ยง3: `simp_add`
#: Game.Levels.Algorithm.L04add_algo3
msgid "You can make your own tactics in Lean.\n"
"This code here\n"
"ยง0\n"
"was used to create a new tactic ยง1, which runs\n"
"ยง2.\n"
"Try running ยง3 to solve this level!"
msgstr ""

#. ยง0: $x \\leq 1$
#. ยง1: $x = 0$
#. ยง2: $x = 1$
#: Game.Levels.LessOrEqual.L10le_one
msgid "If ยง0 then either ยง1 or ยง2."
msgstr ""

#: Game.Levels.Addition.L02succ_add
msgid "succ_add"
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#. ยง2: `c`
#: Game.Levels.Multiplication.L07mul_add
msgid "Induction on ยง0 is the most troublesome, then ยง1,\n"
"and ยง2 is the easiest."
msgstr ""

#. ยง0: $a+(b+0)+(c+0)=a+b+c.$
#: Game.Levels.Tutorial.L05add_zero
#: Game.Levels.Tutorial.L06add_zero2
#: Game.Levels.Power.L01zero_pow_zero
#: Game.Levels.Algorithm.L09decide2
#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "ยง0"
msgstr ""

#. ยง0: `zero_ne_succ`
#. ยง1: `succ_inj`
#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "2 + 2 โ 5 is boring to prove in full, given only the tools we have currently.\n"
"To make it a bit less painful, I have unfolded all of the numerals for you.\n"
"See if you can use ยง0 and ยง1 to prove this."
msgstr ""

#. ยง0: $x$
#. ยง1: $y$
#. ยง2: $x \\leq y$
#. ยง3: $y \\leq x$
#: Game.Levels.LessOrEqual.L08le_total
msgid "If ยง0 and ยง1 are numbers, then either ยง2 or ยง3."
msgstr ""

#. ยง0: `a โค b`
#. ยง1: `a โค b`
#. ยง2: `b โค c`
#. ยง3: `a โค c`
#. ยง4: `a โค b`
#. ยง5: `c`
#. ยง6: `b = a + c`
#: Game.Levels.LessOrEqual
msgid "In this world we define ยง0 and prove standard facts\n"
"about it, such as \"if ยง1 and ยง2 then ยง3.\"\n"
"\n"
"The definition of ยง4 is \"there exists a number ยง5\n"
"such that ยง6. \" So we're going to have to learn\n"
"a tactic to prove \"exists\" theorems, and another one\n"
"to use \"exists\" hypotheses.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#: Game
msgid "*Game version: 4.3*\n"
"\n"
"*Recent additions: bug fixes*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Kevin Buzzard, Jon Eugster\n"
"* **Original Lean3-version:** Kevin Buzzard, Mohammad Pedramfar\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Additional levels:** Sian Carey, Ivan Farabella, Archie Browne.\n"
"* **Additional thanks:** All the student beta testers, all the schools\n"
"who invited Kevin to speak, and all the schoolkids who asked him questions\n"
"about the material.\n"
"\n"
"## Resources\n"
"\n"
"* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n"
"* [Original Lean3 version](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/) (no longer maintained)\n"
"\n"
"## Problems?\n"
"\n"
"Please ask any questions about this game in the\n"
"[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\n"
"the stream \"New Members\". The community will happily help. Note that\n"
"the Lean Zulip chat is a professional research forum.\n"
"Please use your full real name there, stay on topic, and be nice. If you're\n"
"looking for somewhere less formal (e.g. you want to post natural number\n"
"game memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternatively, if you experience issues / bugs you can also open github issues:\n"
"\n"
"* For issues with the game engine, please open an\n"
"[issue at the lean4game](https://github.com/leanprover-community/lean4game/issues) repo.\n"
"* For issues about the game's content, please open an\n"
"[issue at the NNG](https://github.com/hhu-adam/NNG4/issues) repo."
msgstr ""

#. ยง0: $a$
#. ยง1: $m$
#. ยง2: $n$
#. ยง3: $a^{m + n} = a ^ m  a ^ n$
#: Game.Levels.Power.L06pow_add
#: Game.Levels.Power.L07mul_pow
#: Game.Levels.Power.L08pow_pow
msgid "For all naturals ยง0, ยง1, ยง2, we have ยง3."
msgstr ""

#. ยง0: ```lean
#. nth_rewrite 2 [two_eq_succ_one] -- only change the second `2` to `succ 1`.
#. rw [add_succ]
#. rw [one_eq_succ_zero]
#. rw [add_succ, add_zero] -- two rewrites at once
#. rw [โ three_eq_succ_two] -- change `succ 2` to `3`
#. rw [โ four_eq_succ_three]
#. rfl
#. ```
#. ยง1: `</>`
#. ยง2: `>_`
#. ยง3: `induction`
#: Game.Levels.Tutorial.L08twoaddtwo
msgid "Here is an example proof of 2+2=4 showing off various techniques.\n"
"\n"
"ยง0\n"
"\n"
"Optional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\n"
"on the ยง1 button in the top right. You can now see your proof\n"
"written as several lines of code. Move your cursor between lines to see\n"
"the goal state at any point. Now cut and paste your code elsewhere if you\n"
"want to save it, and paste the above proof in instead. Move your cursor\n"
"around to investigate. When you've finished, click the ยง2 button in the top right to\n"
"move back into \"Typewriter mode\".\n"
"\n"
"You have finished tutorial world!\n"
"Click \"Leave World\" to go back to the\n"
"overworld, and select Addition World, where you will learn\n"
"about the ยง3 tactic."
msgstr ""

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "mul_left_cancel"
msgstr ""

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "You can just mimic the previous proof to do this one -- or you can figure out a way\n"
"of using it."
msgstr ""

#. ยง0: `0`
#. ยง1: `n`
#. ยง2: `succ n`
#. ยง3: `n`
#. ยง4: `n`
#. ยง5: `n`
#. ยง6: `0`
#. ยง7: `succ 0`
#. ยง8: `1`
#. ยง9: `2 = succ 1`
#. ยง10: `3 = succ 2`
#. ยง11: `4 = succ 3`
#. ยง12: `2 = succ 1`
#. ยง13: `two_eq_succ_one`
#. ยง14: $2$
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "## The birth of number.\n"
"\n"
"Numbers in Lean are defined by two rules.\n"
"\n"
"* ยง0 is a number.\n"
"* If ยง1 is a number, then the *successor* ยง2 of ยง3 is a number.\n"
"\n"
"The successor of ยง4 means the number after ยง5. Let's learn to\n"
"count, and name a few small numbers.\n"
"\n"
"## Counting to four.\n"
"\n"
"ยง6 is a number, so ยง7 is a number. Let's call this new number ยง8.\n"
"Similarly let's define ยง9, ยง10 and ยง11.\n"
"This gives us plenty of numbers to be getting along with.\n"
"\n"
"The *proof* that ยง12 is called ยง13.\n"
"Check out the \"012\" tab in the list of lemmas on the right\n"
"for this and other proofs.\n"
"\n"
"Let's prove that ยง14 is the number after the number after zero."
msgstr ""

#. ยง0: `rw [โ succ_eq_add_one] at h`
#: Game.Levels.Implication.L04succ_inj
msgid "Concretely: ยง0."
msgstr ""

#. ยง0: `pow_zero a : a ^ 0 = 1`
#: Game.Levels.Power.L01zero_pow_zero
msgid "ยง0 is one of the two axioms\n"
"defining exponentiation in this game."
msgstr ""

#. ยง0: $a, b$
#. ยง1: $c$
#. ยง2: $(a + b) + c = (a + c) + b$
#: Game.Levels.Addition.L05add_right_comm
msgid "If ยง0 and ยง1 are arbitrary natural numbers, we have\n"
"ยง2."
msgstr ""

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "The lemma proved in the final level of this world will be helpful\n"
"in Divisibility World."
msgstr ""

#. ยง0: `pow_one a`
#. ยง1: `a ^ 1 = a`
#. ยง2: `a ^ 1`
#. ยง3: `a ^ 0 * a`
#. ยง4: `1 * a`
#. ยง5: `a`
#: Game.Levels.Power.L03pow_one
msgid "ยง0 says that ยง1.\n"
"\n"
"Note that this is not quite true by definition: ยง2 is\n"
"defined to be ยง3 so it's ยง4, and to prove\n"
"that this is equal to ยง5 you need to use induction somewhere."
msgstr ""

#. ยง0: `add_right_eq_self x y`
#. ยง1: $x + y = x\\implies y=0.$
#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "ยง0 is the theorem that ยง1\n"
"Two ways to do it spring to mind; I'll mention them when you've solved it."
msgstr ""

#. ยง0: $2+2=4$
#. ยง1: $a+b+c+d+e=e+d+c+b+a$
#: Game.Levels.Algorithm
msgid "Proofs like ยง0 and ยง1 are very tedious to do by hand.\n"
"In Algorithm World we learn how to get the computer to do them for us.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#: Game.Levels.Implication.L02exact2
msgid "If the goal is not *exactly* a hypothesis, we can sometimes\n"
"use rewrites to fix things up."
msgstr ""

#: Game.Levels.Algorithm.L06is_zero
msgid "See if you can take it from here. Look at the new lemmas and tactic\n"
"available on the right."
msgstr ""

#. ยง0: `rw [add_left_comm b c]`
#. ยง1: `b`
#. ยง2: `c`
#: Game.Levels.Algorithm.L02add_algo1
msgid "Now use ยง0 to switch ยง1 and ยง2 on the left\n"
"hand side."
msgstr ""

#: Game.Levels.Implication
msgid "Implication World"
msgstr ""

#. ยง0: `add_succ`
#: Game.Levels.Tutorial.L06add_zero2
msgid "Let's now learn about Peano's second axiom for addition, ยง0."
msgstr ""

#. ยง0: `h2`
#. ยง1: `x = 37`
#. ยง2: `y = 42`
#. ยง3: `apply`
#. ยง4: `apply`
#: Game.Levels.Implication.L03apply
msgid "In this level, the hypotheses ยง0 is an *implication*. It says\n"
"that *if* ยง1 *then* ยง2. We can use this\n"
"hypothesis with the ยง3 tactic. Remember you can click on\n"
"ยง4 or any other tactic on the right to see a detailed explanation\n"
"of what it does, with examples."
msgstr ""

#. ยง0: `add_comm b c`
#. ยง1: `b + c = c + b`
#. ยง2: `a + b + c = a + c + b`
#. ยง3: `rw [add_comm b c]`
#. ยง4: `(a + b) + c = (a + c) + b`
#. ยง5: `b + c`
#. ยง6: `add_right_comm`
#. ยง7: `add_assoc`
#. ยง8: `add_comm`
#. ยง9: `rw [add_comm b]`
#. ยง10: `b + ? = ? + b`
#. ยง11: `rw [add_comm b c]`
#. ยง12: `b + c = c + b`
#: Game.Levels.Addition.L05add_right_comm
msgid "ยง0 is a proof that ยง1. But if your goal\n"
"is ยง2 then ยง3 will not\n"
"work! Because the goal means ยง4 so there\n"
"is no ยง5 term *directly* in the goal.\n"
"\n"
"Use associativity and commutativity to prove ยง6.\n"
"You don't need induction. ยง7 moves brackets around,\n"
"and ยง8 moves variables around.\n"
"\n"
"Remember that you can do more targetted rewrites by\n"
"adding explicit variables as inputs to theorems. For example ยง9\n"
"will only do rewrites of the form ยง10, and ยง11\n"
"will only do rewrites of the form ยง12."
msgstr ""

#. ยง0: `h`
#. ยง1: `X = Y`
#. ยง2: `rw [h]`
#. ยง3: `X`
#. ยง4: `Y`
#. ยง5: `rw [โ h]`
#. ยง6: `Y`
#. ยง7: `X`
#. ยง8: `\\left `
#. ยง9: `\\l`
#. ยง10: `rw [h1, h2]`
#. ยง11: `rw [h] at h2`
#. ยง12: `X`
#. ยง13: `Y`
#. ยง14: `h2`
#. ยง15: `rw [h] at h1 h2 โข`
#. ยง16: `X`
#. ยง17: `Y`
#. ยง18: `โข`
#. ยง19: `\\|-`
#. ยง20: `repeat rw [add_zero]`
#. ยง21: `? + 0`
#. ยง22: `?`
#. ยง23: `? + 0`
#. ยง24: `nth_rewrite 2 [h]`
#. ยง25: `X`
#. ยง26: `Y`
#. ยง27: `h : x = y + y`
#. ยง28: ```
#. succ (x + 0) = succ (y + y)
#. ```
#. ยง29: `rw [add_zero]`
#. ยง30: `succ x = succ (y + y)`
#. ยง31: `rw [h]`
#. ยง32: `succ (y + y) = succ (y + y)`
#. ยง33: `rfl`
#. ยง34: `rw`
#. ยง35: ```
#. h1 : x = y + 3
#. h2 : 2 * y = x
#. ```
#. ยง36: `rw [h1] at h2`
#. ยง37: `h2`
#. ยง38: `h2 : 2 * y = y + 3`
#. ยง39: `rw h`
#. ยง40: `h`
#. ยง41: `A = B`
#. ยง42: `h`
#. ยง43: `rw`
#. ยง44: `rw [P = Q]`
#. ยง45: `P = Q`
#. ยง46: `h : P = Q`
#. ยง47: `rw [h]`
#. ยง48: `rw`
#. ยง49: `h : A = B`
#. ยง50: `A`
#. ยง51: `rw [h]`
#. ยง52: `B`
#. ยง53: `A`
#. ยง54: `add_zero`
#. ยง55: `? + 0 = ?`
#. ยง56: `add_zero`
#. ยง57: `?`
#. ยง58: `rw`
#. ยง59: `x + 0`
#. ยง60: `?`
#. ยง61: `x`
#. ยง62: `x + 0`
#. ยง63: `x`
#. ยง64: `rw [add_zero]`
#. ยง65: `(0 + 0) + (x + 0) + (0 + 0) + (x + 0)`
#. ยง66: `0 + (x + 0) + 0 + (x + 0)`
#. ยง67: `b + c + a = b + (a + c)`
#. ยง68: `a + c`
#. ยง69: `c + a`
#. ยง70: `rw [add_comm]`
#. ยง71: `rw [add_comm a c]`
#. ยง72: `a + c`
#. ยง73: `c + a`
#. ยง74: `add_comm`
#. ยง75: `?1 + ?2 = ?2 + ?1`
#. ยง76: `add_comm a`
#. ยง77: `a + ? = ? + a`
#. ยง78: `add_comm a c`
#. ยง79: `a + c = c + a`
#. ยง80: `h : X = Y`
#. ยง81: `rw [h]`
#. ยง82: `X`
#. ยง83: `Y`
#. ยง84: `X`
#. ยง85: `Y`
#. ยง86: `nth_rewrite 37 [h]`
#: Game.Levels.Tutorial.L02rw
msgid "## Summary\n"
"\n"
"If ยง0 is a proof of an equality ยง1, then ยง2 will change\n"
"all ยง3s in the goal to ยง4s. It's the way to \\\\\"substitute in\\\\\".\n"
"\n"
"## Variants\n"
"\n"
"* ยง5 (changes ยง6s to ยง7s; get the back arrow by typing ยง8 or ยง9.)\n"
"\n"
"* ยง10 (a sequence of rewrites)\n"
"\n"
"* ยง11 (changes ยง12s to ยง13s in hypothesis ยง14)\n"
"\n"
"* ยง15 (changes ยง16s to ยง17s in two hypotheses and the goal;\n"
"get the ยง18 symbol with ยง19.)\n"
"\n"
"* ยง20 will keep changing ยง21 to ยง22\n"
"until there are no more matches for ยง23.\n"
"\n"
"* ยง24 will change only the second ยง25 in the goal to ยง26.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption ยง27 and your goal is\n"
"ยง28\n"
"\n"
"then\n"
"\n"
"ยง29\n"
"\n"
"will change the goal into ยง30, and then\n"
"\n"
"ยง31\n"
"\n"
"will change the goal into ยง32, which\n"
"can be solved with ยง33.\n"
"\n"
"### Example:\n"
"\n"
"You can use ยง34 to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"ยง35\n"
"then ยง36 will turn ยง37 into ยง38.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. ยง39 is never correct.\n"
"\n"
"* If ยง40 is not a *proof* of an *equality* (a statement of the form ยง41),\n"
"for example if ยง42 is a function or an implication,\n"
"then ยง43 is not the tactic you want to use. For example,\n"
"ยง44 is never correct: ยง45 is the theorem *statement*,\n"
"not the proof. If ยง46 is the proof, then ยง47 will work.\n"
"\n"
"## Details\n"
"\n"
"The ยง48 tactic is a way to do \\\\\"substituting in\\\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if ยง49 is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more ยง50s, then ยง51\n"
"will change them all to ยง52s. The tactic will error\n"
"if there are no ยง53s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example ยง54\n"
"is a proof that ยง55 because ยง56 really is a function,\n"
"and ยง57 is the input. In this situation ยง58 will look through the goal\n"
"for any subterm of the form ยง59, and the moment it\n"
"finds one it fixes ยง60 to be ยง61 then changes all ยง62s to ยง63s.\n"
"\n"
"Exercise: think about why ยง64 changes the term\n"
"ยง65 to\n"
"ยง66\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targetted usage\n"
"\n"
"If your goal is ยง67 and you want to rewrite ยง68\n"
"to ยง69, then ยง70 will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use ยง71 to\n"
"guarantee that Lean rewrites ยง72 to ยง73. This works because\n"
"ยง74 is a proof that ยง75, ยง76 is a proof\n"
"that ยง77, and ยง78 is a proof that ยง79.\n"
"\n"
"If ยง80 then ยง81 will turn all ยง82s into ยง83s.\n"
"If you only want to change the 37th occurrence of ยง84\n"
"to ยง85 then do ยง86."
msgstr ""

#. ยง0: $a, b,\\ldots h$
#. ยง1: $(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$
#: Game.Levels.Algorithm.L03add_algo2
#: Game.Levels.Algorithm.L04add_algo3
msgid "If ยง0 are arbitrary natural numbers, we have\n"
"ยง1."
msgstr ""

#. ยง0: ```
#. instance instDecidableEq : DecidableEq โ
#. | 0, 0 => isTrue <| by
#.   show 0 = 0
#.   rfl
#. | succ m, 0 => isFalse <| by
#.   show succ m โ 0
#.   exact succ_ne_zero m
#. | 0, succ n => isFalse <| by
#.   show 0 โ succ n
#.   exact zero_ne_succ n
#. | succ m, succ n =>
#.   match instDecidableEq m n with
#.   | isTrue (h : m = n) => isTrue <| by
#.     show succ m = succ n
#.     rw [h]
#.     rfl
#.   | isFalse (h : m โ n) => isFalse <| by
#.     show succ m โ succ n
#.     exact succ_ne_succ m n h
#. ```
#. ยง1: `decide`
#: Game.Levels.Algorithm.L08decide
msgid "Implementing the algorithm for equality of naturals, and the proof that it is correct,\n"
"looks like this:\n"
"\n"
"ยง0\n"
"\n"
"This Lean code is a formally verified algorithm for deciding equality\n"
"between two naturals. I've typed it in already, behind the scenes.\n"
"Because the algorithm is formally verified to be correct, we can\n"
"use it in Lean proofs. You can run the algorithm with the ยง1 tactic."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `intro h`
#. ยง2: `h : P`
#. ยง3: `Q`
#. ยง4: $P \\implies Q$
#. ยง5: $P$
#. ยง6: $Q$
#. ยง7: `x + 1 = y + 1 โ x = y`
#. ยง8: $x+1=y+1 \\implies x=y$
#. ยง9: `intro h`
#. ยง10: $x+1=y+1$
#. ยง11: `h`
#. ยง12: $x=y$
#: Game.Levels.Implication.L06intro
msgid "## Summary\n"
"\n"
"If the goal is ยง0, then ยง1 will introduce ยง2 as a hypothesis,\n"
"and change the goal to ยง3. Mathematically, it says that to prove ยง4,\n"
"we can assume ยง5 and then prove ยง6.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is ยง7 (the way Lean writes ยง8)\n"
"then ยง9 will give you a hypothesis ยง10 named ยง11, and the goal\n"
"will change to ยง12."
msgstr ""

#. ยง0: `rw [add_zero]`
#. ยง1: `b + 0`
#. ยง2: `b`
#: Game.Levels.Tutorial.L05add_zero
msgid "ยง0 will change ยง1 into ยง2."
msgstr ""

#. ยง0: `apply h2 at h1`
#. ยง1: `h1`
#. ยง2: `y = 42`
#: Game.Levels.Implication.L03apply
msgid "Start with ยง0. This will change ยง1 to ยง2."
msgstr ""

#: Game.Levels.Tutorial.L07add_succ
msgid "[dramatic music]. Now are you ready to face the first boss of the game?"
msgstr ""

#. ยง0: $x+y=x\\implies y=0$
#. ยง1: `โค`
#: Game.Levels.AdvAddition
msgid "In Advanced Addition World we will prove some basic\n"
"addition facts such as ยง0. The theorems\n"
"proved in this world will be used to build\n"
"a theory of inequalities in ยง1 World.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#. ยง0: `tauto`
#. ยง1: `tauto`
#. ยง2: `add_zero`
#. ยง3: `tauto`
#. ยง4: `a = a`
#. ยง5: `0 โ 1`
#. ยง6: `0 โ 2`
#. ยง7: `1 โ 2`
#. ยง8: `tauto`
#. ยง9: `x < 37`
#. ยง10: `x < 37 โ y + z = 42`
#. ยง11: `y + z = 42`
#. ยง12: `tauto`
#. ยง13: `False`
#. ยง14: `tauto`
#. ยง15: `True`
#. ยง16: `tauto`
#. ยง17: `h1 : a = 37`
#. ยง18: `h2 : a โ 37`
#. ยง19: `tauto`
#. ยง20: `False`
#. ยง21: `False`
#. ยง22: `h : a โ a`
#. ยง23: `tauto`
#. ยง24: `tauto`
#. ยง25: `a = a`
#. ยง26: `h : 0 = 1`
#. ยง27: `tauto`
#. ยง28: `tauto`
#. ยง29: `0 โ 1`
#. ยง30: `False`
#. ยง31: `a = 0 โ a * b = 0`
#. ยง32: `a * b โ 0 โ a โ 0`
#. ยง33: `tauto`
#. ยง34: `tauto`
#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "# Summary\n"
"\n"
"The ยง0 tactic will solve any goal which can be solved purely by logic (that is, by\n"
"truth tables).\n"
"\n"
"## Details\n"
"\n"
"ยง1 *does not do magic*! It doesn't know *anything* about addition or multiplication,\n"
"it doesn't even know ยง2. The only things that ยง3 knows about numbers\n"
"are firstly that ยง4 and secondly that ยง5, ยง6, ยง7 and so on.\n"
"What ยง8's strength is, is *logic*. If you have a hypothesis ยง9\n"
"and another hypothesis ยง10 and your goal is ยง11 then ยง12 will\n"
"solve this goal, because to solve that goal you don't need to know any facts\n"
"about inequalities or addition, all you need to know is the rules of logic.\n"
"\n"
"## Example\n"
"\n"
"If you have ยง13 as a hypothesis, then ยง14 will solve\n"
"the goal. This is because a false hypothesis implies any hypothesis.\n"
"\n"
"## Example\n"
"\n"
"If your goal is ยง15, then ยง16 will solve the goal.\n"
"\n"
"## Example\n"
"\n"
"If you have two hypotheses ยง17 and ยง18 then ยง19 will\n"
"solve the goal because it can prove ยง20 from your hypotheses, and thus\n"
"prove the goal (as ยง21 implies anything).\n"
"\n"
"## Example\n"
"\n"
"If you have one hypothesis ยง22 then ยง23 will solve the goal because\n"
"ยง24 is smart enough to know that ยง25 is true, which gives the contradiction we seek.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis ยง26 then ยง27 will solve the goal, because\n"
"ยง28 knows ยง29 and this is enough to prove ยง30, which implies any goal.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis of the form ยง31 and your goal is ยง32, then\n"
"ยง33 will solve the goal, because the goal is logically equivalent to the hypothesis.\n"
"If you switch the goal and hypothesis in this example, ยง34 would solve it too."
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Now finish the job with ยง0."
msgstr ""

#. ยง0: `nth_rewrite 2 [โ mul_one a] at h`
#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "Reduce to the previous lemma with ยง0"
msgstr ""

#. ยง0: `le_mul_right a b`
#. ยง1: `a * b โ 0 โ a โค a * b`
#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "ยง0 is a proof that ยง1.\n"
"\n"
"It's one way of saying that a divisor of a positive number\n"
"has to be at most that number."
msgstr ""

#. ยง0: $m$
#. ยง1: $0 ^{\\operatorname{succ} (m)} = 0$
#: Game.Levels.Power.L02zero_pow_succ
msgid "For all numbers ยง0, ยง1."
msgstr ""

#. ยง0: `n`
#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "Start with induction on ยง0."
msgstr ""

#: Game.Levels.LessOrEqual.L08le_total
msgid "x โค y or y โค x"
msgstr ""

#. ยง0: `use`
#. ยง1: `c`
#. ยง2: `x = 0 + c`
#: Game.Levels.LessOrEqual.L02zero_le
msgid "To solve this level, you need to ยง0 a number ยง1 such that ยง2."
msgstr ""

#. ยง0: `le_mul_right`
#. ยง1: `x * y โ 0`
#. ยง2: `have h2 : x * y โ 0`
#. ยง3: `โ`
#. ยง4: `\\ne`
#. ยง5: `le_mul_right`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "We want to use ยง0, but we need a hypothesis ยง1\n"
"which we don't have. Yet. Execute ยง2 (you can type ยง3 with ยง4).\n"
"You'll be asked to\n"
"prove it, and then you'll have a new hypothesis which you can apply\n"
"ยง5 to."
msgstr ""

#. ยง0: $x=37$
#. ยง1: $x=37\\implies y=42$
#. ยง2: $y=42$
#: Game.Levels.Implication.L03apply
msgid "If ยง0 and we know that ยง1 then we can deduce ยง2."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `X = X`
#. ยง2: `rfl`
#. ยง3: `A = B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `rfl`
#. ยง7: ```
#. x + 37 = x + 37
#. ```
#. ยง8: `rfl`
#. ยง9: `0 + x = x`
#. ยง10: `rfl`
#. ยง11: $0+x$
#. ยง12: $x$
#. ยง13: `0 + x`
#. ยง14: `0 + x`
#. ยง15: `rfl`
#. ยง16: `rfl`
#. ยง17: `mathlib`
#. ยง18: `zero_add`
#. ยง19: `add_zero`
#: Game.Levels.Tutorial.L01rfl
msgid "## Summary\n"
"\n"
"ยง0 proves goals of the form ยง1.\n"
"\n"
"In other words, the ยง2 tactic will close any goal of the\n"
"form ยง3 if ยง4 and ยง5 are *identical*.\n"
"\n"
"ยง6 is short for \\\\\"reflexivity (of equality)\\\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"ยง7\n"
"\n"
"then ยง8 will close it. But if it looks like ยง9 then ยง10 won't work, because even\n"
"though ยง11 and ยง12 are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to ยง13 is ยง14.\n"
"\n"
"## Details\n"
"\n"
"ยง15 is short for \\\\\"reflexivity of equality\\\\\".\n"
"\n"
"## Game Implementation\n"
"\n"
"*Note that our ยง16 is weaker than the version used in core Lean and ยง17,\n"
"for pedagogical purposes; mathematicians do not distinguish between propositional\n"
"and definitional equality because they think about definitions in a different way\n"
"to type theorists (ยง18 and ยง19 are both \\\\\"facts\\\\\" as far\n"
"as mathematicians are concerned, and who cares what the definition of addition is).*"
msgstr ""

#. ยง0: `b = 0`
#. ยง1: `a * b = 0`
#. ยง2: `X โ 0`
#. ยง3: `X = 0 โ False`
#. ยง4: `Show more help!`
#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "We want to reduce this to a hypothesis ยง0 and a goal ยง1,\n"
"which is logically equivalent but much easier to prove. Remember that ยง2\n"
"is notation for ยง3. Click on ยง4 if you need hints."
msgstr ""

#. ยง0: `repeat rw [add_zero]`
#: Game.Levels.Tutorial.L05add_zero
msgid "Those of you interested in speedrunning the game may want to know\n"
"that ยง0 will do both rewrites at once."
msgstr ""

#. ยง0: $0$
#. ยง1: $0$
#. ยง2: `37 + d = q`
#. ยง3: `37 + succ d`
#. ยง4: `succ d`
#. ยง5: `d`
#. ยง6: `37 + succ d`
#. ยง7: `succ q`
#. ยง8: `q`
#. ยง9: `x + succ d`
#. ยง10: `succ (x + d)`
#. ยง11: `add_succ x d : x + succ d = succ (x + d)`
#. ยง12: `... + succ ...`
#. ยง13: `rw [add_succ]`
#. ยง14: `succ n = n + 1`
#. ยง15: `+ succ`
#. ยง16: `rw [add_succ]`
#. ยง17: `+`
#. ยง18: `012`
#: Game.Levels.Tutorial.L07add_succ
msgid "Every number in Lean is either ยง0 or a successor. We know how to add ยง1,\n"
"but we need to figure out how to add successors. Let's say we already know\n"
"that ยง2. What should the answer to ยง3 be? Well,\n"
"ยง4 is one bigger than ยง5, so ยง6 should be ยง7,\n"
"the number one bigger than ยง8. More generally ยง9 should\n"
"be ยง10. Let's add this as a lemma.\n"
"\n"
"* ยง11\n"
"\n"
"If you ever see ยง12 in your goal, ยง13 is\n"
"normally a good idea.\n"
"\n"
"Let's now prove that ยง14. Figure out how to get ยง15 into\n"
"the picture, and then ยง16. Switch between the ยง17 (addition) and\n"
"ยง18 (numerals) tabs under \"Theorems\" on the right to\n"
"see which proofs you can rewrite."
msgstr ""

#. ยง0: `trivial`
#. ยง1: `True`
#: Game.Levels.Algorithm.L06is_zero
msgid "# Summary\n"
"\n"
"ยง0 will solve the goal ยง1."
msgstr ""

#. ยง0: $0^0=1$
#. ยง1: $0^n=0$
#. ยง2: $n>0$
#. ยง3: $n$
#: Game.Levels.Power.L02zero_pow_succ
msgid "Although ยง0 in this game, ยง1 if ยง2, i.e., if\n"
"ยง3 is a successor."
msgstr ""

#. ยง0: `b = 0`
#. ยง1: `b โ 0`
#. ยง2: `cases b with d`
#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "Here we want to deal with the cases ยง0 and ยง1 separately,\n"
"so start with ยง2."
msgstr ""

#. ยง0: `hd`
#. ยง1: `c`
#. ยง2: `a * d = a * c โ d = c`
#. ยง3: `apply`
#. ยง4: `at`
#. ยง5: `a * d = a * ?`
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "The inductive hypothesis ยง0 is \"For all natural numbers ยง1, ยง2\".\n"
"You can ยง3 it ยง4 any hypothesis of the form ยง5."
msgstr ""

#: Game.Levels.Multiplication.L07mul_add
msgid "You can do induction on any of the three variables. Some choices\n"
"are harder to push through than others. Can you do the inductive step in\n"
"5 rewrites only?"
msgstr ""

#. ยง0: `0 + ยซ{d}ยป`
#. ยง1: `rw [ยซ{hd}ยป]`
#: Game.Levels.Addition.L01zero_add
msgid "At this point you see the term ยง0, so you can use the\n"
"induction hypothesis with ยง1."
msgstr ""

#. ยง0: `0 ^ 0`
#. ยง1: `0 ^ 0 = 1`
#: Game.Levels.Power.L01zero_pow_zero
msgid "Mathematicians sometimes debate what ยง0 is;\n"
"the answer depends, of course, on your definitions. In this\n"
"game, ยง1. See if you can prove it.\n"
"\n"
"Check out the *Pow* tab in your list of theorems\n"
"to see the new proofs which are available."
msgstr ""

#. ยง0: `1`
#. ยง1: `succ 0`
#. ยง2: `h`
#: Game.Levels.Implication.L09zero_ne_succ
msgid "Now change ยง0 to ยง1 in ยง2."
msgstr ""

#. ยง0: `apply t at h`
#. ยง1: `apply t`
#. ยง2: `apply`
#: Game.Levels.Implication.L05succ_inj2
msgid "Many people find ยง0 easy, but some find ยง1 confusing.\n"
"If you find it confusing, then just argue forwards.\n"
"\n"
"You can read more about the ยง2 tactic in its documentation, which you can view by\n"
"clicking on the tactic in the list on the right."
msgstr ""

#: Game.Levels.Algorithm.L03add_algo2
msgid "Let's now make our own tactic to do this."
msgstr ""

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "add_left_eq_zero"
msgstr ""

#. ยง0: `rw [add_succ]`
#: Game.Levels.Tutorial.L07add_succ
#: Game.Levels.Tutorial.L08twoaddtwo
msgid "Now you can ยง0"
msgstr ""

#. ยง0: `โ`
#. ยง1: `rw`
#. ยง2: `rw`
#. ยง3: `โ`
#. ยง4: `\\l`
#: Game.Levels.Implication.L04succ_inj
msgid "You can put a ยง0 in front of any theorem provided to ยง1 to rewrite\n"
"the other way around. Look at the docs for ยง2 for an explanation. Type ยง3 with ยง4."
msgstr ""

#. ยง0: `exact h`
#: Game.Levels.Implication.L05succ_inj2
msgid "You can now finish with ยง0."
msgstr ""

#: Game
msgid "Natural Number Game"
msgstr ""

#. ยง0: ```
#. rw [add_comm]
#. exact add_right_eq_zero b a
#. ```
#. ยง1: `โค`
#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "How about this for a proof:\n"
"\n"
"ยง0\n"
"\n"
"That's the end of Advanced Addition World! You'll need these theorems\n"
"for the next world, ยง1 World. Click on \"Leave World\" to access it."
msgstr ""

#. ยง0: `n`
#. ยง1: `cases n with d`
#. ยง2: `n = 0`
#. ยง3: `n = succ d`
#. ยง4: `h`
#. ยง5: `cases h with...`
#. ยง6: `n : โ`
#. ยง7: `cases n with d`
#. ยง8: `n`
#. ยง9: `n`
#. ยง10: `succ d`
#. ยง11: `0`
#. ยง12: `h : P โจ Q`
#. ยง13: `cases h with hp hq`
#. ยง14: `hp : P`
#. ยง15: `hq : Q`
#. ยง16: `h : False`
#. ยง17: `cases h`
#. ยง18: `False`
#. ยง19: `h : a โค b`
#. ยง20: `cases h with c hc`
#. ยง21: `c`
#. ยง22: `hc : b = a + c`
#. ยง23: `a โค b`
#. ยง24: `โ c, b = a + c`
#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "## Summary\n"
"\n"
"If ยง0 is a number, then ยง1 will break the goal into two goals,\n"
"one with ยง2 and the other with ยง3.\n"
"\n"
"If ยง4 is a proof (for example a hypothesis), then ยง5 will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If ยง6 is a number, then ยง7 will break the goal into two goals,\n"
"one with ยง8 replaced by 0 and the other with ยง9 replaced by ยง10. This\n"
"corresponds to the mathematical idea that every natural number is either ยง11\n"
"or a successor.\n"
"\n"
"## Example\n"
"\n"
"If ยง12 is a hypothesis, then ยง13 will turn one goal\n"
"into two goals, one with a hypothesis ยง14 and the other with a\n"
"hypothesis ยง15.\n"
"\n"
"## Example\n"
"\n"
"If ยง16 is a hypothesis, then ยง17 will turn one goal into no goals,\n"
"because there are no ways to make a proof of ยง18! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"## Example\n"
"\n"
"If ยง19 is a hypothesis, then ยง20 will create a new number ยง21\n"
"and a proof ยง22. This is because the *definition* of ยง23 is\n"
"ยง24."
msgstr ""

#. ยง0: `ยซ{ha}ยป`
#. ยง1: `ยซ{y}ยป = ยซ{x}ยป + ยซ{a}ยป`
#. ยง2: `hxy`
#. ยง3: `ยซ{hyz}ยป`
#. ยง4: `cases ยซ{hyz}ยป with b hb`
#: Game.Levels.LessOrEqual.L04le_trans
msgid "Now ยง0 is a proof that ยง1, and ยง2 has vanished. Similarly, you can destruct\n"
"ยง3 into its parts with ยง4."
msgstr ""

#: Game.Levels.Implication.L04succ_inj
msgid "succ_inj : the successor function is injective"
msgstr ""

#. ยง0: `b + 0`
#. ยง1: `c + 0`
#. ยง2: `rw [add_zero]`
#. ยง3: `b + 0`
#. ยง4: `c + 0`
#. ยง5: `add_zero`
#: Game.Levels.Tutorial.L06add_zero2
msgid "## Precision rewriting\n"
"\n"
"In the last level, there was ยง0 and ยง1,\n"
"and ยง2 changed the first one it saw,\n"
"which was ยง3. Let's learn how to tell Lean\n"
"to change ยง4 first by giving ยง5 an\n"
"explicit input."
msgstr ""

#. ยง0: `a โค b`
#. ยง1: `โ c, b = a + c`
#. ยง2: `a โค b`
#. ยง3: `use`
#. ยง4: `h : a โค b`
#. ยง5: `cases h with c hc`
#: Game.Levels.LessOrEqual.L01le_refl
msgid "ยง0 is *notation* for ยง1.\n"
"\n"
"Because this game doesn't have negative numbers, this definition\n"
"is mathematically valid.\n"
"\n"
"This means that if you have a goal of the form ยง2 you can\n"
"make progress with the ยง3 tactic, and if you have a hypothesis\n"
"ยง4, you can make progress with ยง5."
msgstr ""

#. ยง0: `exact h`
#: Game.Levels.Implication.L06intro
msgid "Now ยง0 finishes the job."
msgstr ""

#. ยง0: `ยซ{x}ยป โค ยซ{x}ยป`
#. ยง1: `ยซ{x}ยป = ยซ{x}ยป + 0`
#. ยง2: `use 0`
#: Game.Levels.LessOrEqual.L01le_refl
msgid "The reason ยง0 is because ยง1.\n"
"So you should start this proof with ยง2."
msgstr ""

#. ยง0: $x \\leq y$
#. ยง1: $y \\leq z$
#. ยง2: $x \\leq z$
#: Game.Levels.LessOrEqual.L04le_trans
#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "If ยง0 and ยง1, then ยง2."
msgstr ""

#. ยง0: ```
#. apply mul_left_ne_zero at h
#. apply one_le_of_ne_zero at h
#. apply mul_le_mul_right 1 b a at h
#. rw [one_mul, mul_comm] at h
#. exact h
#. ```
#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "Here's what I was thinking of:\n"
"ยง0"
msgstr ""

#. ยง0: `nth_rewrite 2 [two_eq_succ_one]`
#. ยง1: `rw [two_eq_succ_one]`
#: Game.Levels.Tutorial.L08twoaddtwo
msgid "ยง0 is I think quicker than ยง1."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: $a, b$
#. ยง1: $c$
#. ยง2: $ (a + b) + c = a + (b + c). $
#: Game.Levels.Addition.L04add_assoc
msgid "On the set of natural numbers, addition is associative.\n"
"In other words, if ยง0 and ยง1 are arbitrary natural numbers, we have\n"
"ยง2"
msgstr ""

#. ยง0: `use`
#: Game.Levels.LessOrEqual.L04le_trans
msgid "Now you need to figure out which number to ยง0. See if you can take it from here."
msgstr ""

#. ยง0: `t : P โ Q`
#. ยง1: $P \\implies Q$
#. ยง2: `h : P`
#. ยง3: `P`
#. ยง4: `apply t at h`
#. ยง5: `h`
#. ยง6: `Q`
#. ยง7: `P`
#. ยง8: `t`
#. ยง9: `Q`
#. ยง10: `Q`
#. ยง11: `apply t`
#. ยง12: `P`
#. ยง13: `Q`
#. ยง14: `t`
#. ยง15: `P`
#. ยง16: `P`
#. ยง17: `succ_inj x y`
#. ยง18: `succ x = succ y โ x = y`
#. ยง19: `h : succ (a + 37) = succ (b + 42)`
#. ยง20: `apply succ_inj at h`
#. ยง21: `h`
#. ยง22: `a + 37 = b + 42`
#. ยง23: `apply succ_inj (a + 37) (b + 42) at h`
#. ยง24: `succ_inj`
#. ยง25: `a * b = 7`
#. ยง26: `apply succ_inj`
#. ยง27: `succ (a * b) = succ 7`
#: Game.Levels.Implication.L03apply
msgid "## Summary\n"
"\n"
"If ยง0 is a proof that ยง1, and ยง2 is a proof of ยง3,\n"
"then ยง4 will change ยง5 to a proof of ยง6. The idea is that if\n"
"you know ยง7 is true, then you can deduce from ยง8 that ยง9 is true.\n"
"\n"
"If the *goal* is ยง10, then ยง11 will \\\\\"argue backwards\\\\\" and change the\n"
"goal to ยง12. The idea here is that if you want to prove ยง13, then by ยง14\n"
"it suffices to prove ยง15, so you can reduce the goal to proving ยง16.\n"
"\n"
"### Example:\n"
"\n"
"ยง17 is a proof that ยง18.\n"
"\n"
"So if you have a hypothesis ยง19\n"
"then ยง20 will change ยง21 to ยง22.\n"
"You could write ยง23\n"
"but Lean is smart enough to figure out the inputs to ยง24.\n"
"\n"
"### Example\n"
"\n"
"If the goal is ยง25, then ยง26 will turn the\n"
"goal into ยง27."
msgstr ""

#. ยง0: `cases ยซ{h2}ยป with e he`
#: Game.Levels.LessOrEqual.L08le_total
msgid "Now ยง0."
msgstr ""

#. ยง0: `add_mul`
#: Game.Levels.Multiplication.L08add_mul
msgid "ยง0 is just as fiddly to prove by induction; but there's a trick\n"
"which avoids it. Can you spot it?"
msgstr ""

#. ยง0: `repeat rw [โ succ_eq_add_one] at h`
#. ยง1: `h`
#. ยง2: `succ x = succ y`
#: Game.Levels.Implication.L07intro2
msgid "Now ยง0 is the quickest way to\n"
"change ยง1 to ยง2."
msgstr ""

#. ยง0: ```
#. use 1
#. exact succ_eq_add_one x
#. ```
#. ยง1: `succ_eq_add_one x`
#. ยง2: `succ x = x + 1`
#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "Here's a two-liner:\n"
"ยง0\n"
"\n"
"This works because ยง1 is a proof of ยง2."
msgstr ""

#. ยง0: `intro h`
#. ยง1: `X โ Y`
#. ยง2: `X = Y โ False`
#: Game.Levels.Algorithm.L06is_zero
msgid "Start with ยง0 (remembering that ยง1 is just notation\n"
"for ยง2)."
msgstr ""

#. ยง0: `n`
#. ยง1: `induction n with d hd`
#: Game.Levels.Addition.L01zero_add
msgid "You can start a proof by induction on ยง0 by typing:\n"
"ยง1."
msgstr ""

#. ยง0: `Pow a b`
#. ยง1: `a ^ b`
#. ยง2: `pow_zero a : a ^ 0 = 1`
#. ยง3: `pow_succ a b : a ^ succ b = a ^ b * a`
#. ยง4: `0 ^ 0 = 1`
#: Game.Levels.Power.L01zero_pow_zero
msgid "ยง0, with notation ยง1, is the usual\n"
"  exponentiation of natural numbers. Internally it is\n"
"  defined via two axioms:\n"
"\n"
"  * ยง2\n"
"\n"
"  * ยง3\n"
"\n"
"Note in particular that ยง4."
msgstr ""

#. ยง0: `โค`
#. ยง1: `a`
#. ยง2: `b`
#. ยง3: `a โค b`
#. ยง4: `b โค a`
#. ยง5: `or`
#. ยง6: `โจ`
#. ยง7: `\\or`
#. ยง8: `left`
#. ยง9: `right`
#. ยง10: `h`
#. ยง11: `cases h with h1 h2`
#: Game.Levels.LessOrEqual.L07or_symm
msgid "Totality of ยง0 is the boss level of this world, and it's coming up next. It says that\n"
"if ยง1 and ยง2 are naturals then either ยง3 or ยง4.\n"
"But we haven't talked about ยง5 at all. Here's a run-through.\n"
"\n"
"1) The notation for \"or\" is ยง6. You won't need to type it, but you can\n"
"type it with ยง7.\n"
"\n"
"2) If you have an \"or\" statement in the *goal*, then two tactics make\n"
"progress: ยง8 and ยง9. But don't choose a direction unless your\n"
"hypotheses guarantee that it's the correct one.\n"
"\n"
"3) If you have an \"or\" statement as a *hypothesis* ยง10, then\n"
"ยง11 will create two goals, one where you went left,\n"
"and the other where you went right."
msgstr ""

#. ยง0: `one_eq_succ_zero`
#. ยง1: `1 = succ 0`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "ยง0 is a proof of ยง1.\""
msgstr ""

#: Game.Levels.Addition.L01zero_add
msgid "zero_add"
msgstr ""

#. ยง0: `induction b with d hd generalizing c`
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "The way to start this proof is ยง0."
msgstr ""

#. ยง0: `0 ^ 0 = 1`
#. ยง1: `n`
#. ยง2: `0 ^ n = 0`
#: Game.Levels.Power.L02zero_pow_succ
msgid "We've just seen that ยง0, but if ยง1\n"
"is a successor, then ยง2. We prove that here."
msgstr ""

#. ยง0: `rw [zero_add] at ยซ{h}ยป`
#. ยง1: `zero_add`
#. ยง2: `ยซ{x}ยป`
#. ยง3: `0 + ยซ{x}ยป`
#. ยง4: `0 + ยซ{y}ยป`
#: Game.Levels.Implication.L02exact2
msgid "Do that again!\n"
"\n"
"ยง0 tries to fill in\n"
"the arguments to ยง1 (finding ยง2) then it replaces all occurences of\n"
"ยง3 it finds. Therefor, it did not rewrite ยง4, yet."
msgstr ""

#. ยง0: `zero_mul x`
#. ยง1: `0 * x = 0`
#. ยง2: `zero_mul`
#. ยง3: `simp`
#: Game.Levels.Multiplication.L02zero_mul
msgid "ยง0 is the proof that ยง1.\n"
"\n"
"Note: ยง2 is a ยง3 lemma."
msgstr ""

#. ยง0: $\\leq$
#. ยง1: $x \\leq y$
#. ยง2: $y \\leq x$
#. ยง3: $x = y$
#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "This level asks you to prove *antisymmetry* of ยง0.\n"
"In other words, if ยง1 and ยง2 then ยง3.\n"
"It's the trickiest one so far. Good luck!"
msgstr ""

#. ยง0: `contrapose!`
#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "If you have completed Algorithm World then you can use the ยง0 tactic\n"
"here. If not then I'll talk you through a manual approach."
msgstr ""

#. ยง0: `zero_ne_succ n`
#. ยง1: `0 โ succ n`
#. ยง2: `a โ b`
#. ยง3: `a = b โ False`
#. ยง4: `zero_ne_succ n`
#. ยง5: `0 = succ n โ False`
#. ยง6: `False`
#. ยง7: `apply zero_ne_succ at h`
#. ยง8: `h`
#. ยง9: `0 = succ n`
#: Game.Levels.Implication.L09zero_ne_succ
msgid "ยง0 is the proof that ยง1.\n"
"\n"
"In Lean, ยง2 is *defined to mean* ยง3. Hence\n"
"ยง4 is really a proof of ยง5.\n"
"Here ยง6 is a generic false statement. This means that\n"
"you can ยง7 if ยง8 is a proof of ยง9."
msgstr ""

#: Game.Levels.Multiplication.L01mul_one
msgid "mul_one"
msgstr ""

#. ยง0: `add_left_cancel a b n`
#. ยง1: $n+a=n+b\\implies a=b$
#. ยง2: `n`
#. ยง3: `add_right_cancel`
#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "ยง0 is the theorem that ยง1.\n"
"You can prove it by induction on ยง2 or you can deduce it from ยง3."
msgstr ""

#. ยง0: `rw [ยซ{h}ยป] at ยซ{h2}ยป`
#. ยง1: `apply le_one at ยซ{h2}ยป`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now ยง0 so you can ยง1."
msgstr ""

#. ยง0: $x \\leq 2$
#. ยง1: $x = 0$
#. ยง2: $1$
#. ยง3: $2$
#: Game.Levels.LessOrEqual.L11le_two
msgid "If ยง0 then ยง1 or ยง2 or ยง3."
msgstr ""

#. ยง0: `two_eq_succ_one`
#. ยง1: `2 = succ 1`
#: Game.Levels.Tutorial.L03two_eq_ss0
#: Game.Levels.Tutorial.L03two_eq_ss0
#: Game.Levels.Tutorial.L03two_eq_ss0
#: Game.Levels.Addition.L03add_comm
#: Game.Levels.Implication.L09zero_ne_succ
#: Game.Levels.Algorithm.L05pred
#: Game.Levels.Algorithm.L06is_zero
#: Game.Levels.Algorithm.L06is_zero
#: Game.Levels.Algorithm.L06is_zero
#: Game.Levels.LessOrEqual.L05le_zero
msgid "ยง0 is a proof of ยง1."
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $c$
#. ยง3: $n$
#. ยง4: $$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$
#: Game.Levels.Power.L10FLT
msgid "For all naturals ยง0 ยง1 ยง2 and ยง3, we have\n"
"ยง4"
msgstr ""

#. ยง0: `le_antisymm x y`
#. ยง1: `x โค y`
#. ยง2: `y โค x`
#. ยง3: `x = y`
#: Game.Levels.LessOrEqual.L06le_antisymm
#: Game.Levels.AdvMultiplication.L07mul_ne_zero
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "ยง0 is a proof that if ยง1 and ยง2 then ยง3."
msgstr ""

#. ยง0: ```
#. repeat rw [add_comm n]
#. exact add_right_cancel a b n
#. ```
#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "How about this for a proof:\n"
"ยง0"
msgstr ""

#. ยง0: `rw [h]`
#. ยง1: `rfl`
#. ยง2: `exact h`
#: Game.Levels.Implication.L07intro2
msgid "Now ยง0 then ยง1 works, but ยง2 is quicker."
msgstr ""

#. ยง0: `le_refl x`
#. ยง1: `x โค x`
#. ยง2: $\\le$
#: Game.Levels.LessOrEqual.L01le_refl
msgid "ยง0 is a proof of ยง1.\n"
"\n"
"The reason for the name is that this lemma is \"reflexivity of ยง2\""
msgstr ""

#: Game.Levels.Addition.L03add_comm
msgid "add_comm (level boss)"
msgstr ""

#. ยง0: `mul_comm x y : x * y = y * x`
#. ยง1: `mul_zero`
#. ยง2: `zero_mul`
#: Game.Levels.Multiplication.L02zero_mul
msgid "Our first challenge is ยง0,\n"
"and we want to prove it by induction. The zero\n"
"case will need ยง1 (which we have)\n"
"and ยง2 (which we don't), so let's\n"
"start with this."
msgstr ""

#. ยง0: `simp_add`
#. ยง1: `a + (b + c) + (d + e) = e + (d + (c + b)) + a`
#: Game.Levels.Algorithm.L04add_algo3
msgid "# Overview\n"
"\n"
"Our home-made tactic ยง0 will solve arbitrary goals of\n"
"the form ยง1."
msgstr ""

#. ยง0: `20 + 20 = 40`
#: Game.Levels.Algorithm.L04add_algo3
msgid "Let's now move on to a more efficient approach to questions\n"
"involving numerals, such as ยง0."
msgstr ""

#: Game.Levels.Multiplication.L09mul_assoc
msgid "We now have enough to prove that multiplication is associative,\n"
"the boss level of multiplication world. Good luck!"
msgstr ""

#: Game.Levels.Power.L08pow_pow
msgid "pow_pow"
msgstr ""

#: Game.Levels.Implication.L04succ_inj
msgid "Now finish in one line."
msgstr ""

#. ยง0: `le_two x`
#. ยง1: `x โค 2`
#. ยง2: `x = 0`
#. ยง3: `x = 1`
#. ยง4: `x = 2`
#: Game.Levels.LessOrEqual.L11le_two
msgid "ยง0 is a proof that if ยง1 then ยง2 or ยง3 or ยง4."
msgstr ""

#. ยง0: `Mul a b`
#. ยง1: `a * b`
#. ยง2: `mul_zero a : a * 0 = 0`
#. ยง3: `mul_succ a b : a * succ b = a * b + a`
#. ยง4: `zero_mul`
#: Game.Levels.Multiplication.L01mul_one
msgid "ยง0, with notation ยง1, is the usual\n"
"  product of natural numbers. Internally it is\n"
"  via two axioms:\n"
"\n"
"  * ยง2\n"
"\n"
"  * ยง3\n"
"\n"
"Other theorems about naturals, such as ยง4,\n"
"are proved by induction from these two basic theorems."
msgstr ""

#. ยง0: `add_zero a`
#. ยง1: `a + 0 = a`
#. ยง2: `add_zero`
#. ยง3: `add_zero 37`
#. ยง4: `37 + 0 = 37`
#. ยง5: `rw`
#. ยง6: `rw [add_zero]`
#. ยง7: `add_zero`
#. ยง8: $\\forall n โ โ, n + 0 = n$
#. ยง9: `n + 0 = n`
#: Game.Levels.Tutorial.L05add_zero
msgid "ยง0 is a proof that ยง1.\n"
"\n"
"## Summary\n"
"\n"
"ยง2 is really a function, which\n"
"eats a number, and returns a proof of a theorem\n"
"about that number. For example ยง3 is\n"
"a proof that ยง4.\n"
"\n"
"The ยง5 tactic will accept ยง6\n"
"and will try to figure out which number you omitted\n"
"to input.\n"
"\n"
"## Details\n"
"\n"
"A mathematician sometimes thinks of ยง7\n"
"as \\\\\"one thing\\\\\", namely a proof of ยง8.\n"
"This is just another way of saying that it's a function which\n"
"can eat any number n and will return a proof that ยง9."
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $$(a+b)^2=a^2+b^2+2ab.$$
#: Game.Levels.Power.L09add_sq
msgid "For all numbers ยง0 and ยง1, we have\n"
"ยง2"
msgstr ""

#. ยง0: `rfl`
#. ยง1: `rfl`
#. ยง2: `rfl`
#. ยง3: `rw`
#: Game.Levels.Tutorial.L01rfl
msgid "Congratulations! You completed your first verified proof!\n"
"\n"
"Remember that ยง0 is a *tactic*. If you ever want information about the ยง1 tactic,\n"
"you can click on ยง2 in the list of tactics on the right.\n"
"\n"
"Now click on \"Next\" to learn about the ยง3 tactic."
msgstr ""

#. ยง0: $0+x=(0+y)+2$
#. ยง1: $x=y+2$
#: Game.Levels.Implication.L02exact2
msgid "Assuming ยง0, we have ยง1."
msgstr ""

#. ยง0: `add_right_cancel a b n`
#. ยง1: $a+n=b+n\\implies a=b$
#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "In this world I will mostly leave you on your own.\n"
"\n"
"ยง0 is the theorem that ยง1."
msgstr ""

#: Game.Levels.Power.L06pow_add
msgid "Let's now begin our approach to the final boss,\n"
"by proving some more subtle facts about powers."
msgstr ""

#. ยง0: `succ_le_succ x y`
#. ยง1: `succ x โค succ y`
#. ยง2: `x โค y`
#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "ยง0 is a proof that if ยง1 then ยง2."
msgstr ""

#: Game.Levels.Implication.L08ne
msgid "โ"
msgstr ""

#. ยง0: `c = 0`
#. ยง1: `c = succ e`
#. ยง2: `cases c with e`
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "Split into cases ยง0 and ยง1 with ยง2."
msgstr ""

#. ยง0: `intro h`
#. ยง1: `h`
#: Game.Levels.Implication.L06intro
msgid "Start with ยง0 to assume the hypothesis and call its proof ยง1."
msgstr ""

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "mul_right_eq_self"
msgstr ""

#. ยง0: `add_comm`
#. ยง1: `succ_add`
#. ยง2: `succ_add a b`
#. ยง3: `(succ a) + b = succ (a + b)`
#. ยง4: `a`
#. ยง5: `b`
#. ยง6: `x + y = y + x`
#. ยง7: `b`
#. ยง8: `b = 0`
#. ยง9: `b`
#: Game.Levels.Addition.L02succ_add
msgid "Oh no! On the way to ยง0, a wild ยง1 appears. ยง2\n"
"is the proof that ยง3 for ยง4 and ยง5 numbers.\n"
"This result is what's standing in the way of ยง6. Again\n"
"we have the problem that we are adding ยง7 to things, so we need\n"
"to use induction to split into the cases where ยง8 and ยง9 is a successor."
msgstr ""

#. ยง0: `simp`
#. ยง1: `simp`
#. ยง2: `add_comm`
#: Game.Levels.Algorithm.L03add_algo2
msgid "# Overview\n"
"\n"
"Lean's simplifier, ยง0, will rewrite every lemma\n"
"tagged with ยง1 and every lemma fed to it by the user, as much as it can.\n"
"Furthermore, it will attempt to order variables into an internal order if fed\n"
"lemmas such as ยง2, so that it does not go into an infinite loop."
msgstr ""

#. ยง0: `cases ha with n hn`
#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Now take apart the existence statement with ยง0."
msgstr ""

#. ยง0: $2+2=4$
#: Game.Levels.Tutorial.L08twoaddtwo
#: Game.Levels.Implication.L06intro
#: Game.Levels.Implication.L07intro2
#: Game.Levels.Implication.L09zero_ne_succ
#: Game.Levels.Implication.L10one_ne_zero
#: Game.Levels.Implication.L11two_add_two_ne_five
#: Game.Levels.Algorithm.L02add_algo1
#: Game.Levels.Algorithm.L06is_zero
#: Game.Levels.Algorithm.L08decide
#: Game.Levels.AdvAddition.L01add_right_cancel
#: Game.Levels.AdvAddition.L02add_left_cancel
#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "ยง0."
msgstr ""

#. ยง0: $x,y,z>0$
#. ยง1: $m \\geq 3$
#. ยง2: $x^m+y^m\\not =z^m$
#. ยง3: $m \\geq 3$
#. ยง4: `n + 3`
#. ยง5: `m`
#. ยง6: `x > 0`
#. ยง7: `a + 1`
#: Game.Levels.Power.L10FLT
msgid "We now have enough to state a mathematically accurate, but slightly\n"
"clunky, version of Fermat's Last Theorem.\n"
"\n"
"Fermat's Last Theorem states that if ยง0 and ยง1 then ยง2.\n"
"If you didn't do inequality world yet then we can't talk about ยง3,\n"
"so we have to resort to the hack of using ยง4 for ยง5,\n"
"which guarantees it's big enough. Similarly instead of ยง6 we\n"
"use ยง7.\n"
"\n"
"This level looks superficially like other levels we have seen,\n"
"but the shortest solution known to humans would translate into\n"
"many millions of lines of Lean code. The author of this game,\n"
"Kevin Buzzard, is working on translating the proof by Wiles\n"
"and Taylor into Lean, although this task will take many years.\n"
"\n"
"## CONGRATULATIONS!\n"
"\n"
"You've finished the main quest of the natural number game!\n"
"If you would like to learn more about how to use Lean to\n"
"prove theorems in mathematics, then take a look\n"
"at [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\n"
"an interactive textbook which you can read in your browser,\n"
"and which explains how to work with many more mathematical concepts in Lean."
msgstr ""

#: Game.Levels.Algorithm.L09decide2
msgid "decide again"
msgstr ""

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "x โค succ x"
msgstr ""

#: Game.Levels.Tutorial.L02rw
msgid "Can you take it from here? Click on \"Show more help!\" if you need a hint."
msgstr ""

#. ยง0: `contrapose! h`
#. ยง1: `succ m = succ n`
#. ยง2: `m = n`
#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "Start with ยง0, to change the goal into its\n"
"contrapositive, namely a hypothesis of ยง1 and a goal of ยง2."
msgstr ""

#: Game.Levels.Multiplication.L07mul_add
msgid "mul_add"
msgstr ""

#. ยง0: `a`
#. ยง1: `b`
#: Game.Levels.Addition.L02succ_add
msgid "You might want to think about whether induction\n"
"on ยง0 or ยง1 is the best idea."
msgstr ""

#. ยง0: `le_trans x y z`
#. ยง1: `x โค y`
#. ยง2: `y โค z`
#. ยง3: `x โค z`
#. ยง4: `x โค y โ (y โค z โ x โค z)`
#. ยง5: $x \\le y$
#. ยง6: $y \\le z$
#. ยง7: $x \\le z$
#. ยง8: `a + b + c`
#. ยง9: `(a + b) + c`
#. ยง10: `+`
#. ยง11: `โ`
#. ยง12: `x โค y โ y โค z โ x โค z`
#. ยง13: `โค`
#. ยง14: $P \\implies Q \\implies R$
#. ยง15: $P \\implies Q$
#. ยง16: $Q \\implies R$
#: Game.Levels.LessOrEqual.L04le_trans
msgid "ยง0 is a proof that if ยง1 and ยง2 then ยง3.\n"
"More precisely, it is a proof that ยง4. In words,\n"
"If ยง5 then (pause) if ยง6 then ยง7.\n"
"\n"
"## A note on associativity\n"
"\n"
"In Lean, ยง8 means ยง9, because ยง10 is left associative. However\n"
"ยง11 is right associative. This means that ยง12 in Lean means\n"
"exactly that ยง13 is transitive. This is different to how mathematicians use\n"
"ยง14; for them, this usually means that ยง15\n"
"and ยง16."
msgstr ""

#: Game.Levels.Algorithm.L02add_algo1
msgid "making life easier"
msgstr ""

#. ยง0: `add_succ`
#: Game.Levels.Addition.L01zero_add
msgid "Use ยง0."
msgstr ""

#. ยง0: `or`
#. ยง1: `right`
#: Game.Levels.LessOrEqual.L07or_symm
msgid "Now we can prove the ยง0 statement by proving the statement on the right,\n"
"so use the ยง1 tactic."
msgstr ""

#. ยง0: `h : a โ b`
#. ยง1: `c โ d`
#. ยง2: `contrapose! h`
#. ยง3: `h : c = d`
#. ยง4: `a = b`
#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "# Summary\n"
"\n"
"If you have a hypothesis\n"
"\n"
"ยง0\n"
"\n"
"and goal\n"
"\n"
"ยง1\n"
"\n"
"then ยง2 replaces the set-up with its so-called \\\\\"contrapositive\\\\\":\n"
"a hypothesis\n"
"\n"
"ยง3\n"
"\n"
"and goal\n"
"\n"
"ยง4."
msgstr ""

#. ยง0: `succ_add a b`
#. ยง1: `succ a + b = succ (a + b)`
#: Game.Levels.Addition.L02succ_add
#: Game.Levels.Multiplication.L08add_mul
#: Game.Levels.Power.L04one_pow
#: Game.Levels.Implication.L10one_ne_zero
#: Game.Levels.Algorithm.L01add_left_comm
#: Game.Levels.LessOrEqual.L02zero_le
#: Game.Levels.LessOrEqual.L03le_succ_self
#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "ยง0 is a proof that ยง1."
msgstr ""

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "eq_succ_of_ne_zero"
msgstr ""

#. ยง0: ```
#. induction c with d hd
#. rw [add_zero, mul_zero, add_zero]
#. rfl
#. rw [add_succ, mul_succ, hd, mul_succ, add_assoc]
#. rfl
#. ```
#. ยง1: `a`
#. ยง2: `b`
#: Game.Levels.Multiplication.L07mul_add
msgid "Here's my solution:\n"
"ยง0\n"
"\n"
"Inducting on ยง1 or ยง2 also works, but might take longer."
msgstr ""

#. ยง0: `apply succ_inj`
#. ยง1: `succ_inj`
#: Game.Levels.Implication.L05succ_inj2
msgid "Start with ยง0 to apply ยง1 to the *goal*."
msgstr ""

#: Game.Levels.Multiplication.L02zero_mul
msgid "zero_mul"
msgstr ""

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Can you take it from here?"
msgstr ""

#: Game.Levels.Power.L07mul_pow
msgid "mul_pow"
msgstr ""

#. ยง0: `โค`
#. ยง1: `โ`
#: Game.Levels.LessOrEqual.L04le_trans
msgid "A passing mathematician remarks that with reflexivity and transitivity out of the way,\n"
"you have proved that ยง0 is a *preorder* on ยง1."
msgstr ""

#. ยง0: ```
#. cases hxy with a ha
#. cases hyx with b hb
#. rw [ha]
#. rw [ha, add_assoc] at hb
#. symm at hb
#. apply add_right_eq_self at hb
#. apply add_right_eq_zero at hb
#. rw [hb, add_zero]
#. rfl
#. ```
#. ยง1: `โค`
#. ยง2: `โ`
#. ยง3: `โค`
#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "Here's my proof:\n"
"ยง0\n"
"\n"
"A passing mathematician remarks that with antisymmetry as well,\n"
"you have proved that ยง1 is a *partial order* on ยง2.\n"
"\n"
"The boss level of this world is to prove\n"
"that ยง3 is a total order. Let's learn two more easy tactics\n"
"first."
msgstr ""

#: Game.Levels.Multiplication.L05one_mul
msgid "one_mul"
msgstr ""

#: Game.Levels.Algorithm.L05pred
msgid "pred"
msgstr ""

#. ยง0: `exact`
#: Game.Levels.Implication.L01exact
#: Game.Levels.LessOrEqual.L01le_refl
msgid "The ยง0 tactic"
msgstr ""

#. ยง0: `succ n`
#. ยง1: `n + 1`
#: Game.Levels.Tutorial.L04rw_backwards
msgid "Why did we not just define ยง0 to be ยง1? Because we have not\n"
"even *defined* addition yet! We'll do that in the next level."
msgstr ""

#. ยง0: $x$
#. ยง1: $y$
#. ยง2: $y = x + 7$
#. ยง3: $2y = 2(x + 7)$
#: Game.Levels.Tutorial.L02rw
msgid "If ยง0 and ยง1 are natural numbers, and ยง2, then ยง3."
msgstr ""

#: Game.Levels.Power.L09add_sq
msgid "[final boss music]"
msgstr ""

#. ยง0: `succ_eq_add_one n`
#. ยง1: `succ n = n + 1`
#: Game.Levels.Tutorial.L07add_succ
#: Game.Levels.Multiplication.L01mul_one
#: Game.Levels.Multiplication.L01mul_one
#: Game.Levels.Multiplication.L01mul_one
#: Game.Levels.Multiplication.L06two_mul
#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "ยง0 is the proof that ยง1."
msgstr ""

#: Game.Levels.Addition.L05add_right_comm
msgid "add_right_comm"
msgstr ""

#. ยง0: `add_zero`
#: Game.Levels.Addition.L01zero_add
msgid "try rewriting ยง0."
msgstr ""

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "one_le_of_ne_zero"
msgstr ""

#. ยง0: `add_right_cancel a b n`
#. ยง1: $a+n=b+n \\implies a=b.$
#: Game.Levels.AdvAddition.L01add_right_cancel
#: Game.Levels.AdvAddition.L02add_left_cancel
#: Game.Levels.AdvAddition.L03add_left_eq_self
#: Game.Levels.AdvAddition.L03add_left_eq_self
#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "ยง0 is the theorem that ยง1"
msgstr ""

#: Game.Levels.Power.L04one_pow
msgid "one_pow"
msgstr ""

#. ยง0: $a, b, c$
#. ยง1: $a+(b+c)=b+(a+c)$
#: Game.Levels.Algorithm.L01add_left_comm
msgid "If ยง0 are numbers, then ยง1."
msgstr ""

#. ยง0: `a โค b`
#. ยง1: `โ c, b = a + c`
#. ยง2: `a โค b`
#. ยง3: `c`
#. ยง4: `b = a + c`
#. ยง5: `use`
#: Game.Levels.LessOrEqual.L01le_refl
msgid "ยง0 is *notation* for ยง1. This \"backwards E\"\n"
"means \"there exists\". So ยง2 means that there exists\n"
"a number ยง3 such that ยง4. This definition works\n"
"because there are no negative numbers in this game.\n"
"\n"
"To *prove* an \"exists\" statement, use the ยง5 tactic.\n"
"Let's see an example."
msgstr ""

#: Game.Levels.LessOrEqual.L02zero_le
msgid "0 โค x"
msgstr ""

#. ยง0: `or`
#: Game.Levels.LessOrEqual.L07or_symm
msgid "Dealing with ยง0"
msgstr ""

#: Game.Levels.Multiplication.L08add_mul
msgid "add_mul"
msgstr ""

#. ยง0: `apply eq_succ_of_ne_zero at ha`
#. ยง1: `... at hb`
#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "Start with ยง0 and ยง1"
msgstr ""

#. ยง0: `pow_succ a b : a ^ (succ b) = a ^ b * a`
#: Game.Levels.Power.L02zero_pow_succ
msgid "ยง0 is one of the\n"
"two axioms defining exponentiation in this game."
msgstr ""

#. ยง0: `mul_zero`
#. ยง1: `mul_succ`
#. ยง2: `1`
#: Game.Levels.Multiplication.L01mul_one
msgid "See the new \"*\" tab in your lemmas, containing ยง0 and ยง1.\n"
"Right now these are the only facts we know about multiplication.\n"
"Let's prove nine more.\n"
"\n"
"Let's start with a warm-up: no induction needed for this one,\n"
"because we know ยง2 is a successor."
msgstr ""

#: Game.Levels.Implication.L09zero_ne_succ
#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "Nice!"
msgstr ""

#. ยง0: $m$
#. ยง1: $ m \\times 1 = m$
#: Game.Levels.Multiplication.L01mul_one
#: Game.Levels.Multiplication.L05one_mul
#: Game.Levels.Multiplication.L06two_mul
msgid "For any natural number ยง0, we have ยง1."
msgstr ""

#. ยง0: `rw [h]`
#. ยง1: `y`
#. ยง2: `x + 7`
#: Game.Levels.Tutorial.L02rw
msgid "First execute ยง0 to replace the ยง1 with ยง2."
msgstr ""

#. ยง0: $2+2=4$
#. ยง1: $2+2\\neq 5$
#. ยง2: $x + y = y + x$
#. ยง3: $x+1=4 \\implies x=3.$
#: Game.Levels.Implication
msgid "We've proved that ยง0; in Implication World we'll learn\n"
"how to prove ยง1.\n"
"\n"
"In Addition World we proved *equalities* like ยง2.\n"
"In this second tutorial world we'll learn some new tactics,\n"
"enabling us to prove *implications*\n"
"like ยง3\n"
"\n"
"We'll also learn two new fundamental facts about\n"
"natural numbers, which Peano introduced as axioms.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""

#: Game.Levels.LessOrEqual.L11le_two
msgid "le_two"
msgstr ""

#: Game.Levels.Power.L05pow_two
msgid "pow_two"
msgstr ""

#. ยง0: ```
#. have h2 := mul_ne_zero a b
#. tauto
#. ```
#. ยง1: `mul_ne_zero a b`
#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "Here's the short proof:\n"
"ยง0\n"
"This works because, given ยง1,\n"
"the argument is reduced to pure logic."
msgstr ""

#. ยง0: `rw [โ pred_succ a]`
#: Game.Levels.Algorithm.L05pred
msgid "Start with ยง0 and take it from there."
msgstr ""

#. ยง0: `0`
#. ยง1: `pred`
#. ยง2: ```
#. pred 0 := 37
#. pred (succ n) := n
#. ```
#. ยง3: `pred_succ`
#. ยง4: `pred (succ n) = n`
#. ยง5: `succ_inj`
#: Game.Levels.Algorithm.L05pred
msgid "We now start work on an algorithm to do addition more efficiently. Recall that\n"
"we defined addition by recursion, saying what it did on ยง0 and successors.\n"
"It is an axiom of Lean that recursion is a valid\n"
"way to define functions from types such as the naturals.\n"
"\n"
"Let's define a new function ยง1 from the naturals to the naturals, which\n"
"attempts to subtract 1 from the input. The definition is this:\n"
"\n"
"ยง2\n"
"\n"
"We cannot subtract one from 0, so we just return a junk value. As well as this\n"
"definition, we also create a new lemma ยง3, which says that ยง4.\n"
"Let's use this lemma to prove ยง5, the theorem which\n"
"Peano assumed as an axiom and which we have already used extensively without justification."
msgstr ""

#: Game.Levels.Algorithm.L06is_zero
msgid "is_zero"
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $c$
#. ยง3: $(ab)c = a(bc)$
#: Game.Levels.Multiplication.L09mul_assoc
msgid "Multiplication is associative.\n"
"In other words, for all natural numbers ยง0, ยง1 and ยง2, we have\n"
"ยง3."
msgstr ""

#. ยง0: `simp`
#. ยง1: `rw`
#. ยง2: `simp`
#: Game.Levels.Algorithm.L03add_algo2
msgid "Lean's simplifier, ยง0, is \"ยง1 on steroids\". It will rewrite every lemma\n"
"tagged with ยง2 and every lemma fed to it by the user, as much as it can.\n"
"\n"
"This level is not a level which you want to solve by hand.\n"
"Get the simplifier to solve it for you."
msgstr ""

#. ยง0: `h : X = Y`
#. ยง1: `X`
#. ยง2: `nth_rewrite 3 [h]`
#. ยง3: `X`
#. ยง4: `Y`
#. ยง5: `2 + 2 = 4`
#. ยง6: `nth_rewrite 2 [two_eq_succ_one]`
#. ยง7: `2 + succ 1 = 4`
#. ยง8: `rw [two_eq_succ_one]`
#. ยง9: `succ 1 + succ 1 = 4`
#: Game.Levels.Tutorial.L02rw
msgid "## Summary\n"
"\n"
"If ยง0 and there are several ยง1s in the goal, then\n"
"ยง2 will just change the third ยง3 to a ยง4.\n"
"\n"
"## Example\n"
"\n"
"If the goal is ยง5 then ยง6\n"
"will change the goal to ยง7. In contrast, ยง8\n"
"will change the goal to ยง9."
msgstr ""

#. ยง0: $P\\implies Q$
#. ยง1: $Q$
#. ยง2: $P$
#. ยง3: `rw [succ_eq_add_one]`
#: Game.Levels.Implication.L05succ_inj2
msgid "Applying a proof of ยง0 to the *goal* changes ยง1 to ยง2.\n"
"Now try ยง3 to make the goal more like the hypothesis."
msgstr ""

#. ยง0: $a$
#. ยง1: $b$
#. ยง2: $(\\operatorname{succ}\\ a) \\times b = a\\times b + b$
#: Game.Levels.Multiplication.L03succ_mul
msgid "For all natural numbers ยง0 and ยง1, we have\n"
"ยง2."
msgstr ""

#. ยง0: $a+b=0 \\implies a=0$
#: Game.Levels.AdvAddition.L05add_right_eq_zero
#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "A proof that ยง0."
msgstr ""

#. ยง0: `repeat rw [add_assoc]`
#: Game.Levels.Algorithm.L02add_algo1
msgid "Start with ยง0 to push all the brackets to the right."
msgstr ""

#. ยง0: `cases a with d`
#. ยง1: `a = 0`
#. ยง2: `a = succ d`
#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "Start with ยง0 to do a case split on ยง1 and ยง2."
msgstr ""

#. ยง0: `mul_eq_zero`
#. ยง1: `tauto`
#. ยง2: `a = 0`
#. ยง3: `a โ 0`
#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "Use ยง0 and remember that ยง1 will solve a goal\n"
"if there are hypotheses ยง2 and ยง3."
msgstr ""

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "The previous lemma can be used to prove this one."
msgstr ""

#. ยง0: `is_zero`
#. ยง1: ```
#. is_zero 0 := True
#. is_zero (succ n) := False
#. ```
#. ยง2: `is_zero_zero`
#. ยง3: `is_zero_succ n`
#. ยง4: `is_zero 0 = True`
#. ยง5: `is_zero (succ n) = False`
#. ยง6: `succ_ne_zero`
#. ยง7: `zero_ne_succ`
#. ยง8: `zero_ne_succ`
#. ยง9: `True`
#. ยง10: `trivial`
#: Game.Levels.Algorithm.L06is_zero
msgid "We define a function ยง0 thus:\n"
"\n"
"ยง1\n"
"\n"
"We also create two lemmas, ยง2 and ยง3, saying that ยง4\n"
"and ยง5. Let's use these lemmas to prove ยง6, Peano's\n"
"Last Axiom. Actually, we have been using ยง7 before, but it's handy to have\n"
"this opposite version too, which can be proved in the same way. Note: you can\n"
"cheat here by using ยง8 but the point of this world is to show\n"
"you how to *prove* results like that.\n"
"\n"
"If you can turn your goal into ยง9, then the ยง10 tactic will solve it."
msgstr ""

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "mul_eq_zero"
msgstr ""

#. ยง0: `rw [two_eq_succ_one]`
#. ยง1: `2`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Start with ยง0 to begin to break ยง1 down into its definition."
msgstr ""

#: Game.Levels.Implication.L10one_ne_zero
msgid "1 โ 0"
msgstr ""

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "mul_le_mul_right"
msgstr ""

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "add_right_eq_self"
msgstr ""

#. ยง0: `2 + 2 โ 5`
#. ยง1: `โ`
#. ยง2: `a โ b`
#. ยง3: `a = b โ False`
#. ยง4: `False`
#. ยง5: `โ`
#. ยง6: `True โ False`
#. ยง7: `False โ False`
#. ยง8: `X โ False`
#. ยง9: `X`
#. ยง10: `a โ b`
#. ยง11: `False`
#. ยง12: `False`
#: Game.Levels.Implication.L08ne
msgid "We still can't prove ยง0 because we have not talked about the\n"
"definition of ยง1. In Lean, ยง2 is *notation* for ยง3.\n"
"Here ยง4 is a generic false proposition, and ยง5 is Lean's notation\n"
"for \"implies\". In logic we learn\n"
"that ยง6 is false, but ยง7 is true. Hence\n"
"ยง8 is the logical opposite of ยง9.\n"
"\n"
"Even though ยง10 does not look like an implication,\n"
"you should treat it as an implication. The next two levels will show you how.\n"
"\n"
"ยง11 is a goal which you cannot deduce from a consistent set of assumptions!\n"
"So if your goal is ยง12 then you had better hope that your hypotheses\n"
"are contradictory, which they are in this level."
msgstr ""

#: Game.Levels.LessOrEqual.L04le_trans
msgid "x โค y and y โค z implies x โค z"
msgstr ""

#. ยง0: `exact`
#: Game.Levels.Implication.L02exact2
msgid "ยง0 practice."
msgstr ""

#. ยง0: `zero_ne_succ n`
#. ยง1: `0 = succ n โ False`
#. ยง2: `succ n = 0`
#. ยง3: `symm`
#. ยง4: `x = y`
#. ยง5: `y = x`
#. ยง6: `x โ y`
#. ยง7: `y โ x`
#. ยง8: `symm at h`
#. ยง9: `h`
#. ยง10: $0 \\neq 1$
#. ยง11: `zero_ne_one`
#. ยง12: $1 \\neq 0$
#: Game.Levels.Implication.L10one_ne_zero
msgid "We know ยง0 is a proof of ยง1 -- but what\n"
"if we have a hypothesis ยง2? It's the wrong way around!\n"
"\n"
"The ยง3 tactic changes a goal ยง4 to ยง5, and a goal ยง6\n"
"to ยง7. And ยง8\n"
"does the same for a hypothesis ยง9. We've proved ยง10 and called\n"
"the proof ยง11; now try proving ยง12."
msgstr ""

#: Game.Levels.Addition.L02succ_add
msgid "Well done! You now have enough tools to tackle the main boss of this level."
msgstr ""

#. ยง0: `use`
#. ยง1: `use`
#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "If you ยง0 the wrong number, you get stuck with a goal you can't prove.\n"
"What number will you ยง1 here?"
msgstr ""

#: Game.Levels.Multiplication.L04mul_comm
msgid "Multiplication is commutative."
msgstr ""

#. ยง0: `mul_succ`
#. ยง1: `succ_mul`
#: Game.Levels.Multiplication.L03succ_mul
msgid "Similarly we have ยง0\n"
"but we're going to need ยง1 (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions).\n"
"\n"
"The last level from addition world might help you in this level.\n"
"If you can't remember what it is, you can go back to the\n"
"home screen by clicking the house icon and then taking a look.\n"
"You won't lose any progress."
msgstr ""

#. ยง0: `intro h`
#: Game.Levels.Implication.L09zero_ne_succ
#: Game.Levels.LessOrEqual.L04le_trans
#: Game.Levels.LessOrEqual.L08le_total
#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "Start with ยง0."
msgstr ""

#: Game.Levels.Multiplication.L03succ_mul
msgid "succ_mul"
msgstr ""

#. ยง0: `add_left_comm`
#. ยง1: `rw [add_comm b c]`
#. ยง2: `a + b + c`
#. ยง3: `(a + b) + c`
#: Game.Levels.Algorithm.L01add_left_comm
msgid "Having to rearrange variables manually using commutativity and\n"
"associativity is very tedious. We start by reminding you of this. ยง0\n"
"is a key component in the first algorithm which we'll explain, but we need\n"
"to prove it manually.\n"
"\n"
"Remember that you can do precision commutativity rewriting\n"
"with things like ยง1. And remember that\n"
"ยง2 means ยง3."
msgstr ""

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Numbers"
msgstr ""

#. ยง0: `rfl`
#: Game.Levels.Tutorial.L07add_succ
msgid "And finally ยง0."
msgstr ""

#. ยง0: `37 * x`
#. ยง1: $x=0$
#. ยง2: $x$
#. ยง3: `37 * 0`
#. ยง4: `0`
#. ยง5: `37 * d`
#. ยง6: `37 * succ d`
#. ยง7: $(d+1)$
#. ยง8: $37$
#. ยง9: `37 * d + 37`
#. ยง10: `mul_zero a : a * 0 = 0`
#. ยง11: `mul_succ a d : a * succ d = a * d + a`
#. ยง12: `a * b = b * a`
#. ยง13: `a * (b + c) = a * b + a * c`
#: Game.Levels.Multiplication
msgid "How should we define ยง0? Just like addition, we need to give definitions\n"
"when ยง1 and when ยง2 is a successor.\n"
"\n"
"The zero case is easy: we define ยง3 to be ยง4. Now say we know\n"
"ยง5. What should ยง6 be? Well, that's ยง7 ยง8s,\n"
"so it should be ยง9.\n"
"\n"
"Here are the definitions in Lean.\n"
"\n"
"  * ยง10\n"
"  * ยง11\n"
"\n"
"In this world, we must not only prove facts about multiplication like ยง12,\n"
"we must also prove facts about how multiplication interacts with addition, like ยง13.\n"
"Let's get started."
msgstr ""

#. ยง0: $2y=2(x+7)$
#. ยง1: `h`
#. ยง2: $y = x + 7$
#. ยง3: `h`
#. ยง4: `h`
#. ยง5: `x`
#. ยง6: `rfl`
#. ยง7: $y$
#. ยง8: `h`
#. ยง9: `rw`
#: Game.Levels.Tutorial.L02rw
msgid "In this level the *goal* is ยง0 but to help us we\n"
"have an *assumption* ยง1 saying that ยง2. Check that you can see ยง3 in\n"
"your list of assumptions. Lean thinks of ยง4 as being a secret proof of the\n"
"assumption, rather like ยง5 is a secret number.\n"
"\n"
"Before we can use ยง6, we have to \"substitute in for ยง7\".\n"
"We do this in Lean by *rewriting* the proof ยง8,\n"
"using the ยง9 tactic."
msgstr ""

#. ยง0: ```
#. symm
#. exact zero_ne_one
#. ```
#. ยง1: `exact`
#: Game.Levels.Implication.L10one_ne_zero
msgid "What do you think of this two-liner:\n"
"ยง0\n"
"\n"
"ยง1 doesn't just take hypotheses, it will eat any proof which exists\n"
"in the system."
msgstr ""

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "succ x โค succ y โ x โค y"
msgstr ""

#: Game
msgid "The classical introduction game for Lean."
msgstr ""

#. ยง0: `rw [ยซ{h}ยป]`
#. ยง1: `rfl`
#. ยง2: `exact ยซ{h}ยป`
#: Game.Levels.Implication.L02exact2
msgid "Now you could finish with ยง0 then ยง1, but ยง2\n"
"does it in one line."
msgstr ""

#: Game.Levels.Power.L10FLT
msgid "Fermat's Last Theorem"
msgstr ""

#. ยง0: `apply`
#. ยง1: `P โ Q`
#. ยง2: `P โ Q`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `intro`
#: Game.Levels.Implication.L06intro
msgid "We have seen how to ยง0 theorems and assumptions\n"
"of the form ยง1. But what if our *goal* is of the form ยง2?\n"
"To prove this goal, we need to know how to say \"let's assume ยง3 and deduce ยง4\"\n"
"in Lean. We do this with the ยง5 tactic."
msgstr ""

#. ยง0: $x$
#. ยง1: $x \\le x$
#: Game.Levels.LessOrEqual.L01le_refl
#: Game.Levels.LessOrEqual.L02zero_le
#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "If ยง0 is a number, then ยง1."
msgstr ""

#. ยง0: ```
#. cases x with y
#. left
#. rfl
#. rw [one_eq_succ_zero] at hx โข
#. apply succ_le_succ at hx
#. apply le_zero at hx
#. rw [hx]
#. right
#. rfl
#. ```
#: Game.Levels.LessOrEqual.L10le_one
msgid "Here's my proof:\n"
"ยง0\n"
"\n"
"If you solved this level then you should be fine with the next level!"
msgstr ""

#. ยง0: `2 = 2`
#: Game.Levels.Tutorial.L04rw_backwards
msgid "Can you now change the goal into ยง0?"
msgstr ""

#: Game.Levels.Power.L09add_sq
msgid "add_sq"
msgstr ""

#. ยง0: `a`
#. ยง1: `cases a with b`
#. ยง2: `a = 0`
#. ยง3: `a = succ b`
#: Game.Levels.LessOrEqual.L08le_total
msgid "This is I think the toughest level yet. Tips: if ยง0 is a number\n"
"then ยง1 will split into cases ยง2 and ยง3.\n"
"And don't go left or right until your hypotheses guarantee that\n"
"you can prove the resulting goal!\n"
"\n"
"I've left hidden hints; if you need them, retry from the beginning\n"
"and click on \"Show more help!\""
msgstr ""

#. ยง0: `โ`
#: Game.Levels.LessOrEqual.L08le_total
msgid "Very well done.\n"
"\n"
"A passing mathematician remarks that with you've just proved that ยง0 is totally\n"
"ordered.\n"
"\n"
"The final few levels in this world are much easier."
msgstr ""

#. ยง0: `y`
#. ยง1: `add_left_eq_self`
#. ยง2: `add_right_cancel`
#. ยง3: `</>`
#. ยง4: `>_`
#. ยง5: ```
#. nth_rewrite 2 [โ zero_add y]
#. exact add_right_cancel x 0 y
#. ```
#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "Did you use induction on ยง0?\n"
"Here's a two-line proof of ยง1 which uses ยง2.\n"
"If you want to inspect it, you can go into editor mode by clicking ยง3 in the top right\n"
"and then just cut and paste the proof and move your cursor around it\n"
"to see the hypotheses and goal at any given point\n"
"(although you'll lose your own proof this way). Click ยง4 to get\n"
"back to command line mode.\n"
"ยง5"
msgstr ""

#. ยง0: `a = 0`
#. ยง1: `x + a = x`
#: Game.Levels.Addition.L05add_right_comm
msgid "You've now seen all the tactics you need to beat the final boss of the game.\n"
"You can begin the journey towards this boss by entering Multiplication World.\n"
"\n"
"Or you can go off the beaten track and learn some new tactics in Implication\n"
"World. These tactics let you prove more facts about addition, such as\n"
"how to deduce ยง0 from ยง1.\n"
"\n"
"Click \"Leave World\" and make your choice."
msgstr ""

#: Game.Levels.LessOrEqual.L05le_zero
msgid "It's \"intuitively obvious\" that there are no numbers less than zero,\n"
"but to prove it you will need a result which you showed in advanced\n"
"addition world."
msgstr ""

#. ยง0: `exact h`
#: Game.Levels.Implication.L04succ_inj
msgid "And now we've deduced what we wanted to prove: the goal is one of our assumptions.\n"
"Finish the level with ยง0."
msgstr ""

#. ยง0: `rw [add_zero]`
#: Game.Levels.Tutorial.L07add_succ
msgid "And now ยง0"
msgstr ""

#. ยง0: `pow_add a m n`
#. ยง1: $a^{m+n}=a^ma^n.$
#: Game.Levels.Power.L06pow_add
#: Game.Levels.Power.L07mul_pow
#: Game.Levels.Power.L08pow_pow
msgid "ยง0 is a proof that ยง1"
msgstr ""

#: Game.Levels.LessOrEqual
msgid "โค World"
msgstr ""

#. ยง0: `ยซ{hd}ยป : 0 + ยซ{d}ยป = ยซ{d}ยป`
#. ยง1: `0 + succ ยซ{d}ยป = succ ยซ{d}ยป`
#: Game.Levels.Addition.L01zero_add
msgid "Now for to the second goal. Here you have the induction hypothesis\n"
"ยง0, and you need to prove that ยง1."
msgstr ""

#. ยง0: ```
#. rw [mul_comm, mul_one]
#. rfl
#. ```
#: Game.Levels.Multiplication.L05one_mul
#: Game.Levels.Multiplication.L06two_mul
msgid "Here's my solution:\n"
"ยง0"
msgstr ""

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "An algorithm for equality"
msgstr ""

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "le_mul_right"
msgstr ""

#: Game.Levels.Power
msgid "Power World"
msgstr ""

#. ยง0: ```
#. nth_rewrite 2 [โ mul_one a] at h
#. exact mul_left_cancel a b 1 ha h
#. ```
#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "A two-line proof is\n"
"\n"
"ยง0\n"
"\n"
"We now have all the tools necessary to set up the basic theory of divisibility of naturals."
msgstr ""

#: Game.Levels.Multiplication.L06two_mul
msgid "two_mul"
msgstr ""

#: Game.Levels.Algorithm.L04add_algo3
msgid "the simplest approach"
msgstr ""

#. ยง0: $P\\implies Q$
#. ยง1: $P$
#. ยง2: $Q$
#. ยง3: `exact`
#. ยง4: `exact h`
#: Game.Levels.Implication.L01exact
msgid "In this world we'll learn how to prove theorems of the form ยง0.\n"
"In other words, how to prove theorems of the form \"if ยง1 is true, then ยง2 is true.\"\n"
"To do that we need to learn some more tactics.\n"
"\n"
"The ยง3 tactic can be used to close a goal which is exactly one of\n"
"the hypotheses. It takes the name of the hypothesis as argument: ยง4."
msgstr ""

#: Game.Levels.Algorithm.L02add_algo1
msgid "So that's the algorithm: now let's use automation to perform it\n"
"automatically."
msgstr ""

#. ยง0: `x + y = 0 โ x = 0`
#. ยง1: `x + y = x โ y = 0`
#. ยง2: `x * y = 1 โ x = 1`
#. ยง3: `x * y = x โ y = 1`
#. ยง4: `x โ 0`
#: Game.Levels.AdvMultiplication
msgid "Advanced *Addition* World proved various implications\n"
"involving addition, such as ยง0 and ยง1.\n"
"These lemmas were used to prove basic facts about โค in โค World.\n"
"\n"
"In Advanced Multiplication World we prove analogous\n"
"facts about multiplication, such as ยง2, and\n"
"ยง3 (assuming ยง4 in the latter result). This will prepare\n"
"us for Divisibility World.\n"
"\n"
"Multiplication World is more complex than Addition World. In the same\n"
"way, Advanced Multiplication world is more complex than Advanced Addition\n"
"World. One reason for this is that certain intermediate results are only\n"
"true under the additional hypothesis that one of the variables is non-zero.\n"
"This causes some unexpected extra twists."
msgstr ""

#. ยง0: `simp only [add_left_comm, add_comm]`
#: Game.Levels.Algorithm.L03add_algo2
msgid "Solve this level in one line with ยง0"
msgstr ""

#. ยง0: `succ_inj`
#. ยง1: $0$
#: Game.Levels.Algorithm.L05pred
msgid "Nice! You've proved ยง0!\n"
"Let's now prove Peano's other axiom, that successors can't be ยง1."
msgstr ""

#. ยง0: $a$
#. ยง1: $\\operatorname{succ}(a) = a+1$
#: Game.Levels.Tutorial.L07add_succ
#: Game.Levels.Addition.L01zero_add
#: Game.Levels.Multiplication.L02zero_mul
msgid "For all natural numbers ยง0, we have ยง1."
msgstr ""

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "Well done!"
msgstr ""

#: Game.Levels.Tutorial.L06add_zero2
msgid "Precision rewriting"
msgstr ""

#. ยง0: $a(b+c)=ab+ac$
#. ยง1: $(b+c)a=ba+ca$
#. ยง2: `mul_add a b c`
#. ยง3: `a * (b + c) = a * b + a * c`
#: Game.Levels.Multiplication.L07mul_add
msgid "Our next goal is \"left and right distributivity\",\n"
"meaning ยง0 and ยง1. Rather than\n"
"these slightly pompous names, the name of the proofs\n"
"in Lean are descriptive. Let's start with\n"
"ยง2, the proof of ยง3.\n"
"Note that the left hand side contains a multiplication\n"
"and then an addition."
msgstr ""

#. ยง0: `xyzzy`
#. ยง1: `sorry`
#. ยง2: `xyzzy`
#: Game.Levels.Power.L10FLT
msgid "ยง0 is an ancient magic spell, believed to be the origin of the\n"
"modern word ยง1. The game won't complain - or notice - if you\n"
"prove anything with ยง2."
msgstr ""

#. ยง0: `0 ^ 0 = 0`
#. ยง1: `0 ^ 0 = 1`
#: Game.Levels.Power.L01zero_pow_zero
msgid "Mathematicians sometimes argue that ยง0 is also\n"
"a good convention. But it is not a good convention in this\n"
"game; all the later levels come out beautifully with the\n"
"convention that ยง1."
msgstr ""

#. ยง0: ```
#. cases h with d hd
#. use d * t
#. rw [hd, add_mul]
#. rfl
#. ```
#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "My proof:\n"
"ยง0"
msgstr ""

#: Game.Levels.Multiplication.L06two_mul
msgid "This level is more important than you think; it plays\n"
"a useful role when battling a big boss later on."
msgstr ""

#. ยง0: `cases h2 with h0 h1`
#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now ยง0 and deal with the two\n"
"cases separately."
msgstr ""

#: Game.Levels.Power.L08pow_pow
msgid "The music dies down. Is that it?\n"
"\n"
"Course it isn't, you can\n"
"clearly see that there are two levels left.\n"
"\n"
"A passing mathematician says that mathematicians don't have a name\n"
"for the structure you just constructed. You feel cheated.\n"
"\n"
"Suddenly the music starts up again. This really is the final boss."
msgstr ""

#. ยง0: `le_one x`
#. ยง1: `x โค 1`
#. ยง2: `x = 0`
#. ยง3: `x = 1`
#: Game.Levels.LessOrEqual.L10le_one
#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "ยง0 is a proof that if ยง1 then ยง2 or ยง3."
msgstr ""

#: Game.Levels.Tutorial
msgid "Tutorial World"
msgstr ""

#. ยง0: `rw [one_eq_succ_zero]`
#: Game.Levels.Tutorial.L07add_succ
msgid "ยง0 will do this."
msgstr ""

#. ยง0: `x โค 0`
#. ยง1: `x = 0`
#. ยง2: `โค 1`
#. ยง3: `โค 2`
#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "We've proved that ยง0 implies ยง1. The last two levels\n"
"in this world will prove which numbers are ยง2 and ยง3.\n"
"This lemma will be helpful for them."
msgstr ""

#. ยง0: `cases ยซ{e}ยป with a`
#: Game.Levels.LessOrEqual.L08le_total
msgid "You still don't know which way to go, so do ยง0."
msgstr ""

#: Game.Levels.AdvMultiplication
msgid "Advanced Multiplication World"
msgstr ""

#. ยง0: $2$
#. ยง1: $0$
#: Game.Levels.Tutorial.L03two_eq_ss0
#: Game.Levels.Tutorial.L04rw_backwards
msgid "ยง0 is the number after the number after ยง1."
msgstr ""

#. ยง0: `2 + 2 = 4`
#: Game.Levels.Tutorial.L02rw
msgid "You now know enough tactics to prove ยง0! Let's begin the journey."
msgstr ""

#. ยง0: `succ_mul a b`
#. ยง1: `succ a * b = a * b + b`
#. ยง2: `mul_succ`
#. ยง3: `mul_comm`
#. ยง4: `mul_comm`
#. ยง5: `mul_succ`
#: Game.Levels.Multiplication.L03succ_mul
msgid "ยง0 is the proof that ยง1.\n"
"\n"
"It could be deduced from ยง2 and ยง3, however this argument\n"
"would be circular because the proof of ยง4 uses ยง5."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `a * b`
#. ยง1: `rw [mul_comm]`
#. ยง2: `rw`
#: Game.Levels.Power.L07mul_pow
msgid "The music gets ever more dramatic, as we explore\n"
"the interplay between exponentiation and multiplication.\n"
"\n"
"If you're having trouble exchanging the right ยง0\n"
"because ยง1 swaps the wrong multiplication,\n"
"then read the documentation of ยง2 for tips on how to fix this."
msgstr ""

#. ยง0: `le_total x y`
#. ยง1: `x โค y`
#. ยง2: `y โค x`
#: Game.Levels.LessOrEqual.L08le_total
msgid "ยง0 is a proof that ยง1 or ยง2."
msgstr ""

#. ยง0: `ha : 0 โ 0`
#. ยง1: `tauto`
#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "In the \"base case\" we have a hypothesis ยง0, and you can deduce anything\n"
"from a false statement. The ยง1 tactic will close this goal."
msgstr ""

#: Game.Levels.Tutorial.L07add_succ
msgid "add_succ"
msgstr ""

#: Game.Levels.Power.L03pow_one
msgid "pow_one"
msgstr ""

#. ยง0: `rw [two_eq_succ_one, one_eq_succ_zero]`
#. ยง1: `rfl`
#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Note that you can do ยง0\n"
"and then ยง1 to solve this level in two lines."
msgstr ""

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "add_right_eq_zero"
msgstr ""

#: Game.Levels.Tutorial.L05add_zero
msgid "Adding zero"
msgstr ""

#: Game.Levels.Addition.L03add_comm
msgid "[boss battle music]\n"
"\n"
"Look in your inventory to see the proofs you have available.\n"
"These should be enough."
msgstr ""

#. ยง0: $a, b$
#. ยง1: $c$
#. ยง2: $d$
#. ยง3: $(a + b) + (c + d) = ((a + c) + d) + b.$
#: Game.Levels.Algorithm.L02add_algo1
msgid "If ยง0, ยง1 and ยง2 are numbers, we have\n"
"ยง3"
msgstr ""

#. ยง0: `a โ 0`
#. ยง1: `b โ 0`
#. ยง2: `a * b โ 0`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `succ`
#. ยง6: `a * b`
#. ยง7: `succ`
#. ยง8: `apply zero_ne_succ`
#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "This level proves that if ยง0 and ยง1 then ยง2. One strategy\n"
"is to write both ยง3 and ยง4 as ยง5 of something, deduce that ยง6 is\n"
"also ยง7 of something, and then ยง8."
msgstr ""

#: Game.Levels.Power.L02zero_pow_succ
msgid "zero_pow_succ"
msgstr ""

#: Game.Levels.LessOrEqual.L07or_symm
msgid "Ready for the boss level of this world?"
msgstr ""

#. ยง0: `mul_add a b c`
#. ยง1: `a * (b + c) = a * b + a * c`
#: Game.Levels.Multiplication.L07mul_add
msgid "Multiplication distributes\n"
"over addition on the left.\n"
"\n"
"ยง0 is the proof that ยง1."
msgstr ""

#: Game.Levels.Algorithm
msgid "Algorithm World"
msgstr ""

#. ยง0: `add_succ a b`
#. ยง1: `a + succ b = succ (a + b)`
#: Game.Levels.Tutorial.L07add_succ
msgid "ยง0 is the proof of ยง1."
msgstr ""

#: Game.Levels.Power.L10FLT
msgid "Congratulations! You have proved Fermat's Last Theorem!\n"
"\n"
"Either that, or you used magic..."
msgstr ""

#. ยง0: `mul_comm`
#. ยง1: `mul_comm a b`
#. ยง2: `a * b = b * a`
#: Game.Levels.Multiplication.L04mul_comm
msgid "ยง0 is the proof that multiplication is commutative. More precisely,\n"
"ยง1 is the proof that ยง2."
msgstr ""

#: Game.Levels.Tutorial.L04rw_backwards
msgid "rewriting backwards"
msgstr ""

#. ยง0: `use`
#. ยง1: `x`
#. ยง2: `x = 37`
#. ยง3: `use 37`
#. ยง4: `a โค b`
#. ยง5: `c`
#. ยง6: `b = a + c`
#. ยง7: `a โค b`
#. ยง8: `use`
#. ยง9: `b - a`
#. ยง10: `use b - a`
#. ยง11: `use`
#. ยง12: `use 37`
#. ยง13: `use a`
#. ยง14: `use a * a + 1`
#: Game.Levels.LessOrEqual.L01le_refl
msgid "## Summary\n"
"\n"
"The ยง0 tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some ยง1 exists with some property, and you know\n"
"that ยง2 will work, then ยง3 will make progress.\n"
"\n"
"Because ยง4 is notation for \\\\\"there exists ยง5 such that ยง6\\\\\",\n"
"you can make progress on goals of the form ยง7 by ยง8ing the\n"
"number which is morally ยง9 (i.e. ยง10)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the ยง11 function is accurate:\n"
"\n"
"- ยง12\n"
"- ยง13\n"
"- ยง14"
msgstr ""

#. ยง0: `x + y = y + x`
#. ยง1: `add_comm`
#. ยง2: `add_zero`
#. ยง3: `zero_add`
#. ยง4: `add_comm`
#. ยง5: `x + y = y + x`
#: Game.Levels.Addition.L01zero_add
msgid "This lemma would have been easy if we had known that ยง0. That theorem\n"
"  is called ยง1 and it is *true*, but unfortunately its proof *uses* both\n"
"  ยง2 and ยง3!\n"
"\n"
"  Let's continue on our journey to ยง4, the proof of ยง5."
msgstr ""
