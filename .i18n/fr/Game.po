# Arnaud Bodin <arnaud.bodin@univ-lille.fr>, 2025.
# via Deepseek
msgid ""
msgstr ""
"Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Fri Mar 14 17:06:47 2025\n"
"PO-Revision-Date: \n"
"Last-Translator: Arnaud Bodin <arnaud.bodin@univ-lille.fr>\n"
"Language-Team: none\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.6\n"

#: GameServer.RpcHandlers
msgid "level completed! üéâ"
msgstr "niveau termin√© ! üéâ"

#: GameServer.RpcHandlers
msgid "level completed with warnings‚Ä¶ üé≠"
msgstr "niveau termin√© avec des avertissements‚Ä¶ üé≠"

#: GameServer.RpcHandlers
msgid "intermediate goal solved! üéâ"
msgstr "objectif interm√©diaire r√©solu ! üéâ"

#: Game.Levels.Tutorial.L01rfl
msgid "The rfl tactic"
msgstr "La tactique rfl"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\".\n"
"\n"
"## Game Implementation\n"
"\n"
"*Note that our `rfl` is weaker than the version used in core Lean and `mathlib`,\n"
"for pedagogical purposes; mathematicians do not distinguish between propositional\n"
"and definitional equality because they think about definitions in a different way\n"
"to type theorists (`zero_add` and `add_zero` are both \\\"facts\\\" as far\n"
"as mathematicians are concerned, and who cares what the definition of addition is).*"
msgstr ""
"## R√©sum√©\n"
"\n"
"`rfl` prouve les buts de la forme `X = X`.\n"
"\n"
"Autrement dit, la tactique `rfl` fermera tout but de la\n"
"forme `A = B` si `A` et `B` sont *identiques*.\n"
"\n"
"`rfl` est l'abr√©viation de \"r√©flexivit√© (de l'√©galit√©)\".\n"
"\n"
"## Exemple :\n"
"\n"
"Si le but ressemble √† ceci :\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"alors `rfl` le fermera. Mais s'il ressemble √† `0 + x = x`, alors `rfl` ne fonctionnera pas, car "
"m√™me si\n"
"$0+x$ et $x$ sont toujours √©gaux en tant que *nombres*, ils ne sont pas √©gaux en tant que "
"*termes*.\n"
"Le seul terme identique √† `0 + x` est `0 + x`.\n"
"\n"
"## D√©tails\n"
"\n"
"`rfl` est l'abr√©viation de \"r√©flexivit√© de l'√©galit√©\".\n"
"\n"
"## Impl√©mentation dans le jeu\n"
"\n"
"*Notez que, pour des raisons p√©dagogiques, notre `rfl` est plus faible que la version utilis√©e dans Lean et `mathlib`,\n"
" ; les math√©maticiens ne distinguent pas l'√©galit√© propositionnelle\n"
"et l'√©galit√© d√©finitionnelle car ils pensent aux d√©finitions d'une mani√®re diff√©rente\n"
"des th√©oriciens des types (`zero_add` et `add_zero` sont tous deux des \"faits\"\n"
"pour les math√©maticiens, et qui se soucie de la d√©finition de l'addition ?).*"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical theorem (the \"Goal\").\n"
"The goal will be a statement about *numbers*. Some numbers in this game have known values.\n"
"Those numbers have names like $37$. Other numbers will be secret. They're called things\n"
"like $x$ and $q$. We know $x$ is a number, we just don't know which one.\n"
"\n"
"In this first level we're going to prove the theorem that $37x + q = 37x + q$.\n"
"You can see `x q : ‚Ñï` in the *Objects* below, which means that `x` and `q`\n"
"are numbers.\n"
"\n"
"We solve goals in Lean using *Tactics*, and the first tactic we're\n"
"going to learn is called `rfl`, which proves all theorems of the form $X = X$.\n"
"\n"
"Prove that $37x+q=37x+q$ by executing the `rfl` tactic."
msgstr ""
"# Lisez ceci d'abord\n"
"\n"
"Chaque niveau de ce jeu consiste √† prouver un th√©or√®me math√©matique (le \"But\").\n"
"Le but sera un √©nonc√© sur des *nombres*. Certains nombres dans ce jeu ont des valeurs connues.\n"
"Ces nombres ont des noms comme $37$. D'autres nombres seront secrets. Ils sont appel√©s\n"
"$x$ et $q$. Nous savons que $x$ est un nombre, nous ne savons juste pas lequel.\n"
"\n"
"Dans ce premier niveau, nous allons prouver le th√©or√®me que $37x + q = 37x + q$.\n"
"Vous pouvez voir `x q : ‚Ñï` dans les *Objets* ci-dessous, ce qui signifie que `x` et `q`\n"
"sont des nombres.\n"
"\n"
"Nous r√©solvons les buts dans Lean en utilisant des *Tactiques*, et la premi√®re tactique que nous\n"
"allons apprendre s'appelle `rfl`, qui prouve tous les th√©or√®mes de la forme $X = X$.\n"
"\n"
"Prouvez que $37x+q=37x+q$ en ex√©cutant la tactique `rfl`."

#: Game.Levels.Tutorial.L01rfl
msgid "If $x$ and $q$ are arbitrary natural numbers, then $37x+q=37x+q.$"
msgstr "Si $x$ et $q$ sont des nombres naturels arbitraires, alors $37x+q=37x+q.$"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"In order to use the tactic `rfl` you can enter it in the text box\n"
"under the goal and hit \"Execute\"."
msgstr ""
"Pour utiliser la tactique `rfl`, vous pouvez l'entrer dans la zone de texte\n"
"sous le but et appuyer sur \"Ex√©cuter\"."

#: Game.Levels.Tutorial.L01rfl
msgid ""
"Congratulations! You completed your first verified proof!\n"
"\n"
"Remember that `rfl` is a *tactic*. If you ever want information about the `rfl` tactic,\n"
"you can click on `rfl` in the list of tactics on the right.\n"
"\n"
"Now click on \"Next\" to learn about the `rw` tactic."
msgstr ""
"F√©licitations ! Vous avez compl√©t√© votre premi√®re preuve v√©rifi√©e !\n"
"\n"
"Rappelez-vous que `rfl` est une *tactique*. Si vous voulez des informations sur la tactique "
"`rfl`,\n"
"vous pouvez cliquer sur `rfl` dans la liste des tactiques √† droite.\n"
"\n"
"Cliquez maintenant sur \"Suivant\" pour apprendre la tactique `rw`."

#: Game.Levels.Tutorial.L02rw
msgid "the rw tactic"
msgstr "la tactique rw"

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [‚Üê h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `‚ä¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targetted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si `h` est une preuve d'une √©galit√© `X = Y`, alors `rw [h]` changera\n"
"tous les `X` du but en `Y`. `rw` est l‚Äôabr√©viation de \"rewrite\". C'est la mani√®re de "
"\"substituer\".\n"
"\n"
"## Variantes\n"
"\n"
"* `rw [‚Üê h]` (change les `Y` en `X` ; obtenez la fl√®che gauche en tapant `\\left ` ou `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (une s√©quence de r√©√©critures)\n"
"\n"
"* `rw [h] at h2` (change les `X` en `Y` dans l'hypoth√®se `h2`)\n"
"\n"
"* `rw [h] at h1 h2 ‚ä¢` (change les `X` en `Y` dans deux hypoth√®ses et le but ;\n"
"obtenez le symbole `‚ä¢` avec `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` continuera √† changer `? + 0` en `?`\n"
"jusqu'√† ce qu'il n'y ait plus de correspondances pour `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` ne changera que le deuxi√®me `X` du but en `Y`.\n"
"\n"
"### Exemple :\n"
"\n"
"Si vous avez l'hypoth√®se `h : x = y + y` et que votre but est\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"alors\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"changera le but en `succ x = succ (y + y)`, puis\n"
"\n"
"`rw [h]`\n"
"\n"
"changera le but en `succ (y + y) = succ (y + y)`, ce qui\n"
"peut √™tre r√©solu avec `rfl`.\n"
"\n"
"### Exemple :\n"
"\n"
"Vous pouvez √©galement utiliser `rw` pour changer une hypoth√®se.\n"
"Par exemple, si vous avez deux hypoth√®ses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"alors `rw [h1] at h2` transformera `h2` en `h2 : 2 * y = y + 3`.\n"
"\n"
"## Erreurs courantes\n"
"\n"
"* Vous avez besoin des crochets. `rw h` n'est jamais valide.\n"
"\n"
"* Si `h` n'est pas une *preuve* d'une *√©galit√©* (un √©nonc√© de la forme `A = B`),\n"
"par exemple si `h` est une fonction ou une implication,\n"
"alors `rw` n'est pas la tactique que vous voulez utiliser. Par exemple,\n"
"`rw [P = Q]` n'est jamais correct : `P = Q` est l'*√©nonc√©* du th√©or√®me,\n"
"pas la preuve. Si `h : P = Q` est la preuve, alors `rw [h]` fonctionnera.\n"
"\n"
"## D√©tails\n"
"\n"
"La tactique `rw` est un moyen de faire une \"substitution\". Il y a\n"
"deux situations distinctes o√π vous pouvez utiliser cette tactique.\n"
"\n"
"1) Utilisation basique : si `h : A = B` est une hypoth√®se ou\n"
"la preuve d'un th√©or√®me, et si le but contient un ou plusieurs `A`, alors `rw [h]`\n"
"les changera tous en `B`. La tactique √©chouera\n"
"s'il n'y a pas de `A` dans le but.\n"
"\n"
"2) Utilisation avanc√©e : Les hypoth√®ses provenant de preuves de th√©or√®mes\n"
"ont souvent des parties manquantes. Par exemple, `add_zero`\n"
"est une preuve que `? + 0 = ?` car `add_zero` est en fait une fonction,\n"
"et `?` est l'entr√©e. Dans cette situation, `rw` parcourra le but\n"
"√† la recherche de tout sous-terme de la forme `x + 0`, et d√®s qu'il\n"
"en trouve un, il fixe `?` √† `x` puis change tous les `x + 0` en `x`.\n"
"\n"
"Exercice : r√©fl√©chissez √† pourquoi `rw [add_zero]` change le terme\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` en\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"Si vous ne vous souvenez pas du nom de la preuve d'une √©galit√©, cherchez-la dans\n"
"la liste des lemmes √† droite.\n"
"\n"
"## Utilisation cibl√©e\n"
"\n"
"Si votre but est `b + c + a = b + (a + c)` et que vous voulez r√©√©crire `a + c`\n"
"en `c + a`, alors `rw [add_comm]` ne fonctionnera pas car Lean trouve d'abord\n"
"une autre addition et √©change ces entr√©es √† la place. Utilisez `rw [add_comm a c]` pour\n"
"garantir que Lean r√©√©crit `a + c` en `c + a`. Cela fonctionne car\n"
"`add_comm` est une preuve que `?1 + ?2 = ?2 + ?1`, `add_comm a` est une preuve\n"
"que `a + ? = ? + a`, et `add_comm a c` est une preuve que `a + c = c + a`.\n"
"\n"
"Si `h : X = Y` alors `rw [h]` transformera tous les `X` en `Y`.\n"
"Si vous voulez seulement changer la 37√®me occurrence de `X`\n"
"en `Y`, alors faites `nth_rewrite 37 [h]`."

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""
"## R√©sum√©\n"
"\n"
"`repeat t` applique r√©p√©titivement la tactique `t`\n"
"au but. Vous n'avez pas besoin d'utiliser cette\n"
"tactique, elle acc√©l√®re simplement les choses parfois.\n"
"\n"
"## Exemple\n"
"\n"
"`repeat rw [add_zero]` transformera le but\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"en le but\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## R√©sum√©\n"
"\n"
"Si `h : X = Y` et qu'il y a plusieurs `X` dans le but, alors\n"
"`nth_rewrite 3 [h]` ne changera que le troisi√®me `X` en `Y`.\n"
"\n"
"## Exemple\n"
"\n"
"Si le but est `2 + 2 = 4` alors `nth_rewrite 2 [two_eq_succ_one]`\n"
"changera le but en `2 + succ 1 = 4`. En revanche, `rw [two_eq_succ_one]`\n"
"changera le but en `succ 1 + succ 1 = 4`."

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si `h : X = Y` et qu'il y a plusieurs `X` dans le but, alors\n"
"`nth_rewrite 3 [h]` ne changera que le troisi√®me `X` en `Y`.\n"
"\n"
"## Exemple\n"
"\n"
"Si le but est `2 + 2 = 4` alors `nth_rewrite 2 [two_eq_succ_one]`\n"
"changera le but en `2 + succ 1 = 4`. En revanche, `rw [two_eq_succ_one]`\n"
"changera le but en `succ 1 + succ 1 = 4`."

#: Game.Levels.Tutorial.L02rw
msgid ""
"In this level the *goal* is $2y=2(x+7)$ but to help us we\n"
"have an *assumption* `h` saying that $y = x + 7$. Check that you can see `h` in\n"
"your list of assumptions. Lean thinks of `h` as being a secret proof of the\n"
"assumption, rather like `x` is a secret number.\n"
"\n"
"Before we can use `rfl`, we have to \"substitute in for $y$\".\n"
"We do this in Lean by *rewriting* the proof `h`,\n"
"using the `rw` tactic."
msgstr ""
"Dans ce niveau, le *but* est $2y=2(x+7)$ mais pour nous aider, nous\n"
"avons une *hypoth√®se* `h` disant que $y = x + 7$. V√©rifiez que vous pouvez voir `h` dans\n"
"votre liste d'hypoth√®ses. Lean consid√®re `h` comme une preuve secr√®te de\n"
"l'hypoth√®se, un peu comme `x` est un nombre secret.\n"
"\n"
"Avant de pouvoir utiliser `rfl`, nous devons \"substituer $y$\".\n"
"Nous faisons cela dans Lean en *r√©√©crivant* la preuve `h`,\n"
"en utilisant la tactique `rw`."

#: Game.Levels.Tutorial.L02rw
msgid "If $x$ and $y$ are natural numbers, and $y = x + 7$, then $2y = 2(x + 7)$."
msgstr "Si $x$ et $y$ sont des nombres naturels, et $y = x + 7$, alors $2y = 2(x + 7)$."

#: Game.Levels.Tutorial.L02rw
msgid "First execute `rw [h]` to replace the `y` with `x + 7`."
msgstr "Commencez par ex√©cuter `rw [h]` pour remplacer `y` par `x + 7`."

#: Game.Levels.Tutorial.L02rw
msgid "Can you take it from here? Click on \"Show more help!\" if you need a hint."
msgstr ""
"Pouvez-vous continuer ? Cliquez sur \"Afficher plus d'aide !\" si vous avez besoin d'un indice."

#: Game.Levels.Tutorial.L02rw
msgid "Now `rfl` will work."
msgstr "Maintenant `rfl` fonctionnera."

#: Game.Levels.Tutorial.L02rw
msgid "You now know enough tactics to prove `2 + 2 = 4`! Let's begin the journey."
msgstr ""
"Vous connaissez maintenant assez de tactiques pour prouver `2 + 2 = 4` ! Commen√ßons le voyage."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Numbers"
msgstr "Nombres"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"`‚Ñï` is the natural numbers, just called \\\"numbers\\\" in this game. It's\n"
"defined via two rules:\n"
"\n"
"* `0 : ‚Ñï` (zero is a number)\n"
"* `succ (n : ‚Ñï) : ‚Ñï` (the successor of a number is a number)\n"
"\n"
"## Game Implementation\n"
"\n"
"*The game uses its own copy of the natural numbers, called `MyNat` with notation `‚Ñï`.\n"
"It is distinct from the Lean natural numbers `Nat`, which should hopefully\n"
"never leak into the natural number game.*"
msgstr ""
"`‚Ñï` repr√©sente les nombres naturels, simplement appel√©s \"nombres\" dans ce jeu. Ils sont\n"
"d√©finis par deux r√®gles :\n"
"\n"
"* `0 : ‚Ñï` (z√©ro est un nombre)\n"
"* `succ (n : ‚Ñï) : ‚Ñï` (le successeur d'un nombre est un nombre)\n"
"\n"
"## Impl√©mentation dans le jeu\n"
"\n"
"*Le jeu utilise sa propre copie des nombres naturels, appel√©e `MyNat` avec la notation `‚Ñï`.\n"
"Elle est distincte des nombres naturels de Lean `Nat`, qui ne devraient normalement jamais\n"
"appara√Ætre dans le jeu des nombres naturels.*"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`one_eq_succ_zero` is a proof of `1 = succ 0`.\""
msgstr "`one_eq_succ_zero` est une preuve que `1 = succ 0`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`two_eq_succ_one` is a proof of `2 = succ 1`."
msgstr "`two_eq_succ_one` est une preuve que `2 = succ 1`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`three_eq_succ_two` is a proof of `3 = succ 2`."
msgstr "`three_eq_succ_two` est une preuve que `3 = succ 2`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`four_eq_succ_three` is a proof of `4 = succ 3`."
msgstr "`four_eq_succ_three` est une preuve que `4 = succ 3`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"## The birth of number.\n"
"\n"
"Numbers in Lean are defined by two rules.\n"
"\n"
"* `0` is a number.\n"
"* If `n` is a number, then the *successor* `succ n` of `n` is a number.\n"
"\n"
"The successor of `n` means the number after `n`. Let's learn to\n"
"count, and name a few small numbers.\n"
"\n"
"## Counting to four.\n"
"\n"
"`0` is a number, so `succ 0` is a number. Let's call this new number `1`.\n"
"Similarly let's define `2 = succ 1`, `3 = succ 2` and `4 = succ 3`.\n"
"This gives us plenty of numbers to be getting along with.\n"
"\n"
"The *proof* that `2 = succ 1` is called `two_eq_succ_one`.\n"
"Check out the \"012\" tab in the list of lemmas on the right\n"
"for this and other proofs.\n"
"\n"
"Let's prove that $2$ is the number after the number after zero."
msgstr ""
"## La naissance des nombres.\n"
"\n"
"Les nombres dans Lean sont d√©finis par deux r√®gles.\n"
"\n"
"* `0` est un nombre.\n"
"* Si `n` est un nombre, alors le *successeur* `succ n` de `n` est un nombre.\n"
"\n"
"Le successeur de `n` signifie le nombre apr√®s `n`. Apprenons √†\n"
"compter et nommons quelques petits nombres.\n"
"\n"
"## Compter jusqu'√† quatre.\n"
"\n"
"`0` est un nombre, donc `succ 0` est un nombre. Appelons ce nouveau nombre `1`.\n"
"De m√™me, d√©finissons `2 = succ 1`, `3 = succ 2` et `4 = succ 3`.\n"
"Cela nous donne suffisamment de nombres pour commencer.\n"
"\n"
"La *preuve* que `2 = succ 1` s'appelle `two_eq_succ_one`.\n"
"Consultez l'onglet \"012\" dans la liste des lemmes √† droite\n"
"pour cette preuve et d'autres.\n"
"\n"
"Prouvons que $2$ est le nombre apr√®s le nombre apr√®s z√©ro."

#: Game.Levels.Tutorial.L03two_eq_ss0 Game.Levels.Tutorial.L04rw_backwards
msgid "$2$ is the number after the number after $0$."
msgstr "$2$ est le nombre apr√®s le nombre apr√®s $0$."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Start with `rw [two_eq_succ_one]` to begin to break `2` down into its definition."
msgstr "Commencez par `rw [two_eq_succ_one]` pour commencer √† d√©composer `2` selon sa d√©finition."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Can you take it from here?"
msgstr "Pouvez-vous continuer ?"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Next turn `1` into `succ 0` with `rw [one_eq_succ_zero]`."
msgstr "Ensuite, transformez `1` en `succ 0` avec `rw [one_eq_succ_zero]`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Now finish the job with `rfl`."
msgstr "Terminez maintenant avec `rfl`."

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"Note that you can do `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"and then `rfl` to solve this level in two lines."
msgstr ""
"Notez que vous pouvez faire `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"puis `rfl` pour r√©soudre ce niveau en deux lignes."

#: Game.Levels.Tutorial.L04rw_backwards
msgid "rewriting backwards"
msgstr "r√©√©criture √† l'envers"

#: Game.Levels.Tutorial.L04rw_backwards
msgid ""
"If `h` is a proof of `X = Y` then `rw [h]` will\n"
"turn `X`s into `Y`s. But what if we want to\n"
"turn `Y`s into `X`s? To tell the `rw` tactic\n"
"we want this, we use a left arrow `‚Üê`. Type\n"
"`\\l` and then hit the space bar to get this arrow.\n"
"\n"
"Let's prove that $2$ is the number after the number\n"
"after $0$ again, this time by changing `succ (succ 0)`\n"
"into `2`."
msgstr ""
"Si `h` est une preuve de `X = Y` alors `rw [h]`\n"
"transformera les `X` en `Y`. Mais que faire si nous voulons\n"
"transformer les `Y` en `X` ? Pour indiquer √† la tactique `rw`\n"
"que nous voulons cela, nous utilisons une fl√®che gauche `‚Üê`. Tapez\n"
"`\\l` puis appuyez sur la barre d'espace pour obtenir cette fl√®che.\n"
"\n"
"Prouvons √† nouveau que $2$ est le nombre apr√®s le nombre\n"
"apr√®s $0$, cette fois en changeant `succ (succ 0)`\n"
"en `2`."

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Try `rw [‚Üê one_eq_succ_zero]` to change `succ 0` into `1`."
msgstr "Essayez `rw [‚Üê one_eq_succ_zero]` pour changer `succ 0` en `1`."

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Can you now change the goal into `2 = 2`?"
msgstr "Pouvez-vous maintenant changer le but en `2 = 2` ?"

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Now `rw [‚Üê two_eq_succ_one]` will change `succ 1` into `2`."
msgstr "Maintenant `rw [‚Üê two_eq_succ_one]` changera `succ 1` en `2`."

#: Game.Levels.Tutorial.L04rw_backwards
msgid ""
"Why did we not just define `succ n` to be `n + 1`? Because we have not\n"
"even *defined* addition yet! We'll do that in the next level."
msgstr ""
"Pourquoi n'avons-nous pas simplement d√©fini `succ n` comme `n + 1` ? Parce que nous n'avons pas\n"
"encore *d√©fini* l'addition ! Nous ferons cela au niveau suivant."

#: Game.Levels.Tutorial.L05add_zero
msgid "Adding zero"
msgstr "Ajouter z√©ro"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"`Add a b`, with notation `a + b`, is\n"
"the usual sum of natural numbers. Internally it is defined\n"
"via the following two hypotheses:\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"Other theorems about naturals, such as `zero_add a : 0 + a = a`, are proved\n"
"by induction using these two basic theorems.\""
msgstr ""
"`Add a b`, avec la notation `a + b`, est\n"
"la somme habituelle des nombres naturels. En interne, elle est d√©finie\n"
"par les deux hypoth√®ses suivantes :\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"D'autres th√©or√®mes sur les naturels, comme `zero_add a : 0 + a = a`, sont prouv√©s\n"
"par induction en utilisant ces deux th√©or√®mes de base.\""

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"`add_zero a` is a proof that `a + 0 = a`.\n"
"\n"
"## Summary\n"
"\n"
"`add_zero` is really a function, which\n"
"eats a number, and returns a proof of a theorem\n"
"about that number. For example `add_zero 37` is\n"
"a proof that `37 + 0 = 37`.\n"
"\n"
"The `rw` tactic will accept `rw [add_zero]`\n"
"and will try to figure out which number you omitted\n"
"to input.\n"
"\n"
"## Details\n"
"\n"
"A mathematician sometimes thinks of `add_zero`\n"
"as \\\"one thing\\\", namely a proof of $\\forall n ‚àà ‚Ñï, n + 0 = n$.\n"
"This is just another way of saying that it's a function which\n"
"can eat any number n and will return a proof that `n + 0 = n`."
msgstr ""
"`add_zero a` est une preuve que `a + 0 = a`.\n"
"\n"
"## R√©sum√©\n"
"\n"
"`add_zero` est en fait une fonction qui\n"
"prend un nombre et renvoie une preuve d'un th√©or√®me\n"
"sur ce nombre. Par exemple, `add_zero 37` est\n"
"une preuve que `37 + 0 = 37`.\n"
"\n"
"La tactique `rw` acceptera `rw [add_zero]`\n"
"et essaiera de d√©terminer quel nombre vous avez omis\n"
"de sp√©cifier.\n"
"\n"
"## D√©tails\n"
"\n"
"Un math√©maticien consid√®re parfois `add_zero`\n"
"comme \"une seule chose\", √† savoir une preuve de $\\forall n ‚àà ‚Ñï, n + 0 = n$.\n"
"C'est juste une autre fa√ßon de dire que c'est une fonction qui\n"
"peut prendre n'importe quel nombre n et renvoyer une preuve que `n + 0 = n`."

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`."
msgstr ""
"## R√©sum√©\n"
"\n"
"`repeat t` applique r√©p√©titivement la tactique `t`\n"
"au but. Vous n'avez pas besoin d'utiliser cette\n"
"tactique, elle acc√©l√®re simplement les choses parfois.\n"
"\n"
"## Exemple\n"
"\n"
"`repeat rw [add_zero]` transformera le but\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"en le but\n"
"`a = b`."

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"We'd like to prove `2 + 2 = 4` but right now\n"
"we can't even *state* it\n"
"because we haven't yet defined addition.\n"
"\n"
"## Defining addition.\n"
"\n"
"How are we going to add $37$ to an arbitrary number $x$? Well,\n"
"there are only two ways to make numbers in this game: $0$\n"
"and successors. So to define `37 + x` we will need\n"
"to know what `37 + 0` is and what `37 + succ x` is.\n"
"Let's start with adding `0`.\n"
"\n"
"### Adding 0\n"
"\n"
"To make addition agree with our intuition, we should *define* `37 + 0`\n"
"to be `37`. More generally, we should define `a + 0` to be `a` for\n"
"any number `a`. The name of this proof in Lean is `add_zero a`.\n"
"For example `add_zero 37` is a proof of `37 + 0 = 37`,\n"
"`add_zero x` is a proof of `x + 0 = x`, and `add_zero` is a proof\n"
"of `? + 0 = ?`.\n"
"\n"
"We write `add_zero x : x + 0 = x`, so `proof : statement`."
msgstr ""
"Nous aimerions prouver `2 + 2 = 4` mais actuellement\n"
"nous ne pouvons m√™me pas *l'√©noncer*\n"
"car nous n'avons pas encore d√©fini l'addition.\n"
"\n"
"## D√©finition de l'addition.\n"
"\n"
"Comment allons-nous ajouter $37$ √† un nombre arbitraire $x$ ? Eh bien,\n"
"il n'y a que deux fa√ßons de cr√©er des nombres dans ce jeu : $0$\n"
"et les successeurs. Donc pour d√©finir `37 + x`, nous aurons besoin\n"
"de savoir ce que sont `37 + 0` et `37 + succ x`.\n"
"Commen√ßons par ajouter `0`.\n"
"\n"
"### Ajouter 0\n"
"\n"
"Pour que l'addition corresponde √† notre intuition, nous devons *d√©finir* `37 + 0`\n"
"comme `37`. Plus g√©n√©ralement, nous devons d√©finir `a + 0` comme `a` pour\n"
"tout nombre `a`. Le nom de cette preuve dans Lean est `add_zero a`.\n"
"Par exemple, `add_zero 37` est une preuve de `37 + 0 = 37`,\n"
"`add_zero x` est une preuve de `x + 0 = x`, et `add_zero` est une preuve\n"
"de `? + 0 = ?`.\n"
"\n"
"Nous √©crivons `add_zero x : x + 0 = x`, donc `preuve : √©nonc√©`."

#: Game.Levels.Tutorial.L05add_zero Game.Levels.Tutorial.L06add_zero2
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr "$a+(b+0)+(c+0)=a+b+c.$"

#: Game.Levels.Tutorial.L05add_zero
msgid "`rw [add_zero]` will change `b + 0` into `b`."
msgstr "`rw [add_zero]` changera `b + 0` en `b`."

#: Game.Levels.Tutorial.L05add_zero
msgid "Now `rw [add_zero]` will change `c + 0` into `c`."
msgstr "Maintenant `rw [add_zero]` changera `c + 0` en `c`."

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"Those of you interested in speedrunning the game may want to know\n"
"that `repeat rw [add_zero]` will do both rewrites at once."
msgstr ""
"Ceux d'entre vous int√©ress√©s par le speedrun du jeu voudront peut-√™tre savoir\n"
"que `repeat rw [add_zero]` fera les deux r√©√©critures en une seule fois."

#: Game.Levels.Tutorial.L06add_zero2
msgid "Precision rewriting"
msgstr "R√©√©criture de pr√©cision"

#: Game.Levels.Tutorial.L06add_zero2
msgid ""
"## Precision rewriting\n"
"\n"
"In the last level, there was `b + 0` and `c + 0`,\n"
"and `rw [add_zero]` changed the first one it saw,\n"
"which was `b + 0`. Let's learn how to tell Lean\n"
"to change `c + 0` first by giving `add_zero` an\n"
"explicit input."
msgstr ""
"## R√©√©criture de pr√©cision\n"
"\n"
"Dans le niveau pr√©c√©dent, il y avait `b + 0` et `c + 0`,\n"
"et `rw [add_zero]` a chang√© le premier qu'il a vu,\n"
"qui √©tait `b + 0`. Apprenons √† dire √† Lean\n"
"de changer `c + 0` en premier en donnant √† `add_zero` une\n"
"entr√©e explicite."

#: Game.Levels.Tutorial.L06add_zero2
msgid "Try `rw [add_zero c]`."
msgstr "Essayez `rw [add_zero c]`."

#: Game.Levels.Tutorial.L06add_zero2
msgid ""
"`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\n"
"You can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\n"
"can usually stick to `rw [add_zero]` unless you need real precision."
msgstr ""
"`add_zero c` est une preuve que `c + 0 = c`, donc c'est ce qui a √©t√© r√©√©crit.\n"
"Vous pouvez maintenant changer `b + 0` en `b` avec `rw [add_zero]` ou `rw [add_zero b]`.\n"
"Vous pouvez g√©n√©ralement vous en tenir √† `rw [add_zero]` sauf si vous avez besoin d'une grande "
"pr√©cision."

#: Game.Levels.Tutorial.L06add_zero2
msgid "Let's now learn about Peano's second axiom for addition, `add_succ`."
msgstr "Apprenons maintenant le second axiome de Peano pour l'addition, `add_succ`."

#: Game.Levels.Tutorial.L07add_succ
msgid "add_succ"
msgstr "add_succ"

#: Game.Levels.Tutorial.L07add_succ
msgid "`add_succ a b` is the proof of `a + succ b = succ (a + b)`."
msgstr "`add_succ a b` est la preuve que `a + succ b = succ (a + b)`."

#: Game.Levels.Tutorial.L07add_succ
msgid "`succ_eq_add_one n` is the proof that `succ n = n + 1`."
msgstr "`succ_eq_add_one n` est la preuve que `succ n = n + 1`."

#: Game.Levels.Tutorial.L07add_succ
msgid ""
"Every number in Lean is either $0$ or a successor. We know how to add $0$,\n"
"but we need to figure out how to add successors. Let's say we already know\n"
"that `37 + d = q`. What should the answer to `37 + succ d` be? Well,\n"
"`succ d` is one bigger than `d`, so `37 + succ d` should be `succ q`,\n"
"the number one bigger than `q`. More generally `x + succ d` should\n"
"be `succ (x + d)`. Let's add this as a lemma.\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"If you ever see `... + succ ...` in your goal, `rw [add_succ]` is\n"
"normally a good idea.\n"
"\n"
"Let's now prove that `succ n = n + 1`. Figure out how to get `+ succ` into\n"
"the picture, and then `rw [add_succ]`. Switch between the `+` (addition) and\n"
"`012` (numerals) tabs under \"Theorems\" on the right to\n"
"see which proofs you can rewrite."
msgstr ""
"Chaque nombre dans Lean est soit $0$, soit un successeur. Nous savons comment ajouter $0$,\n"
"mais nous devons comprendre comment ajouter des successeurs. Disons que nous savons d√©j√†\n"
"que `37 + d = q`. Que devrait √™tre la r√©ponse √† `37 + succ d` ? Eh bien,\n"
"`succ d` est un de plus que `d`, donc `37 + succ d` devrait √™tre `succ q`,\n"
"le nombre un de plus que `q`. Plus g√©n√©ralement, `x + succ d` devrait\n"
"√™tre `succ (x + d)`. Ajoutons cela comme lemme.\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"Si vous voyez `... + succ ...` dans votre but, `rw [add_succ]` est\n"
"g√©n√©ralement une bonne id√©e.\n"
"\n"
"Prouvons maintenant que `succ n = n + 1`. Trouvez comment introduire `+ succ`\n"
"dans notre situation, puis `rw [add_succ]`. Alternez entre les onglets `+` (addition) et\n"
"`012` (num√©raux) sous \"Th√©or√®mes\" √† droite pour\n"
"voir quelles preuves vous pouvez r√©√©crire."

#: Game.Levels.Tutorial.L07add_succ
msgid "For all natural numbers $a$, we have $\\operatorname{succ}(a) = a+1$."
msgstr "Pour tout nombre naturel $a$, nous avons $\\operatorname{succ}(a) = a+1$."

#: Game.Levels.Tutorial.L07add_succ
msgid "Start by unravelling the `1`."
msgstr "Commencez par d√©composer le `1`."

#: Game.Levels.Tutorial.L07add_succ
msgid "`rw [one_eq_succ_zero]` will do this."
msgstr "`rw [one_eq_succ_zero]` fera cela."

#: Game.Levels.Tutorial.L07add_succ Game.Levels.Tutorial.L08twoaddtwo
msgid "Now you can `rw [add_succ]`"
msgstr "Maintenant vous pouvez utiliser `rw [add_succ]`"

#: Game.Levels.Tutorial.L07add_succ
msgid "And now `rw [add_zero]`"
msgstr "Et maintenant `rw [add_zero]`"

#: Game.Levels.Tutorial.L07add_succ
msgid "And finally `rfl`."
msgstr "Et enfin `rfl`."

#: Game.Levels.Tutorial.L07add_succ
msgid "[dramatic music]. Now are you ready to face the first boss of the game?"
msgstr "[musique dramatique]. √ätes-vous maintenant pr√™t √† affronter le premier boss du jeu ?"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "2+2=4"
msgstr "2+2=4"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid ""
"Good luck!\n"
"\n"
"  One last hint. If `h : X = Y` then `rw [h]` will change *all* `X`s into `Y`s.\n"
"  If you only want to change one of them, say the 3rd one, then use\n"
"  `nth_rewrite 3 [h]`."
msgstr ""
"Bonne chance !\n"
"\n"
"  Un dernier indice. Si `h : X = Y` alors `rw [h]` changera *tous* les `X` en `Y`.\n"
"  Si vous ne voulez en changer qu'un seul, disons le 3√®me, alors utilisez\n"
"  `nth_rewrite 3 [h]`."

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "$2+2=4$."
msgstr "$2+2=4$."

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "`nth_rewrite 2 [two_eq_succ_one]` is I think quicker than `rw [two_eq_succ_one]`."
msgstr "`nth_rewrite 2 [two_eq_succ_one]` est je pense plus rapide que `rw [two_eq_succ_one]`."

#: Game.Levels.Tutorial.L08twoaddtwo
msgid ""
"Here is an example proof of 2+2=4 showing off various techniques.\n"
"\n"
"```lean\n"
"nth_rewrite 2 [two_eq_succ_one] -- only change the second `2` to `succ 1`.\n"
"rw [add_succ]\n"
"rw [one_eq_succ_zero]\n"
"rw [add_succ, add_zero] -- two rewrites at once\n"
"rw [‚Üê three_eq_succ_two] -- change `succ 2` to `3`\n"
"rw [‚Üê four_eq_succ_three]\n"
"rfl\n"
"```\n"
"\n"
"Optional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\n"
"on the `</>` button in the top right. You can now see your proof\n"
"written as several lines of code. Move your cursor between lines to see\n"
"the goal state at any point. Now cut and paste your code elsewhere if you\n"
"want to save it, and paste the above proof in instead. Move your cursor\n"
"around to investigate. When you've finished, click the `>_` button in the top right to\n"
"move back into \"Typewriter mode\".\n"
"\n"
"You have finished tutorial world!\n"
"Click \"Leave World\" to go back to the\n"
"overworld, and select Addition World, where you will learn\n"
"about the `induction` tactic."
msgstr ""
"Voici un exemple de preuve de 2+2=4 montrant diverses techniques.\n"
"\n"
"```lean\n"
"nth_rewrite 2 [two_eq_succ_one] -- ne change que le deuxi√®me `2` en `succ 1`\n"
"rw [add_succ]\n"
"rw [one_eq_succ_zero]\n"
"rw [add_succ, add_zero] -- deux r√©√©critures en une fois\n"
"rw [‚Üê three_eq_succ_two] -- change `succ 2` en `3`\n"
"rw [‚Üê four_eq_succ_three]\n"
"rfl\n"
"```\n"
"\n"
"Option suppl√©mentaire : vous pouvez ex√©cuter cette preuve vous-m√™me. Passez le jeu en \"Mode "
"√âditeur\" en cliquant\n"
"sur le bouton `</>` en haut √† droite. Vous pouvez maintenant voir votre preuve\n"
"√©crite sous forme de plusieurs lignes de code. D√©placez votre curseur entre les lignes pour voir\n"
"l'√©tat du but √† tout moment. Maintenant, copiez et collez votre code ailleurs si vous\n"
"voulez le sauvegarder, et collez la preuve ci-dessus √† la place. D√©placez votre curseur\n"
"autour pour examiner. Lorsque vous avez termin√©, cliquez sur le bouton `>_` en haut √† droite pour\n"
"revenir en \"Mode Machine √† √©crire\".\n"
"\n"
"Vous avez termin√© le monde tutoriel !\n"
"Cliquez sur \"Quitter le monde\" pour revenir au\n"
"monde principal, et s√©lectionnez Addition World, o√π vous apprendrez\n"
"la tactique `induction`."

#: Game.Levels.Tutorial
msgid "Tutorial World"
msgstr "Monde Tutoriel"

#: Game.Levels.Tutorial
msgid ""
"Welcome to tutorial world! In this world we learn the basics\n"
"of proving theorems. The boss level of this world\n"
"is the theorem `2 + 2 = 4`.\n"
"\n"
"You prove theorems by solving puzzles using tools called *tactics*.\n"
"The aim is to prove the theorem by applying tactics\n"
"in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below\n"
"to begin your quest."
msgstr ""
"Bienvenue dans le monde tutoriel ! Dans ce monde, nous apprenons les bases\n"
"de la preuve de th√©or√®mes. Le niveau boss de ce monde\n"
"est le th√©or√®me `2 + 2 = 4`.\n"
"\n"
"Vous prouvez des th√©or√®mes en r√©solvant des √©nigmes √† l'aide d'outils appel√©s *tactiques*.\n"
"Le but est de prouver le th√©or√®me en appliquant des tactiques\n"
"dans le bon ordre.\n"
"\n"
"Apprenons quelques tactiques de base. Cliquez sur \"Commencer\" ci-dessous\n"
"pour d√©buter votre qu√™te."

#: Game.Levels.Addition.L01zero_add
msgid "zero_add"
msgstr "zero_add"

#: Game.Levels.Addition.L01zero_add
msgid ""
"In this level we're going to prove that $0+n=n$, where $n$ is a secret natural number.\n"
"\n"
"Wait, don't we already know that? No! We know that $n+0=n$, but that's `add_zero`.\n"
"This is `zero_add`, which is different.\n"
"\n"
"The difficulty with proving `0 + n = n` is that we do not have a *formula* for\n"
"`0 + n` in general, we can only use `add_zero` and `add_succ` once\n"
"we know whether `n` is `0` or a successor. The `induction` tactic splits into these two cases.\n"
"\n"
"The base case will require us to prove `0 + 0 = 0`, and the inductive step\n"
"will ask us to show that if `0 + d = d` then `0 + succ d = succ d`. Because\n"
"`0` and successor are the only way to make numbers, this will cover all the cases.\n"
"\n"
"See if you can do your first induction proof in Lean.\n"
"\n"
"(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\n"
"back to \"Typewriter mode\" by clicking the `>_` button in the top right.)"
msgstr ""
"Dans ce niveau, nous allons prouver que $0+n=n$, o√π $n$ est un nombre naturel secret.\n"
"\n"
"Attendez, ne le savons-nous pas d√©j√† ? Non ! Nous savons que $n+0=n$, mais c'est `add_zero`.\n"
"Ceci est `zero_add`, ce qui est diff√©rent.\n"
"\n"
"La difficult√© pour prouver `0 + n = n` est que nous n'avons pas de *formule* pour\n"
"`0 + n` en g√©n√©ral, nous ne pouvons utiliser `add_zero` et `add_succ` que lorsque\n"
"nous savons si `n` est `0` ou un successeur. La tactique `induction`, correspond √† une r√©currence "
"et se divise en ces deux cas.\n"
"\n"
"Le cas de base nous demandera de prouver `0 + 0 = 0`, et l'√©tape inductive\n"
"nous demandera de montrer que si `0 + d = d` alors `0 + succ d = succ d`. Parce que\n"
"`0` et successeur sont les seules fa√ßons de cr√©er des nombres, cela couvrira tous les cas.\n"
"\n"
"Voyons si vous pouvez faire votre premi√®re preuve par r√©currence avec Lean.\n"
"\n"
"(Au fait, si vous √™tes toujours en \"Mode √âditeur\" depuis le dernier monde, vous pouvez revenir\n"
"en \"Mode Machine √† √©crire\" en cliquant sur le bouton `>_` en haut √† droite.)"

#: Game.Levels.Addition.L01zero_add
msgid ""
"`zero_add x` is the proof of `0 + x = x`.\n"
"\n"
"`zero_add` is a `simp` lemma, because replacing `0 + x` by `x`\n"
"is almost always what you want to do if you're simplifying an expression."
msgstr ""
"`zero_add x` est la preuve que `0 + x = x`.\n"
"\n"
"`zero_add` est un lemme `simp`, car remplacer `0 + x` par `x`\n"
"est presque toujours ce que vous voulez faire si vous simplifiez une expression."

#: Game.Levels.Addition.L01zero_add
msgid "For all natural numbers $n$, we have $0 + n = n$."
msgstr "Pour tous les nombres naturels $n$, nous avons $0 + n = n$."

#: Game.Levels.Addition.L01zero_add
msgid ""
"You can start a proof by induction on `n` by typing:\n"
"`induction n with d hd`."
msgstr ""
"Vous pouvez commencer une preuve par induction sur `n` en tapant :\n"
"`induction n with d hd`."

#: Game.Levels.Addition.L01zero_add
msgid ""
"Now you have two goals. Once you proved the first, you will jump to the second one.\n"
"This first goal is the base case $n = 0$.\n"
"\n"
"Recall that you can rewrite the proof of any lemma which is visible\n"
"in your inventory, or of any assumption displayed above the goal,\n"
"as long as it is of the form `X = Y`."
msgstr ""
"Maintenant vous avez deux buts. Une fois que vous avez prouv√© le premier, vous passerez au "
"second.\n"
"Ce premier but est le cas de base $n = 0$.\n"
"\n"
"Rappelez-vous que vous pouvez r√©√©crire la preuve de tout lemme visible\n"
"dans votre inventaire, ou de toute hypoth√®se affich√©e au-dessus du but,\n"
"tant qu'elle est de la forme `X = Y`."

#: Game.Levels.Addition.L01zero_add
msgid "try rewriting `add_zero`."
msgstr "essayez de r√©√©crire avec `add_zero`."

#: Game.Levels.Addition.L01zero_add
msgid ""
"Now for to the second goal. Here you have the induction hypothesis\n"
"`¬´{hd}¬ª : 0 + ¬´{d}¬ª = ¬´{d}¬ª`, and you need to prove that `0 + succ ¬´{d}¬ª = succ ¬´{d}¬ª`."
msgstr ""
"Passons maintenant au second but. Ici vous avez l'hypoth√®se d'induction\n"
"`¬´{hd}¬ª : 0 + ¬´{d}¬ª = ¬´{d}¬ª`, et vous devez prouver que `0 + succ ¬´{d}¬ª = succ ¬´{d}¬ª`."

#: Game.Levels.Addition.L01zero_add
msgid "Use `add_succ`."
msgstr "Utilisez `add_succ`."

#: Game.Levels.Addition.L01zero_add
msgid ""
"At this point you see the term `0 + ¬´{d}¬ª`, so you can use the\n"
"induction hypothesis with `rw [¬´{hd}¬ª]`."
msgstr ""
"√Ä ce stade, vous voyez le terme `0 + ¬´{d}¬ª`, donc vous pouvez utiliser\n"
"l'hypoth√®se d'induction avec `rw [¬´{hd}¬ª]`."

#: Game.Levels.Addition.L01zero_add
msgid ""
"## Summary\n"
"\n"
"If `n : ‚Ñï` is an object, and the goal mentions `n`, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si `n : ‚Ñï` est un objet, et que le but mentionne `n`, alors `induction n with d hd`\n"
"tente de prouver le but par induction sur `n` (c'est-√†-dire par r√©currence sur `n`). avec la variable inductive\n"
"dans le cas successeur √©tant `d`, et l'hypoth√®se inductive √©tant `hd`.\n"
"\n"
"### Exemple :\n"
"Si le but est\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"alors\n"
"\n"
"`induction n with d hd`\n"
"\n"
"le transformera en deux buts. Le premier est `0 + 0 = 0` ;\n"
"le second a une hypoth√®se `hd : 0 + d = d` et un but\n"
"`0 + succ d = succ d`.\n"
"\n"
"Notez que vous devez prouver le premier\n"
"but avant de pouvoir acc√©der au second."

#: Game.Levels.Addition.L01zero_add
msgid ""
"This lemma would have been easy if we had known that `x + y = y + x`. That theorem\n"
"  is called `add_comm` and it is *true*, but unfortunately its proof *uses* both\n"
"  `add_zero` and `zero_add`!\n"
"\n"
"  Let's continue on our journey to `add_comm`, the proof of `x + y = y + x`."
msgstr ""
"Ce lemme aurait √©t√© facile si nous avions su que `x + y = y + x`. Ce th√©or√®me\n"
"  s'appelle `add_comm` et il est *vrai*, mais malheureusement sa preuve *utilise* √† la fois\n"
"  `add_zero` et `zero_add` !\n"
"\n"
"  Continuons notre voyage vers `add_comm`, la preuve de `x + y = y + x`."

#: Game.Levels.Addition.L02succ_add
msgid "succ_add"
msgstr "succ_add"

#: Game.Levels.Addition.L02succ_add
msgid ""
"Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add a b`\n"
"is the proof that `(succ a) + b = succ (a + b)` for `a` and `b` numbers.\n"
"This result is what's standing in the way of `x + y = y + x`. Again\n"
"we have the problem that we are adding `b` to things, so we need\n"
"to use induction to split into the cases where `b = 0` and `b` is a successor."
msgstr ""
"Oh non ! En chemin vers `add_comm`, un `succ_add` sauvage appara√Æt. `succ_add a b`\n"
"est la preuve que `(succ a) + b = succ (a + b)` pour `a` et `b` des nombres.\n"
"Ce r√©sultat est ce qui bloque pour `x + y = y + x`. Encore une fois\n"
"nous avons le probl√®me que nous ajoutons `b` √† des choses, donc nous devons\n"
"utiliser l'induction pour diviser entre les cas o√π `b = 0` et o√π `b` est un successeur."

#: Game.Levels.Addition.L02succ_add
msgid "`succ_add a b` is a proof that `succ a + b = succ (a + b)`."
msgstr "`succ_add a b` est une preuve que `succ a + b = succ (a + b)`."

#: Game.Levels.Addition.L02succ_add
msgid ""
"For all natural numbers $a, b$, we have\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$."
msgstr ""
"Pour tous les nombres naturels $a, b$, nous avons\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$."

#: Game.Levels.Addition.L02succ_add
msgid ""
"You might want to think about whether induction\n"
"on `a` or `b` is the best idea."
msgstr ""
"Vous pourriez r√©fl√©chir √† savoir si l'induction\n"
"sur `a` ou `b` est la meilleure id√©e."

#: Game.Levels.Addition.L02succ_add
msgid ""
"Induction on `a` will not work here. You are still stuck with an `+ b`.\n"
"I suggest you delete this line and try a different approach."
msgstr ""
"L'induction sur `a` ne fonctionnera pas ici. Vous √™tes toujours bloqu√© avec un `+ b`.\n"
"Je vous sugg√®re de supprimer cette ligne et d'essayer une approche diff√©rente."

#: Game.Levels.Addition.L02succ_add
msgid ""
"Note that `succ a + ¬´{d}¬ª` means `(succ a) + ¬´{d}¬ª`. Put your cursor\n"
"on any `succ` in the goal or assumptions to see what exactly it's eating."
msgstr ""
"Notez que `succ a + ¬´{d}¬ª` signifie `(succ a) + ¬´{d}¬ª`. Placez votre curseur\n"
"sur n'importe quel `succ` dans le but ou les hypoth√®ses pour voir exactement ce qu'il prend."

#: Game.Levels.Addition.L02succ_add
msgid "Well done! You now have enough tools to tackle the main boss of this level."
msgstr ""
"Bien jou√© ! Vous avez maintenant suffisamment d'outils pour affronter le boss principal de ce "
"niveau."

#: Game.Levels.Addition.L03add_comm
msgid "add_comm (level boss)"
msgstr "add_comm (boss du niveau)"

#: Game.Levels.Addition.L03add_comm
msgid ""
"[boss battle music]\n"
"\n"
"Look in your inventory to see the proofs you have available.\n"
"These should be enough."
msgstr ""
"[musique de combat de boss]\n"
"\n"
"Regardez dans votre inventaire les preuves dont vous disposez.\n"
"Cela devrait suffire."

#: Game.Levels.Addition.L03add_comm
msgid "`add_comm x y` is a proof of `x + y = y + x`."
msgstr "`add_comm x y` est une preuve de `x + y = y + x`."

#: Game.Levels.Addition.L03add_comm
msgid ""
"On the set of natural numbers, addition is commutative.\n"
"In other words, if `a` and `b` are arbitrary natural numbers, then\n"
"$a + b = b + a$."
msgstr ""
"Sur l'ensemble des nombres naturels, l'addition est commutative.\n"
"Autrement dit, si `a` et `b` sont des nombres naturels arbitraires, alors\n"
"$a + b = b + a$."

#: Game.Levels.Addition.L03add_comm
msgid "Induction on `a` or `b` -- it's all the same in this one."
msgstr "Induction sur `a` ou `b` -- c'est pareil dans ce cas."

#: Game.Levels.Addition.L04add_assoc
msgid "add_assoc (associativity of addition)"
msgstr "add_assoc (associativit√© de l'addition)"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"We've been adding up two numbers; in this level we will add up three.\n"
"\n"
"  What does $x+y+z$ *mean*? It could either mean $(x+y)+z$, or it\n"
"  could mean $x+(y+z)$. In Lean, $x+y+z$ means $(x+y)+z$.\n"
"\n"
"  But why do we care which one it means; $(x+y)+z$ and $x+(y+z)$ are *equal*!\n"
"\n"
"  That's true, but we didn't prove it yet. Let's prove it now by induction."
msgstr ""
"Nous avons additionn√© deux nombres ; dans ce niveau, nous en additionnerons trois.\n"
"\n"
"  Que signifie $x+y+z$ ? Cela pourrait signifier $(x+y)+z$, ou\n"
"  $x+(y+z)$. Dans Lean, $x+y+z$ signifie $(x+y)+z$.\n"
"\n"
"  Mais pourquoi se soucier de ce que cela signifie, en fait $(x+y)+z$ et $x+(y+z)$ sont *√©gaux* !\n"
"\n"
"  C'est vrai, mais nous ne l'avons pas encore prouv√©. Prouvons-le maintenant par induction."

#: Game.Levels.Addition.L04add_assoc
msgid ""
"`add_assoc a b c` is a proof\n"
"that `(a + b) + c = a + (b + c)`. Note that in Lean `(a + b) + c` prints\n"
"as `a + b + c`, because the notation for addition is defined to be left\n"
"associative."
msgstr ""
"`add_assoc a b c` est une preuve\n"
"que `(a + b) + c = a + (b + c)`. Notez que dans Lean `(a + b) + c` s'affiche\n"
"comme `a + b + c`, car la notation pour l'addition est d√©finie comme √©tant\n"
"associative √† gauche."

#: Game.Levels.Addition.L04add_assoc
msgid ""
"On the set of natural numbers, addition is associative.\n"
"In other words, for all natural numbers $a, b$ and $c$, we have\n"
"$ (a + b) + c = a + (b + c). $"
msgstr ""
"Sur l'ensemble des nombres naturels, l'addition est associative.\n"
"Autrement dit, pour tous les nombres naturels $a, b$ et $c$, nous avons\n"
"$ (a + b) + c = a + (b + c). $"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\n"
"If you are not sure where the brackets are in an expression, just hover\n"
"your cursor over it and look at what gets highlighted. For example,\n"
"hover over both `+` symbols on the left hand side of the goal and\n"
"you'll see where the invisible brackets are."
msgstr ""
"Rappelez-vous que lorsque Lean √©crit `a + b + c`, cela signifie `(a + b) + c`.\n"
"Si vous n'√™tes pas s√ªr des parenth√®ses dans une expression, passez simplement\n"
"votre curseur dessus et regardez ce qui est mis en √©vidence. Par exemple,\n"
"passez sur les deux symboles `+` du c√¥t√© gauche du but et\n"
"vous verrez o√π sont les parenth√®ses invisibles."

#: Game.Levels.Addition.L04add_assoc
msgid ""
"A passing mathematician congratulates you on proving that naturals\n"
"are an additive commutative monoid.\n"
"\n"
"Let's practice using `add_assoc` and `add_comm` in one more level,\n"
"before we leave addition world."
msgstr ""
"Un math√©maticien de passage vous f√©licite d'avoir prouv√© que les entiers naturels\n"
"forment un mono√Øde commutatif additif.\n"
"\n"
"Si vous voulez vous entra√Æner √† utiliser `add_assoc` et `add_comm` dans un niveau suppl√©mentaire,\n"
"avant de quitter le monde de l'addition."

#: Game.Levels.Addition.L05add_right_comm
msgid "add_right_comm"
msgstr "add_right_comm"

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"`add_comm b c` is a proof that `b + c = c + b`. But if your goal\n"
"is `a + b + c = a + c + b` then `rw [add_comm b c]` will not\n"
"work! Because the goal means `(a + b) + c = (a + c) + b` so there\n"
"is no `b + c` term *directly* in the goal.\n"
"\n"
"Use associativity and commutativity to prove `add_right_comm`.\n"
"You don't need induction. `add_assoc` moves brackets around,\n"
"and `add_comm` moves variables around.\n"
"\n"
"Remember that you can do more targetted rewrites by\n"
"adding explicit variables as inputs to theorems. For example `rw [add_comm b]`\n"
"will only do rewrites of the form `b + ? = ? + b`, and `rw [add_comm b c]`\n"
"will only do rewrites of the form `b + c = c + b`."
msgstr ""
"`add_comm b c` est une preuve que `b + c = c + b`. Mais si votre but\n"
"est `a + b + c = a + c + b` alors `rw [add_comm b c]` ne\n"
"fonctionnera pas ! Parce que le but signifie `(a + b) + c = (a + c) + b` donc il n'y a\n"
"pas de terme `b + c` *directement* dans le but.\n"
"\n"
"Utilisez l'associativit√© et la commutativit√© pour prouver `add_right_comm`.\n"
"Vous n'avez pas besoin d'induction. `add_assoc` d√©place les parenth√®ses,\n"
"et `add_comm` √©change les variables.\n"
"\n"
"Rappelez-vous que vous pouvez faire des r√©√©critures plus cibl√©es en\n"
"ajoutant des variables explicites comme entr√©es aux th√©or√®mes. Par exemple `rw [add_comm b]`\n"
"ne fera que des r√©√©critures de la forme `b + ? = ? + b`, et `rw [add_comm b c]`\n"
"ne fera que des r√©√©critures de la forme `b + c = c + b`."

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"`add_right_comm a b c` is a proof that `(a + b) + c = (a + c) + b`\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, so this result gets displayed\n"
"as `a + b + c = a + c + b`."
msgstr ""
"`add_right_comm a b c` est une preuve que `(a + b) + c = (a + c) + b`\n"
"\n"
"Dans Lean, `a + b + c` signifie `(a + b) + c`, donc ce r√©sultat s'affiche\n"
"comme `a + b + c = a + c + b`."

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"If $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$(a + b) + c = (a + c) + b$."
msgstr ""
"Si $a, b$ et $c$ sont des nombres naturels arbitraires, nous avons\n"
"$(a + b) + c = (a + c) + b$."

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"You've now seen all the tactics you need to beat the final boss of the game.\n"
"You can begin the journey towards this boss by entering Multiplication World.\n"
"\n"
"Or you can go off the beaten track and learn some new tactics in Implication\n"
"World. These tactics let you prove more facts about addition, such as\n"
"how to deduce `a = 0` from `x + a = x`.\n"
"\n"
"Click \"Leave World\" and make your choice."
msgstr ""
"Vous avez maintenant vu toutes les tactiques n√©cessaires pour vaincre le boss final du jeu.\n"
"Vous pouvez commencer le voyage vers ce boss en entrant dans le monde de la Multiplication.\n"
"\n"
"Ou vous pouvez sortir des sentiers battus et apprendre de nouvelles tactiques dans le monde\n"
"de l'Implication. Ces tactiques vous permettent de prouver plus de r√©sultats sur l'addition, "
"comme\n"
"comment d√©duire `a = 0` de `x + a = x`.\n"
"\n"
"Cliquez sur \"Quitter le monde\" et faites votre choix."

#: Game.Levels.Addition
msgid "Addition World"
msgstr "Monde de l'Addition"

#: Game.Levels.Addition
msgid ""
"Welcome to Addition World! In this world we'll learn the `induction` tactic.\n"
"This will enable us to defeat the boss level of this world, namely `x + y = y + x`.\n"
"\n"
"The tactics `rw`, `rfl` and `induction` are the only tactics you'll need to\n"
"beat all the levels in Addition World, Multiplication World, and Power World.\n"
"Power World contains the final boss of the game.\n"
"\n"
"There are plenty more tactics in this game, but you'll only need to know them if you\n"
"want to explore the game further (for example if you decide to 100%\n"
"the game)."
msgstr ""
"Bienvenue dans le monde de l'Addition ! Dans ce monde, nous apprendrons la tactique `induction`.\n"
"Cela nous permettra de vaincre le niveau boss de ce monde, √† savoir `x + y = y + x`.\n"
"\n"
"Les tactiques `rw`, `rfl` et `induction` sont les seules dont vous aurez besoin\n"
"pour vaincre tous les niveaux du monde de l'Addition, du monde de la Multiplication et du monde "
"des Puissances.\n"
"Le monde des Puissances contient le boss final du jeu.\n"
"\n"
"Il y a beaucoup d'autres tactiques dans ce jeu, mais vous n'aurez besoin de les conna√Ætre que si "
"vous\n"
"voulez explorer le jeu plus avant (par exemple si vous d√©cidez de finir le jeu √† 100%)."

#: Game.Levels.Multiplication.L01mul_one
msgid "mul_one"
msgstr "mul_one"

#: Game.Levels.Multiplication.L01mul_one
msgid ""
"See the new \"*\" tab in your lemmas, containing `mul_zero` and `mul_succ`.\n"
"Right now these are the only facts we know about multiplication.\n"
"Let's prove nine more.\n"
"\n"
"Let's start with a warm-up: no induction needed for this one,\n"
"because we know `1` is a successor."
msgstr ""
"Voyez le nouvel onglet \"*\" dans vos lemmes, contenant `mul_zero` et `mul_succ`.\n"
"Actuellement, ce sont les seuls faits que nous connaissons sur la multiplication.\n"
"Prouvons-en neuf de plus.\n"
"\n"
"Commen√ßons par un √©chauffement : aucune induction n'est n√©cessaire pour celui-ci,\n"
"car nous savons que `1` est un successeur."

#: Game.Levels.Multiplication.L01mul_one
msgid ""
"`Mul a b`, with notation `a * b`, is the usual\n"
"  product of natural numbers. Internally it is\n"
"  via two axioms:\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"\n"
"  * `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"Other theorems about naturals, such as `zero_mul`,\n"
"are proved by induction from these two basic theorems."
msgstr ""
"`Mul a b`, avec la notation `a * b`, est le produit\n"
"  habituel des nombres naturels. En interne, il est\n"
"  d√©fini par deux axiomes :\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"\n"
"  * `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"D'autres th√©or√®mes sur les naturels, comme `zero_mul`,\n"
"sont prouv√©s par induction √† partir de ces deux th√©or√®mes de base."

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_zero m` is the proof that `m * 0 = 0`."
msgstr "`mul_zero m` est la preuve que `m * 0 = 0`."

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_succ a b` is the proof that `a * succ b = a * b + a`."
msgstr "`mul_succ a b` est la preuve que `a * succ b = a * b + a`."

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_one m` is the proof that `m * 1 = m`."
msgstr "`mul_one m` est la preuve que `m * 1 = m`."

#: Game.Levels.Multiplication.L01mul_one
msgid "For any natural number $m$, we have $ m \\times 1 = m$."
msgstr "Pour tout nombre naturel $m$, nous avons $ m \\times 1 = m$."

#: Game.Levels.Multiplication.L02zero_mul
msgid "zero_mul"
msgstr "zero_mul"

#: Game.Levels.Multiplication.L02zero_mul
msgid ""
"Our first challenge is `mul_comm x y : x * y = y * x`,\n"
"and we want to prove it by induction. The zero\n"
"case will need `mul_zero` (which we have)\n"
"and `zero_mul` (which we don't), so let's\n"
"start with this."
msgstr ""
"Notre premier d√©fi est `mul_comm x y : x * y = y * x`,\n"
"et nous voulons le prouver par induction. Le cas\n"
"z√©ro aura besoin de `mul_zero` (que nous avons)\n"
"et de `zero_mul` (que nous n'avons pas), donc commen√ßons\n"
"par cela."

#: Game.Levels.Multiplication.L02zero_mul
msgid ""
"`zero_mul x` is the proof that `0 * x = 0`.\n"
"\n"
"Note: `zero_mul` is a `simp` lemma."
msgstr ""
"`zero_mul x` est la preuve que `0 * x = 0`.\n"
"\n"
"Note : `zero_mul` est un lemme `simp`."

#: Game.Levels.Multiplication.L02zero_mul
msgid "For all natural numbers $m$, we have $ 0 \\times m = 0$."
msgstr "Pour tous les nombres naturels $m$, nous avons $ 0 \\times m = 0$."

#: Game.Levels.Multiplication.L03succ_mul
msgid "succ_mul"
msgstr "succ_mul"

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"Similarly we have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions).\n"
"\n"
"The last level from addition world might help you in this level.\n"
"If you can't remember what it is, you can go back to the\n"
"home screen by clicking the house icon and then taking a look.\n"
"You won't lose any progress."
msgstr ""
"De m√™me, nous avons `mul_succ`\n"
"mais nous allons avoir besoin de `succ_mul` (devinez ce que cela dit -- peut-√™tre\n"
"commencez-vous √† comprendre les conventions de nommage de Lean).\n"
"\n"
"Le dernier niveau du monde de l'addition pourrait vous aider dans ce niveau.\n"
"Si vous ne vous souvenez pas ce que c'est, vous pouvez revenir √† l'√©cran d'accueil\n"
"en cliquant sur l'ic√¥ne maison et jeter un coup d'≈ìil.\n"
"Vous ne perdrez aucun progr√®s."

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"`succ_mul a b` is the proof that `succ a * b = a * b + b`.\n"
"\n"
"It could be deduced from `mul_succ` and `mul_comm`, however this argument\n"
"would be circular because the proof of `mul_comm` uses `mul_succ`."
msgstr ""
"`succ_mul a b` est la preuve que `succ a * b = a * b + b`.\n"
"\n"
"Cela pourrait √™tre d√©duit de `mul_succ` et `mul_comm`, cependant cet argument\n"
"serait circulaire car la preuve de `mul_comm` utilise `mul_succ`."

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"For all natural numbers $a$ and $b$, we have\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$."
msgstr ""
"Pour tous les nombres naturels $a$ et $b$, nous avons\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$."

#: Game.Levels.Multiplication.L04mul_comm
msgid "mul_comm"
msgstr "mul_comm"

#: Game.Levels.Multiplication.L04mul_comm
msgid ""
"The first sub-boss of Multiplication World is `mul_comm x y : x * y = y * x`.\n"
"\n"
"When you've proved this theorem we will have \"spare\" proofs\n"
"such as `zero_mul`, which is now easily deducible from `mul_zero`.\n"
"But we'll keep hold of these proofs anyway, because it's convenient\n"
"to have exactly the right tool for a job."
msgstr ""
"Le premier sous-boss du monde de la Multiplication est `mul_comm x y : x * y = y * x`.\n"
"\n"
"Lorsque vous aurez prouv√© ce th√©or√®me, nous aurons des preuves \"suppl√©mentaires\"\n"
"comme `zero_mul`, qui est maintenant facilement d√©ductible de `mul_zero`.\n"
"Mais nous garderons ces preuves quand m√™me, car c'est pratique\n"
"d'avoir exactement le bon outil pour certaines t√¢ches."

#: Game.Levels.Multiplication.L04mul_comm
msgid ""
"`mul_comm` is the proof that multiplication is commutative. More precisely,\n"
"`mul_comm a b` is the proof that `a * b = b * a`."
msgstr ""
"`mul_comm` est la preuve que la multiplication est commutative. Plus pr√©cis√©ment,\n"
"`mul_comm a b` est la preuve que `a * b = b * a`."

#: Game.Levels.Multiplication.L04mul_comm
msgid "Multiplication is commutative."
msgstr "La multiplication est commutative."

#: Game.Levels.Multiplication.L05one_mul
msgid "one_mul"
msgstr "one_mul"

#: Game.Levels.Multiplication.L05one_mul
msgid ""
"You can prove $1\\times m=m$ in at least three ways.\n"
"Either by induction, or by using `succ_mul`, or\n"
"by using commutativity. Which do you think is quickest?"
msgstr ""
"Vous pouvez prouver $1\\times m=m$ d'au moins trois fa√ßons.\n"
"Soit par induction, soit en utilisant `succ_mul`, soit\n"
"en utilisant la commutativit√©. Selon vous, laquelle est la plus rapide ?"

#: Game.Levels.Multiplication.L05one_mul
msgid "`one_mul m` is the proof `1 * m = m`."
msgstr "`one_mul m` est la preuve que `1 * m = m`."

#: Game.Levels.Multiplication.L05one_mul
msgid "For any natural number $m$, we have $ 1 \\times m = m$."
msgstr "Pour tout nombre naturel $m$, nous avons $ 1 \\times m = m$."

#: Game.Levels.Multiplication.L05one_mul
msgid ""
"Here's my solution:\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"
msgstr ""
"Voici ma solution :\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L06two_mul
msgid "two_mul"
msgstr "two_mul"

#: Game.Levels.Multiplication.L06two_mul
msgid ""
"This level is more important than you think; it plays\n"
"a useful role when battling a big boss later on."
msgstr ""
"Ce niveau est plus important que vous ne le pensez ; il joue\n"
"un r√¥le utile lors du combat contre un gros boss plus tard."

#: Game.Levels.Multiplication.L06two_mul
msgid "`two_mul m` is the proof that `2 * m = m + m`."
msgstr "`two_mul m` est la preuve que `2 * m = m + m`."

#: Game.Levels.Multiplication.L06two_mul
msgid "For any natural number $m$, we have $ 2 \\times m = m+m$."
msgstr "Pour tout nombre naturel $m$, nous avons $ 2 \\times m = m+m$."

#: Game.Levels.Multiplication.L06two_mul
msgid ""
"Here's my solution:\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"
msgstr ""
"Voici ma solution :\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L07mul_add
msgid "mul_add"
msgstr "mul_add"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Our next goal is \"left and right distributivity\",\n"
"meaning $a(b+c)=ab+ac$ and $(b+c)a=ba+ca$. Rather than\n"
"these slightly pompous names, the name of the proofs\n"
"in Lean are descriptive. Let's start with\n"
"`mul_add a b c`, the proof of `a * (b + c) = a * b + a * c`.\n"
"Note that the left hand side contains a multiplication\n"
"and then an addition."
msgstr ""
"Notre prochain objectif est la \"distributivit√© √† gauche et √† droite\",\n"
"c'est-√†-dire $a(b+c)=ab+ac$ et $(b+c)a=ba+ca$. Plut√¥t que\n"
"ces noms un peu pompeux, les noms des preuves\n"
"dans Lean sont descriptifs. Commen√ßons par\n"
"`mul_add a b c`, la preuve de `a * (b + c) = a * b + a * c`.\n"
"Notez que le c√¥t√© gauche contient une multiplication\n"
"puis une addition."

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Multiplication distributes\n"
"over addition on the left.\n"
"\n"
"`mul_add a b c` is the proof that `a * (b + c) = a * b + a * c`."
msgstr ""
"La multiplication est distributive\n"
"sur l'addition √† gauche.\n"
"\n"
"`mul_add a b c` est la preuve que `a * (b + c) = a * b + a * c`."

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Multiplication is distributive over addition on the left.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$a(b + c) = ab + ac$."
msgstr ""
"La multiplication est distributive sur l'addition √† gauche.\n"
"Autrement dit, pour tous les nombres naturels $a$, $b$ et $c$, nous avons\n"
"$a(b + c) = ab + ac$."

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"You can do induction on any of the three variables. Some choices\n"
"are harder to push through than others. Can you do the inductive step in\n"
"5 rewrites only?"
msgstr ""
"Vous pouvez faire une induction sur l'une des trois variables. Certains choix\n"
"sont plus difficiles √† mener que d'autres. Pouvez-vous faire l'√©tape inductive\n"
"en seulement 5 r√©√©critures ?"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Induction on `a` is the most troublesome, then `b`,\n"
"and `c` is the easiest."
msgstr ""
"L'induction sur `a` est la plus probl√©matique, puis `b`,\n"
"et `c` est la plus facile."

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Here's my solution:\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"Inducting on `a` or `b` also works, but might take longer."
msgstr ""
"Voici ma solution :\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"L'induction sur `a` ou `b` fonctionne aussi, mais pourrait prendre plus de temps √† √©crire."

#: Game.Levels.Multiplication.L08add_mul
msgid "add_mul"
msgstr "add_mul"

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"`add_mul` is just as fiddly to prove by induction; but there's a trick\n"
"which avoids it. Can you spot it?"
msgstr ""
"`add_mul` est tout aussi d√©licat √† prouver par induction ; mais il y a une astuce\n"
"pour l'√©viter. Pouvez-vous la trouver ?"

#: Game.Levels.Multiplication.L08add_mul
msgid "`add_mul a b c` is a proof that $(a+b)c=ac+bc$."
msgstr "`add_mul a b c` est une preuve que $(a+b)c=ac+bc$."

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(a + b) \\times c = ac + bc$."
msgstr ""
"L'addition est distributive sur la multiplication.\n"
"Autrement dit, pour tous les nombres naturels $a$, $b$ et $c$, nous avons\n"
"$(a + b) \\times c = ac + bc$."

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"Here's my proof:\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"
msgstr ""
"Voici ma preuve :\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L09mul_assoc
msgid "mul_assoc"
msgstr "mul_assoc"

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"We now have enough to prove that multiplication is associative,\n"
"the boss level of multiplication world. Good luck!"
msgstr ""
"Nous avons maintenant assez de mati√®re pour prouver que la multiplication est associative,\n"
"le niveau boss du monde de la multiplication. Bonne chance !"

#: Game.Levels.Multiplication.L09mul_assoc
msgid "`mul_assoc a b c` is a proof that `(a * b) * c = a * (b * c)`.\n"
"\n"
"Note that when Lean says `a * b * c` it means `(a * b) * c`.\n"
"\n"
"Note that `(a * b) * c = a * (b * c)` cannot be proved by \\\"pure thought\\\":\n"
"for example subtraction is not associative, as `(6 - 2) - 1` is not\n"
"equal to `6 - (2 - 1)`."
msgstr "`mul_assoc a b c` est une preuve que `(a * b) * c = a * (b * c)`.\n"
"\n"
"Notez que dans Lean `a * b * c` signifie `(a * b) * c`.\n"
"\n"
"Notez aussi que `(a * b) * c = a * (b * c)` ne peut pas √™tre prouv√© par \"pens√©e pure\" :\n"
"par exemple, la soustraction n'est pas associative, car `(6 - 2) - 1` n'est pas\n"
"√©gal √† `6 - (2 - 1)`."

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(ab)c = a(bc)$."
msgstr ""
"La multiplication est associative.\n"
"Autrement dit, pour tous les nombres naturels $a$, $b$ et $c$, nous avons\n"
"$(ab)c = a(bc)$."

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"A passing mathematician notes that you've proved\n"
"that the natural numbers are a commutative semiring.\n"
"\n"
"If you want to begin your journey to the final boss, head for Power World."
msgstr ""
"Un math√©maticien de passage vous f√©licite d'avoir prouv√©\n"
"que les nombres naturels forment un semi-anneau commutatif.\n"
"\n"
"Si vous voulez commencer votre voyage vers le boss final, dirigez-vous vers le monde des "
"Puissances."

#: Game.Levels.Multiplication
msgid "Multiplication World"
msgstr "Monde de la Multiplication"

#: Game.Levels.Multiplication
msgid ""
"How should we define `37 * x`? Just like addition, we need to give definitions\n"
"when $x=0$ and when $x$ is a successor.\n"
"\n"
"The zero case is easy: we define `37 * 0` to be `0`. Now say we know\n"
"`37 * d`. What should `37 * succ d` be? Well, that's $(d+1)$ $37$s,\n"
"so it should be `37 * d + 37`.\n"
"\n"
"Here are the definitions in Lean.\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"In this world, we must not only prove facts about multiplication like `a * b = b * a`,\n"
"we must also prove facts about how multiplication interacts with addition, like `a * (b + c) = a * "
"b + a * c`.\n"
"Let's get started."
msgstr ""
"Comment devrions-nous d√©finir `37 * x` ? Tout comme pour l'addition, nous devons donner des "
"d√©finitions\n"
"lorsque $x=0$ et lorsque $x$ est un successeur.\n"
"\n"
"Le cas z√©ro est facile : nous d√©finissons `37 * 0` comme `0`. Maintenant, disons que nous "
"connaissons\n"
"`37 * d`. Que devrait √™tre `37 * succ d` ? Eh bien, c'est $(d+1)$ fois $37$,\n"
"donc cela devrait √™tre `37 * d + 37`.\n"
"\n"
"Voici les d√©finitions dans Lean.\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"Dans ce monde, nous devons non seulement prouver des faits sur la multiplication comme `a * b = b "
"* a`,\n"
"mais aussi des faits sur la fa√ßon dont la multiplication interagit avec l'addition, comme `a * (b "
"+ c) = a * b + a * c`.\n"
"Commen√ßons."

#: Game.Levels.Power.L01zero_pow_zero
msgid "zero_pow_zero"
msgstr "zero_pow_zero"

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"Mathematicians sometimes debate what `0 ^ 0` is;\n"
"the answer depends, of course, on your definitions. In this\n"
"game, `0 ^ 0 = 1`. See if you can prove it.\n"
"\n"
"Check out the *Pow* tab in your list of theorems\n"
"to see the new proofs which are available."
msgstr ""
"Les math√©maticiens d√©battent parfois de ce qu'est `0 ^ 0` ;\n"
"la r√©ponse d√©pend, bien s√ªr, de vos d√©finitions. Dans ce\n"
"jeu, `0 ^ 0 = 1`. Voyez si vous pouvez le prouver.\n"
"\n"
"Consultez l'onglet *Pow* dans votre liste de th√©or√®mes\n"
"pour voir les nouvelles preuves disponibles."

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"`Pow a b`, with notation `a ^ b`, is the usual\n"
"  exponentiation of natural numbers. Internally it is\n"
"  defined via two axioms:\n"
"\n"
"  * `pow_zero a : a ^ 0 = 1`\n"
"\n"
"  * `pow_succ a b : a ^ succ b = a ^ b * a`\n"
"\n"
"Note in particular that `0 ^ 0 = 1`."
msgstr ""
"`Pow a b`, avec la notation `a ^ b`, est l'exponentiation\n"
"  habituelle des nombres naturels, c'est √† dire `a` puissance `b. En interne, elle est\n"
"  d√©finie par deux axiomes :\n"
"\n"
"  * `pow_zero a : a ^ 0 = 1`\n"
"\n"
"  * `pow_succ a b : a ^ succ b = a ^ b * a`\n"
"\n"
"Notez en particulier que `0 ^ 0 = 1`."

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"`pow_zero a : a ^ 0 = 1` is one of the two axioms\n"
"defining exponentiation in this game."
msgstr ""
"`pow_zero a : a ^ 0 = 1` est l'un des deux axiomes\n"
"d√©finissant l'exponentiation dans ce jeu."

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"Mathematicians sometimes argue that `0 ^ 0 = 0` is also\n"
"a good convention. But it is not a good convention in this\n"
"game; all the later levels come out beautifully with the\n"
"convention that `0 ^ 0 = 1`."
msgstr ""
"Les math√©maticiens soutiennent parfois que `0 ^ 0 = 0` est aussi\n"
"une bonne convention. Mais ce n'est pas une bonne convention dans ce\n"
"jeu ; tous les niveaux suivants fonctionnent parfaitement avec la\n"
"convention que `0 ^ 0 = 1`."

#: Game.Levels.Power.L01zero_pow_zero
msgid "$0 ^ 0 = 1$"
msgstr "$0 ^ 0 = 1$"

#: Game.Levels.Power.L02zero_pow_succ
msgid "zero_pow_succ"
msgstr "zero_pow_succ"

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"We've just seen that `0 ^ 0 = 1`, but if `n`\n"
"is a successor, then `0 ^ n = 0`. We prove that here."
msgstr ""
"Nous venons de voir que `0 ^ 0 = 1`, mais si `n`\n"
"est un successeur, alors `0 ^ n = 0`. Nous le prouvons ici."

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"`pow_succ a b : a ^ (succ b) = a ^ b * a` is one of the\n"
"two axioms defining exponentiation in this game."
msgstr ""
"`pow_succ a b : a ^ (succ b) = a ^ b * a` est l'un des\n"
"deux axiomes d√©finissant l'exponentiation dans ce jeu."

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"Although $0^0=1$ in this game, $0^n=0$ if $n>0$, i.e., if\n"
"$n$ is a successor."
msgstr ""
"Bien que $0^0=1$ dans ce jeu, $0^n=0$ si $n>0$, c'est-√†-dire si\n"
"$n$ est un successeur."

#: Game.Levels.Power.L02zero_pow_succ
msgid "For all numbers $m$, $0 ^{\\operatorname{succ} (m)} = 0$."
msgstr "Pour tous les nombres $m$, $0 ^{\\operatorname{succ} (m)} = 0$."

#: Game.Levels.Power.L03pow_one
msgid "pow_one"
msgstr "pow_one"

#: Game.Levels.Power.L03pow_one
msgid ""
"`pow_one a` says that `a ^ 1 = a`.\n"
"\n"
"Note that this is not quite true by definition: `a ^ 1` is\n"
"defined to be `a ^ 0 * a` so it's `1 * a`, and to prove\n"
"that this is equal to `a` you need to use induction somewhere."
msgstr ""
"`pow_one a` dit que `a ^ 1 = a`.\n"
"\n"
"Notez que ce n'est pas tout √† fait vrai par d√©finition : `a ^ 1` est\n"
"d√©fini comme `a ^ 0 * a`, donc c'est `1 * a`, et pour prouver\n"
"que cela est √©gal √† `a`, vous devez utiliser l'induction quelque part."

#: Game.Levels.Power.L03pow_one
msgid "For all naturals $a$, $a ^ 1 = a$."
msgstr "Pour tous les naturels $a$, $a ^ 1 = a$."

#: Game.Levels.Power.L04one_pow
msgid "one_pow"
msgstr "one_pow"

#: Game.Levels.Power.L04one_pow
msgid "`one_pow n` is a proof that $1^n=1$."
msgstr "`one_pow n` est une preuve que $1^n=1$."

#: Game.Levels.Power.L04one_pow
msgid "For all naturals $m$, $1 ^ m = 1$."
msgstr "Pour tous les naturels $m$, $1 ^ m = 1$."

#: Game.Levels.Power.L05pow_two
msgid "pow_two"
msgstr "pow_two"

#: Game.Levels.Power.L05pow_two
msgid "Note: this lemma will be useful for the final boss!"
msgstr "Note : ce lemme sera utile pour le boss final !"

#: Game.Levels.Power.L05pow_two
msgid "`pow_two a` says that `a ^ 2 = a * a`."
msgstr "`pow_two a` dit que `a ^ 2 = a * a`."

#: Game.Levels.Power.L05pow_two
msgid "For all naturals $a$, $a ^ 2 = a \\times a$."
msgstr "Pour tous les naturels $a$, $a ^ 2 = a \\times a$."

#: Game.Levels.Power.L06pow_add
msgid "pow_add"
msgstr "pow_add"

#: Game.Levels.Power.L06pow_add
msgid ""
"Let's now begin our approach to the final boss,\n"
"by proving some more subtle facts about powers."
msgstr ""
"Commen√ßons maintenant notre approche vers le boss final,\n"
"en prouvant des faits plus subtils sur les puissances."

#: Game.Levels.Power.L06pow_add
msgid "`pow_add a m n` is a proof that $a^{m+n}=a^ma^n.$"
msgstr "`pow_add a m n` est une preuve que $a^{m+n}=a^ma^n.$"

#: Game.Levels.Power.L06pow_add
msgid "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$."
msgstr "Pour tous les naturels $a$, $m$, $n$, nous avons $a^{m + n} = a ^ m  a ^ n$."

#: Game.Levels.Power.L07mul_pow
msgid "mul_pow"
msgstr "mul_pow"

#: Game.Levels.Power.L07mul_pow
msgid ""
"The music gets ever more dramatic, as we explore\n"
"the interplay between exponentiation and multiplication.\n"
"\n"
"If you're having trouble exchanging the right `a * b`\n"
"because `rw [mul_comm]` swaps the wrong multiplication,\n"
"then read the documentation of `rw` for tips on how to fix this."
msgstr ""
"La musique devient de plus en plus dramatique alors que nous explorons\n"
"l'interaction entre exponentiation et multiplication.\n"
"\n"
"Si vous avez du mal √† √©changer le bon `a * b`\n"
"parce que `rw [mul_comm]` √©change la mauvaise multiplication,\n"
"lisez la documentation de `rw` pour des conseils sur la fa√ßon de r√©soudre ce probl√®me."

#: Game.Levels.Power.L07mul_pow
msgid "`mul_pow a b n` is a proof that $(ab)^n=a^nb^n.$"
msgstr "`mul_pow a b n` est une preuve que $(ab)^n=a^nb^n.$"

#: Game.Levels.Power.L07mul_pow
msgid "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$."
msgstr "Pour tous les naturels $a$, $b$, $n$, nous avons $(ab) ^ n = a ^ nb ^ n$."

#: Game.Levels.Power.L08pow_pow
msgid "pow_pow"
msgstr "pow_pow"

#: Game.Levels.Power.L08pow_pow
msgid ""
"One of the best named levels in the game, a savage `pow_pow`\n"
"sub-boss appears as the music reaches a frenzy. What\n"
"else could there be to prove about powers after this?"
msgstr ""
"L'un des niveaux les mieux nomm√©s du jeu, un sous-boss f√©roce `pow_pow` \n"
"appara√Æt alors que la musique atteint son paroxysme. Que\n"
"pourrait-il y avoir d'autre √† prouver sur les puissances apr√®s cela ?"

#: Game.Levels.Power.L08pow_pow
msgid "`pow_pow a m n` is a proof that $(a^m)^n=a^{mn}.$"
msgstr "`pow_pow a m n` est une preuve que $(a^m)^n=a^{mn}.$"

#: Game.Levels.Power.L08pow_pow
msgid "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$."
msgstr "Pour tous les naturels $a$, $m$, $n$, nous avons $(a ^ m) ^ n = a ^ {mn}$."

#: Game.Levels.Power.L08pow_pow
msgid ""
"The music dies down. Is that it?\n"
"\n"
"Course it isn't, you can\n"
"clearly see that there are two levels left.\n"
"\n"
"A passing mathematician says that mathematicians don't have a name\n"
"for the structure you just constructed. You feel cheated.\n"
"\n"
"Suddenly the music starts up again. This really is the final boss."
msgstr ""
"La musique s'apaise. Est-ce tout ?\n"
"\n"
"Bien s√ªr que non, vous pouvez\n"
"clairement voir qu'il reste deux niveaux.\n"
"\n"
"Un math√©maticien de passage dit que les math√©maticiens n'ont pas de nom\n"
"pour la structure que vous venez de construire. Vous vous sentez tromp√©.\n"
"\n"
"Soudain, la musique repart. C'est vraiment le boss final."

#: Game.Levels.Power.L09add_sq
msgid "add_sq"
msgstr "add_sq"

#: Game.Levels.Power.L09add_sq
msgid "[final boss music]"
msgstr "[musique de boss final]"

#: Game.Levels.Power.L09add_sq
msgid "`add_sq a b` is the statement that $(a+b)^2=a^2+b^2+2ab.$"
msgstr "`add_sq a b` est l'√©nonc√© que $(a+b)^2=a^2+b^2+2ab.$"

#: Game.Levels.Power.L09add_sq
msgid ""
"For all numbers $a$ and $b$, we have\n"
"$$(a+b)^2=a^2+b^2+2ab.$$"
msgstr ""
"Pour tous les nombres $a$ et $b$, nous avons\n"
"$$(a+b)^2=a^2+b^2+2ab.$$"

#: Game.Levels.Power.L09add_sq
msgid ""
"It's all over! You have proved a theorem which has tripped up\n"
"schoolkids for generations (some of them think $(a+b)^2=a^2+b^2$:\n"
"this is \"the freshman's dream\").\n"
"\n"
"How many rewrites did you use? I can do it in 12.\n"
"\n"
"But wait! This boss is stirring...and mutating into a second more powerful form!"
msgstr ""
"C'est fini ! Vous avez prouv√© un th√©or√®me qui a pi√©g√©\n"
"les √©coliers depuis des g√©n√©rations (certains pensent que $(a+b)^2=a^2+b^2$ :\n"
"c'est \"le r√™ve du d√©butant\").\n"
"\n"
"Combien de r√©√©critures avez-vous utilis√©es ? Je peux le faire en 12.\n"
"\n"
"Mais attendez ! Ce boss s'agite... et mute en une deuxi√®me forme plus puissante !"

#: Game.Levels.Power.L10FLT
msgid "Fermat's Last Theorem"
msgstr "Grand th√©or√®me de Fermat"

#: Game.Levels.Power.L10FLT
msgid ""
"We now have enough to state a mathematically accurate, but slightly\n"
"clunky, version of Fermat's Last Theorem.\n"
"\n"
"Fermat's Last Theorem states that if $x,y,z>0$ and $m \\geq 3$ then $x^m+y^m\\not =z^m$.\n"
"If you didn't do inequality world yet then we can't talk about $m \\geq 3$,\n"
"so we have to resort to the hack of using `n + 3` for `m`,\n"
"which guarantees it's big enough. Similarly instead of `x > 0` we\n"
"use `a + 1`.\n"
"\n"
"This level looks superficially like other levels we have seen,\n"
"but the shortest solution known to humans would translate into\n"
"many millions of lines of Lean code. The author of this game,\n"
"Kevin Buzzard, is working on translating the proof by Wiles\n"
"and Taylor into Lean, although this task will take many years.\n"
"\n"
"## CONGRATULATIONS!\n"
"\n"
"You've finished the main quest of the natural number game!\n"
"If you would like to learn more about how to use Lean to\n"
"prove theorems in mathematics, then take a look\n"
"at [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\n"
"an interactive textbook which you can read in your browser,\n"
"and which explains how to work with many more mathematical concepts in Lean."
msgstr ""
"Nous avons maintenant suffisamment de connaissance pour √©noncer une version math√©matiquement "
"exacte, mais un peu\n"
"maladroite, du \"grand th√©or√®me de Fermat\".\n"
"\n"
"Le dernier th√©or√®me de Fermat √©nonce que si $x,y,z>0$ et $m \\geq 3$ alors $x^m+y^m\\not =z^m$.\n"
"Si vous n'avez pas encore fait le monde des in√©galit√©s, nous ne pouvons pas parler de $m \\geq "
"3$,\n"
"nous devons donc recourir √† l'astuce d'utiliser `n + 3` pour `m`,\n"
"ce qui garantit qu'il est assez grand. De m√™me, au lieu de `x > 0` nous\n"
"utilisons `a + 1`.\n"
"\n"
"Ce niveau ressemble superficiellement √† d'autres niveaux que nous avons vus,\n"
"mais la solution la plus courte connue des humains se traduirait par\n"
"plusieurs millions de lignes de code Lean. L'auteur de ce jeu,\n"
"Kevin Buzzard, travaille √† traduire la preuve de Wiles\n"
"et Taylor dans Lean, m√™me si cette t√¢che prendra de nombreuses ann√©es.\n"
"\n"
"## F√âLICITATIONS !\n"
"\n"
"Vous avez termin√© la qu√™te principale du jeu des nombres naturels !\n"
"Si vous souhaitez en savoir plus sur l'utilisation de Lean pour\n"
"prouver des th√©or√®mes en math√©matiques, jetez un ≈ìil\n"
"√† [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\n"
"un manuel interactif que vous pouvez lire dans votre navigateur,\n"
"et qui explique comment travailler avec beaucoup d'autres concepts math√©matiques dans Lean."

#: Game.Levels.Power.L10FLT
msgid ""
"`xyzzy` is an ancient magic spell, believed to be the origin of the\n"
"modern word `sorry`. The game won't complain - or notice - if you\n"
"prove anything with `xyzzy`."
msgstr ""
"`xyzzy` est un ancien sortil√®ge magique, consid√©r√© comme l'origine du\n"
"mot moderne `sorry`. Le jeu ne se plaindra pas - ou ne remarquera pas - si vous\n"
"prouvez quoi que ce soit avec `xyzzy`."

#: Game.Levels.Power.L10FLT
msgid ""
"For all naturals $a$ $b$ $c$ and $n$, we have\n"
"$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$"
msgstr ""
"Pour tous les naturels $a$ $b$ $c$ et $n$, nous avons\n"
"$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$"

#: Game.Levels.Power.L10FLT
msgid ""
"Congratulations! You have proved Fermat's Last Theorem!\n"
"\n"
"Either that, or you used magic..."
msgstr ""
"F√©licitations ! Vous avez prouv√© le dernier th√©or√®me de Fermat !\n"
"\n"
"Soit cela, soit vous avez utilis√© de la magie..."

#: Game.Levels.Power
msgid "Power World"
msgstr "Monde des Puissances"

#: Game.Levels.Power
msgid ""
"This world introduces exponentiation. If you want to define `37 ^ n`\n"
"then, as always, you will need to know what `37 ^ 0` is, and\n"
"what `37 ^ (succ d)` is, given only `37 ^ d`.\n"
"\n"
"You can probably guess the names of the general theorems:\n"
"\n"
"  * `pow_zero (a : ‚Ñï) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : ‚Ñï) : a ^ succ b = a ^ b * a`\n"
"\n"
"Using only these, can you get past the final boss level?\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship\n"
"in the summer of 2019. Thanks to Sian and also thanks to Imperial\n"
"College for funding her."
msgstr ""
"Ce monde introduit l'exponentiation. Si vous voulez d√©finir `37 ^ n`\n"
"alors, comme toujours, vous devrez savoir ce que vaut `37 ^ 0`, et\n"
"ce que vaut `37 ^ (succ d)`, sachant seulement `37 ^ d`.\n"
"\n"
"Vous pouvez probablement deviner les noms des th√©or√®mes g√©n√©raux :\n"
"\n"
"  * `pow_zero (a : ‚Ñï) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : ‚Ñï) : a ^ succ b = a ^ b * a`\n"
"\n"
"En utilisant uniquement ceux-ci, pourrez-vous passer le niveau boss final ?\n"
"\n"
"Les niveaux de ce monde ont √©t√© con√ßus par Sian Carey, une √©tudiante UROP\n"
"√† l'Imperial College de Londres, financ√©e par une bourse Mary Lister McCammon\n"
"durant l'√©t√© 2019. Merci √† Sian et √©galement √† Imperial\n"
"College pour l'avoir financ√©e."

#: Game.Levels.Implication.L01exact
msgid "The `exact` tactic"
msgstr "La tactique `exact`"

#: Game.Levels.Implication.L01exact
msgid ""
"## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x = 37` and you have a hypothesis `h : x = 37`\n"
"then `exact h` will solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x + 0 = x` then `exact add_zero x` will close the goal.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"Note that `exact add_zero` will *not work* in the previous example;\n"
"for `exact h` to work, `h` has to be *exactly* a proof of the goal.\n"
"`add_zero` is a proof of `‚àÄ n, n + 0 = n` or, if you like,\n"
"a proof of `? + 0 = ?` where `?` needs to be supplied by the user.\n"
"This is in contrast to `rw` and `apply`, which will \\\"guess the inputs\\\"\n"
"if necessary. If the goal is `x + 0 = x` then `rw [add_zero]`\n"
"and `rw [add_zero x]` will both change the goal to `x = x`,\n"
"because `rw` guesses the input to the function `add_zero`."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si le but est un √©nonc√© `P`, alors `exact h` fermera le but si `h` est une preuve de `P`.\n"
"\n"
"### Exemple\n"
"\n"
"Si le but est `x = 37` et que vous avez une hypoth√®se `h : x = 37`\n"
"alors `exact h` r√©soudra le but.\n"
"\n"
"### Exemple\n"
"\n"
"Si le but est `x + 0 = x` alors `exact add_zero x` fermera le but.\n"
"\n"
"### Exact doit √™tre exactement juste\n"
"\n"
"Notez que `exact add_zero` ne *fonctionnera pas* dans l'exemple pr√©c√©dent ;\n"
"pour que `exact h` fonctionne, `h` doit √™tre *exactement* une preuve du but.\n"
"`add_zero` est une preuve de `‚àÄ n, n + 0 = n` ou, si vous pr√©f√©rez,\n"
"une preuve de `? + 0 = ?` o√π `?` doit √™tre fourni par l'utilisateur.\n"
"Cela contraste avec `rw` et `apply`, qui \"devineront les entr√©es\"\n"
"si n√©cessaire. Si le but est `x + 0 = x` alors `rw [add_zero]`\n"
"et `rw [add_zero x]` changeront tous deux le but en `x = x`,\n"
"car `rw` devine l'entr√©e de la fonction `add_zero`."

#: Game.Levels.Implication.L01exact Game.Levels.LessOrEqual.L01le_refl
msgid ""
"In this world we'll learn how to prove theorems of the form $P\\implies Q$.\n"
"In other words, how to prove theorems of the form \"if $P$ is true, then $Q$ is true.\"\n"
"To do that we need to learn some more tactics.\n"
"\n"
"The `exact` tactic can be used to close a goal which is exactly one of\n"
"the hypotheses. It takes the name of the hypothesis as argument: `exact h`."
msgstr ""
"Dans ce monde, nous apprendrons √† prouver des th√©or√®mes de la forme $P\\implies Q$.\n"
"Autrement dit, comment prouver des th√©or√®mes de la forme \"si $P$ est vrai, alors $Q$ est vrai\".\n"
"Pour cela, nous devons apprendre d'autres tactiques.\n"
"\n"
"La tactique `exact` peut √™tre utilis√©e pour obtenir un but qui est exactement l'une\n"
"des hypoth√®ses. Elle prend le nom de l'hypoth√®se comme argument : `exact h`."

#: Game.Levels.Implication.L01exact
msgid "Assuming $x+y=37$ and $3x+z=42$, we have $x+y=37$."
msgstr "En supposant $x+y=37$ et $3x+z=42$, nous avons $x+y=37$."

#: Game.Levels.Implication.L01exact
msgid "The goal in this level is one of our hypotheses. Solve the goal by executing `exact h1`."
msgstr "Le but dans ce niveau est l'une de nos hypoth√®ses. R√©solvez le but en ex√©cutant `exact h1`."

#: Game.Levels.Implication.L02exact2
msgid "`exact` practice."
msgstr "Pratique de `exact`."

#: Game.Levels.Implication.L02exact2
msgid ""
"If the goal is not *exactly* a hypothesis, we can sometimes\n"
"use rewrites to fix things up."
msgstr ""
"Si le but n'est pas *exactement* une hypoth√®se, nous pouvons parfois\n"
"utiliser des r√©√©critures pour arranger les choses."

#: Game.Levels.Implication.L02exact2
msgid "Assuming $0+x=(0+y)+2$, we have $x=y+2$."
msgstr "En supposant $0+x=(0+y)+2$, nous avons $x=y+2$."

#: Game.Levels.Implication.L02exact2
msgid ""
"You can use `rw [zero_add] at ¬´{h}¬ª` to rewrite at `¬´{h}¬ª` instead\n"
"of at the goal."
msgstr ""
"Vous pouvez utiliser `rw [zero_add] at ¬´{h}¬ª` pour r√©√©crire dans `¬´{h}¬ª` au lieu\n"
"du but."

#: Game.Levels.Implication.L02exact2
msgid ""
"Do that again!\n"
"\n"
"`rw [zero_add] at ¬´{h}¬ª` tries to fill in\n"
"the arguments to `zero_add` (finding `¬´{x}¬ª`) then it replaces all occurences of\n"
"`0 + ¬´{x}¬ª` it finds. Therefor, it did not rewrite `0 + ¬´{y}¬ª`, yet."
msgstr ""
"Faites-le encore !\n"
"\n"
"`rw [zero_add] at ¬´{h}¬ª` essaie de remplir\n"
"les arguments de `zero_add` (trouvant `¬´{x}¬ª`) puis remplace toutes les occurrences de\n"
"`0 + ¬´{x}¬ª` qu'il trouve. Par cons√©quent, il n'a pas r√©√©crit `0 + ¬´{y}¬ª` pour l'instant."

#: Game.Levels.Implication.L02exact2
msgid ""
"Now you could finish with `rw [¬´{h}¬ª]` then `rfl`, but `exact ¬´{h}¬ª`\n"
"does it in one line."
msgstr ""
"Maintenant, vous pourriez terminer avec `rw [¬´{h}¬ª]` puis `rfl`, mais `exact ¬´{h}¬ª`\n"
"le fait en une ligne."

#: Game.Levels.Implication.L02exact2
msgid ""
"Here's a two-line proof:\n"
"```\n"
"repeat rw [zero_add] at h\n"
"exact h\n"
"```"
msgstr ""
"Voici une preuve en deux lignes :\n"
"```\n"
"repeat rw [zero_add] at h\n"
"exact h\n"
"```"

#: Game.Levels.Implication.L03apply
msgid "The `apply` tactic."
msgstr "La tactique `apply`."

#: Game.Levels.Implication.L03apply
msgid ""
"## Summary\n"
"\n"
"If `t : P ‚Üí Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y ‚Üí x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si `t : P ‚Üí Q` est une preuve que $P \\implies Q$, et `h : P` est une preuve de `P`,\n"
"alors `apply t at h` changera `h` en une preuve de `Q`. L'id√©e est que si\n"
"vous savez que `P` est vrai, alors vous pouvez d√©duire de `t` que `Q` est vrai.\n"
"\n"
"Si le *but* est `Q`, alors `apply t` \"argumentera √† l'envers\" et changera le\n"
"but en `P`. L'id√©e ici est que si vous voulez prouver `Q`, alors par `t`\n"
"il suffit de prouver `P`, donc vous pouvez r√©duire le but √† prouver `P`.\n"
"\n"
"### Exemple :\n"
"\n"
"`succ_inj x y` est une preuve que `succ x = succ y ‚Üí x = y`.\n"
"\n"
"Ainsi, si vous avez une hypoth√®se `h : succ (a + 37) = succ (b + 42)`\n"
"alors `apply succ_inj at h` changera `h` en `a + 37 = b + 42`.\n"
"Vous pourriez √©crire `apply succ_inj (a + 37) (b + 42) at h`\n"
"mais Lean est assez intelligent pour trouver les entr√©es de `succ_inj`.\n"
"\n"
"### Exemple\n"
"\n"
"Si le but est `a * b = 7`, alors `apply succ_inj` transformera le\n"
"but en `succ (a * b) = succ 7`."

#: Game.Levels.Implication.L03apply
msgid ""
"In this level, the hypotheses `h2` is an *implication*. It says\n"
"that *if* `x = 37` *then* `y = 42`. We can use this\n"
"hypothesis with the `apply` tactic. Remember you can click on\n"
"`apply` or any other tactic on the right to see a detailed explanation\n"
"of what it does, with examples."
msgstr ""
"Dans ce niveau, l'hypoth√®se `h2` est une *implication*. Elle dit\n"
"que *si* `x = 37` *alors* `y = 42`. Nous pouvons utiliser cette\n"
"hypoth√®se avec la tactique `apply`. Rappelez-vous que vous pouvez cliquer sur\n"
"`apply` ou toute autre tactique √† droite pour voir une explication d√©taill√©e\n"
"de ce qu'elle fait, avec des exemples."

#: Game.Levels.Implication.L03apply
msgid "If $x=37$ and we know that $x=37\\implies y=42$ then we can deduce $y=42$."
msgstr "Si $x=37$ et que nous savons que $x=37\\implies y=42$ alors nous pouvons d√©duire $y=42$."

#: Game.Levels.Implication.L03apply
msgid "Start with `apply h2 at h1`. This will change `h1` to `y = 42`."
msgstr "Commencez par `apply h2 at h1`. Cela changera `h1` en `y = 42`."

#: Game.Levels.Implication.L03apply
msgid "Now finish using the `exact` tactic."
msgstr "Terminez maintenant en utilisant la tactique `exact`."

#: Game.Levels.Implication.L04succ_inj
msgid "succ_inj : the successor function is injective"
msgstr "succ_inj : la fonction successeur est injective"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"If `a` and `b` are numbers, then `succ_inj a b` is a proof\n"
"that `succ a = succ b` implies `a = b`. Click on this theorem in the *Peano*\n"
"tab for more information.\n"
"\n"
"Peano had this theorem as an axiom, but in Algorithm World\n"
"we will show how to prove it in Lean. Right now let's just assume it,\n"
"and let's prove $x+1=4 \\implies x=3$ using it. Again, we will proceed\n"
"by manipulating our hypothesis until it becomes the goal. I will\n"
"walk you through this level."
msgstr ""
"Si `a` et `b` sont des nombres, alors `succ_inj a b` est une preuve\n"
"que `succ a = succ b` implique `a = b`. Cliquez sur ce th√©or√®me dans l'onglet *Peano*\n"
"pour plus d'informations.\n"
"\n"
"Peano avait ce th√©or√®me comme axiome, mais dans le monde Algorithmique\n"
"nous montrerons comment le prouver dans Lean. Pour l'instant, supposons-le simplement,\n"
"et prouvons $x+1=4 \\implies x=3$ en l'utilisant. Encore une fois, nous proc√©derons\n"
"en manipulant notre hypoth√®se jusqu'√† ce qu'elle devienne le but. Je vais\n"
"vous guider √† travers ce niveau."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"# Statement\n"
"\n"
"If $a$ and $b$ are numbers, then\n"
"`succ_inj a b` is the proof that\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"## More technical details\n"
"\n"
"There are other ways to think about `succ_inj`.\n"
"\n"
"You can think about `succ_inj` itself as a function which takes two\n"
"numbers $$a$$ and $$b$$ as input, and outputs a proof of\n"
"$ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"You can think of `succ_inj` itself as a proof; it is the proof\n"
"that `succ` is an injective function. In other words,\n"
"`succ_inj` is a proof of\n"
"$\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies "
"a=b$.\n"
"\n"
"`succ_inj` was postulated as an axiom by Peano, but\n"
"in Lean it can be proved using `pred`, a mathematically\n"
"pathological function."
msgstr ""
"# √ânonc√©\n"
"\n"
"Si $a$ et $b$ sont des nombres, alors\n"
"`succ_inj a b` est la preuve que\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"## Plus de d√©tails techniques\n"
"\n"
"Il y a d'autres fa√ßons de penser √† `succ_inj`.\n"
"\n"
"Vous pouvez consid√©rer `succ_inj` comme une fonction qui prend deux\n"
"nombres $$a$$ et $$b$$ en entr√©e, et produit une preuve de\n"
"$ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"Vous pouvez aussi consid√©rer `succ_inj` comme une preuve ; c'est la preuve\n"
"que `succ` est une fonction injective. Autrement dit,\n"
"`succ_inj` est une preuve de\n"
"$\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies "
"a=b$.\n"
"\n"
"`succ_inj` a √©t√© postul√© comme axiome par Peano, mais\n"
"dans Lean, il peut √™tre prouv√© en utilisant `pred`, une fonction\n"
"math√©matiquement pathologique."

#: Game.Levels.Implication.L04succ_inj Game.Levels.Implication.L05succ_inj2
msgid "If $x+1=4$ then $x=3$."
msgstr "Si $x+1=4$ alors $x=3$."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Let's first get `h` into the form `succ x = succ 3` so we can\n"
"apply `succ_inj`. First execute `rw [four_eq_succ_three] at h`\n"
"to change the 4 on the right hand side."
msgstr ""
"Commen√ßons par mettre `h` sous la forme `succ x = succ 3` pour que nous puissions\n"
"appliquer `succ_inj`. Ex√©cutez d'abord `rw [four_eq_succ_three] at h`\n"
"pour changer le 4 du c√¥t√© droit."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Now rewrite `succ_eq_add_one` backwards at `h`\n"
"to get the right hand side."
msgstr ""
"Maintenant, r√©√©crivez `succ_eq_add_one` √† l'envers dans `h`\n"
"pour obtenir le c√¥t√© droit."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"You can put a `‚Üê` in front of any theorem provided to `rw` to rewrite\n"
"the other way around. Look at the docs for `rw` for an explanation. Type `‚Üê` with `\\l`."
msgstr ""
"Vous pouvez mettre un `‚Üê` devant n'importe quel th√©or√®me fourni √† `rw` pour r√©√©crire\n"
"dans l'autre sens. Consultez la documentation de `rw` pour une explication. Tapez `‚Üê` avec `\\l`."

#: Game.Levels.Implication.L04succ_inj
msgid "Concretely: `rw [‚Üê succ_eq_add_one] at h`."
msgstr "Concr√®tement : `rw [‚Üê succ_eq_add_one] at h`."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Now let's `apply` our new theorem. Execute `apply succ_inj at h`\n"
"to change `h` to a proof of `x = 3`."
msgstr ""
"Maintenant, appliquons notre nouveau th√©or√®me. Ex√©cutez `apply succ_inj at h`\n"
"pour changer `h` en une preuve de `x = 3`."

#: Game.Levels.Implication.L04succ_inj
msgid "Now finish in one line."
msgstr "Terminez maintenant en une ligne."

#: Game.Levels.Implication.L04succ_inj
msgid ""
"And now we've deduced what we wanted to prove: the goal is one of our assumptions.\n"
"Finish the level with `exact h`."
msgstr ""
"Et maintenant nous avons d√©duit ce que nous voulions prouver : le but est une de nos hypoth√®ses.\n"
"Terminez le niveau avec `exact h`."

#: Game.Levels.Implication.L04succ_inj
msgid "In the next level, we'll do the same proof but backwards."
msgstr "Dans le niveau suivant, nous ferons la m√™me preuve mais √† l'envers."

#: Game.Levels.Implication.L05succ_inj2
msgid "Arguing backwards"
msgstr "Argumenter √† l'envers"

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"In the last level, we manipulated the hypothesis `x + 1 = 4`\n"
"  until it became the goal `x = 3`. In this level we'll manipulate\n"
"  the goal until it becomes our hypothesis! In other words, we\n"
"  will \"argue backwards\". The `apply` tactic can do this too.\n"
"  Again I will walk you through this one (assuming you're in\n"
"  command line mode)."
msgstr ""
"Dans le dernier niveau, nous avons manipul√© l'hypoth√®se `x + 1 = 4`\n"
"  jusqu'√† ce qu'elle devienne le but `x = 3`. Dans ce niveau, nous manipulerons\n"
"  le but jusqu'√† ce qu'il devienne notre hypoth√®se ! Autrement dit, nous\n"
"  \"argumenterons √† l'envers\". La tactique `apply` peut aussi faire cela.\n"
"  Je vais encore vous guider √† travers celui-ci (en supposant que vous √™tes en\n"
"  mode ligne de commande)."

#: Game.Levels.Implication.L05succ_inj2
msgid "Start with `apply succ_inj` to apply `succ_inj` to the *goal*."
msgstr "Commencez par `apply succ_inj` pour appliquer `succ_inj` au *but*."

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Applying a proof of $P\\implies Q$ to the *goal* changes $Q$ to $P$.\n"
"Now try `rw [succ_eq_add_one]` to make the goal more like the hypothesis."
msgstr ""
"Appliquer une preuve de $P\\implies Q$ au *but* change $Q$ en $P$.\n"
"Essayez maintenant `rw [succ_eq_add_one]` pour rendre le but plus semblable √† l'hypoth√®se."

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Now rewrite `four_eq_succ_three` backwards to make the goal\n"
"equal to the hypothesis."
msgstr ""
"Maintenant, r√©√©crivez `four_eq_succ_three` √† l'envers pour rendre le but\n"
"√©gal √† l'hypoth√®se."

#: Game.Levels.Implication.L05succ_inj2
msgid "You can now finish with `exact h`."
msgstr "Vous pouvez maintenant terminer avec `exact h`."

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Many people find `apply t at h` easy, but some find `apply t` confusing.\n"
"If you find it confusing, then just argue forwards.\n"
"\n"
"You can read more about the `apply` tactic in its documentation, which you can view by\n"
"clicking on the tactic in the list on the right."
msgstr ""
"Beaucoup de gens trouvent `apply t at h` facile, mais certains trouvent `apply t` confus.\n"
"Si vous le trouvez confus, argumentez simplement en avant.\n"
"\n"
"Vous pouvez en savoir plus sur la tactique `apply` dans sa documentation, que vous pouvez voir en\n"
"cliquant sur la tactique dans la liste √† droite."

#: Game.Levels.Implication.L06intro
msgid "intro"
msgstr "intro"

#: Game.Levels.Implication.L06intro
msgid ""
"## Summary\n"
"\n"
"If the goal is `P ‚Üí Q`, then `intro h` will introduce `h : P` as a hypothesis,\n"
"and change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\n"
"we can assume $P$ and then prove $Q$.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is `x + 1 = y + 1 ‚Üí x = y` (the way Lean writes $x+1=y+1 \\implies x=y$)\n"
"then `intro h` will give you a hypothesis $x+1=y+1$ named `h`, and the goal\n"
"will change to $x=y$."
msgstr ""
"## R√©sum√©\n"
"\n"
"Si le but est `P ‚Üí Q`, alors `intro h` introduira `h : P` comme hypoth√®se,\n"
"et changera le but en `Q`. Math√©matiquement, cela signifie que pour prouver $P \\implies Q$,\n"
"nous pouvons supposer $P$ et ensuite prouver $Q$.\n"
"\n"
"### Exemple :\n"
"\n"
"Si votre but est `x + 1 = y + 1 ‚Üí x = y` (la fa√ßon dont Lean √©crit $x+1=y+1 \\implies x=y$)\n"
"alors `intro h` vous donnera une hypoth√®se $x+1=y+1$ nomm√©e `h`, et le but\n"
"changera en $x=y$."

#: Game.Levels.Implication.L06intro
msgid ""
"We have seen how to `apply` theorems and assumptions\n"
"of the form `P ‚Üí Q`. But what if our *goal* is of the form `P ‚Üí Q`?\n"
"To prove this goal, we need to know how to say \"let's assume `P` and deduce `Q`\"\n"
"in Lean. We do this with the `intro` tactic."
msgstr ""
"Nous avons vu comment utilsier `apply` sur des th√©or√®mes et des hypoth√®ses\n"
"de la forme `P ‚Üí Q`. Mais que faire si notre *but* est de la forme `P ‚Üí Q` ?\n"
"Pour prouver ce but, nous devons savoir dire \"supposons `P` et d√©duisons `Q`\"\n"
"dans Lean. Nous faisons cela avec la tactique `intro`."

#: Game.Levels.Implication.L06intro
msgid "$x=37\\implies x=37$."
msgstr "$x=37\\implies x=37$."

#: Game.Levels.Implication.L06intro
msgid "Start with `intro h` to assume the hypothesis and call its proof `h`."
msgstr "Commencez par `intro h` pour supposer l'hypoth√®se et appeler sa preuve `h`."

#: Game.Levels.Implication.L06intro
msgid "Now `exact h` finishes the job."
msgstr "Maintenant `exact h` termine le travail."

#: Game.Levels.Implication.L07intro2
msgid "intro practice"
msgstr "pratique de intro"

#: Game.Levels.Implication.L07intro2
msgid ""
"Let's see if you can use the tactics we've learnt to prove $x+1=y+1\\implies x=y$.\n"
"Try this one by yourself; if you need help then click on \"Show more help!\"."
msgstr ""
"Voyons si vous pouvez utiliser les tactiques que nous avons apprises pour prouver "
"$x+1=y+1\\implies x=y$.\n"
"Essayez par vous-m√™me ; si vous avez besoin d'aide, cliquez sur \"Afficher plus d'aide !\"."

#: Game.Levels.Implication.L07intro2
msgid "$x+1=y+1 \\implies x=y$."
msgstr "$x+1=y+1 \\implies x=y$."

#: Game.Levels.Implication.L07intro2
msgid "Start with `intro h` to assume the hypothesis."
msgstr "Commencez par `intro h` pour supposer l'hypoth√®se."

#: Game.Levels.Implication.L07intro2
msgid ""
"Now `repeat rw [‚Üê succ_eq_add_one] at h` is the quickest way to\n"
"change `h` to `succ x = succ y`."
msgstr ""
"Maintenant `repeat rw [‚Üê succ_eq_add_one] at h` est le moyen le plus rapide de\n"
"changer `h` en `succ x = succ y`."

#: Game.Levels.Implication.L07intro2
msgid "Now `apply succ_inj at h` to cancel the `succ`s."
msgstr "Maintenant `apply succ_inj at h` pour annuler les `succ`."

#: Game.Levels.Implication.L07intro2
msgid "Now `rw [h]` then `rfl` works, but `exact h` is quicker."
msgstr "Maintenant `rw [h]` puis `rfl` fonctionne, mais `exact h` est plus rapide."

#: Game.Levels.Implication.L07intro2
msgid ""
"Here's a completely backwards proof:\n"
"```\n"
"intro h\n"
"apply succ_inj\n"
"repeat rw [succ_eq_add_one]\n"
"exact h\n"
"```"
msgstr ""
"Voici une preuve compl√®tement √† l'envers :\n"
"```\n"
"intro h\n"
"apply succ_inj\n"
"repeat rw [succ_eq_add_one]\n"
"exact h\n"
"```"

#: Game.Levels.Implication.L08ne
msgid "‚â†"
msgstr "‚â†"

#: Game.Levels.Implication.L08ne
msgid ""
"We still can't prove `2 + 2 ‚â† 5` because we have not talked about the\n"
"definition of `‚â†`. In Lean, `a ‚â† b` is *notation* for `a = b ‚Üí False`.\n"
"Here `False` is a generic false proposition, and `‚Üí` is Lean's notation\n"
"for \"implies\". In logic we learn\n"
"that `True ‚Üí False` is false, but `False ‚Üí False` is true. Hence\n"
"`X ‚Üí False` is the logical opposite of `X`.\n"
"\n"
"Even though `a ‚â† b` does not look like an implication,\n"
"you should treat it as an implication. The next two levels will show you how.\n"
"\n"
"`False` is a goal which you cannot deduce from a consistent set of assumptions!\n"
"So if your goal is `False` then you had better hope that your hypotheses\n"
"are contradictory, which they are in this level."
msgstr ""
"Nous ne pouvons toujours pas prouver `2 + 2 ‚â† 5` car nous n'avons pas parl√© de la\n"
"d√©finition de `‚â†`. Dans Lean, `a ‚â† b` est une *notation* pour `a = b ‚Üí False`.\n"
"Ici `False` est une proposition fausse g√©n√©rique, et `‚Üí` est la notation de Lean\n"
"pour \"implique\". En logique, nous apprenons\n"
"que `True ‚Üí False` est faux, mais `False ‚Üí False` est vrai. Par cons√©quent,\n"
"`X ‚Üí False` est l'oppos√© logique de `X`.\n"
"\n"
"M√™me si `a ‚â† b` ne ressemble pas √† une implication,\n"
"vous devez la traiter comme telle. Les deux prochains niveaux vous montreront comment.\n"
"\n"
"`False` est un but que vous ne pouvez pas d√©duire d'un ensemble coh√©rent d'hypoth√®ses !\n"
"Donc si votre but est `False`, vous feriez mieux d'esp√©rer que vos hypoth√®ses\n"
"soient contradictoires, ce qu'elles sont dans ce niveau."

#: Game.Levels.Implication.L08ne
msgid "If $x=y$ and $x \\neq y$ then we can deduce a contradiction."
msgstr "Si $x=y$ et $x \\neq y$ alors nous pouvons d√©duire une contradiction."

#: Game.Levels.Implication.L08ne
msgid ""
"Remember that `h2` is a proof of `x = y ‚Üí False`. Try\n"
"`apply`ing `h2` either `at h1` or directly to the goal."
msgstr ""
"Rappelez-vous que `h2` est une preuve de `x = y ‚Üí False`. Essayez\n"
"avec `apply` `h2` avec en plus `at h1` ou bien directement au but."

#: Game.Levels.Implication.L08ne
msgid ""
"`a ‚â† b` is *notation* for `(a = b) ‚Üí False`.\n"
"\n"
"The reason this is mathematically\n"
"valid is that if `P` is a true-false statement then `P ‚Üí False`\n"
"is the logical opposite of `P`. Indeed `True ‚Üí False` is false,\n"
"and `False ‚Üí False` is true!\n"
"\n"
"The upshot of this is that you can treat `a ‚â† b` in exactly\n"
"the same way as you treat any implication `P ‚Üí Q`. For example,\n"
"if your *goal* is of the form `a ‚â† b` then you can make progress\n"
"with `intro h`, and if you have a hypothesis `h` of the\n"
"form `a ‚â† b` then you can `apply h at h1` if `h1` is a proof\n"
"of `a = b`."
msgstr ""
"`a ‚â† b` est une *notation* pour `(a = b) ‚Üí False`.\n"
"\n"
"La raison pour laquelle c'est math√©matiquement\n"
"valide est que si `P` est un √©nonc√© vrai-faux alors `P ‚Üí False`\n"
"est l'oppos√© logique de `P`. En effet `True ‚Üí False` est faux,\n"
"et `False ‚Üí False` est vrai !\n"
"\n"
"La cons√©quence est que vous pouvez traiter `a ‚â† b` exactement\n"
"de la m√™me mani√®re que toute implication `P ‚Üí Q`. Par exemple,\n"
"si votre *but* est de la forme `a ‚â† b` alors vous pouvez avancer\n"
"avec `intro h`, et si vous avez une hypoth√®se `h` de la\n"
"forme `a ‚â† b` alors vous pouvez utiliser `apply h at h1` si `h1` est une preuve\n"
"de `a = b`."

#: Game.Levels.Implication.L08ne
msgid "Remember, `x ‚â† y` is *notation* for `x = y ‚Üí False`."
msgstr "Rappelez-vous, `x ‚â† y` est une *notation* pour `x = y ‚Üí False`."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "zero_ne_succ"
msgstr "zero_ne_succ"

#: Game.Levels.Implication.L09zero_ne_succ
msgid ""
"`zero_ne_succ n` is the proof that `0 ‚â† succ n`.\n"
"\n"
"In Lean, `a ‚â† b` is *defined to mean* `a = b ‚Üí False`. Hence\n"
"`zero_ne_succ n` is really a proof of `0 = succ n ‚Üí False`.\n"
"Here `False` is a generic false statement. This means that\n"
"you can `apply zero_ne_succ at h` if `h` is a proof of `0 = succ n`."
msgstr ""
"`zero_ne_succ n` est la preuve que `0 ‚â† succ n`.\n"
"\n"
"Dans Lean, `a ‚â† b` est *d√©fini comme signifiant* `a = b ‚Üí False`. Par cons√©quent\n"
"`zero_ne_succ n` est en r√©alit√© une preuve de `0 = succ n ‚Üí False`.\n"
"Ici `False` est un √©nonc√© faux g√©n√©rique. Cela signifie que\n"
"vous pouvez `apply zero_ne_succ at h` si `h` est une preuve de `0 = succ n`."

#: Game.Levels.Implication.L09zero_ne_succ
msgid ""
"As warm-up for `2 + 2 ‚â† 5` let's prove `0 ‚â† 1`. To do this we need to\n"
"introduce Peano's last axiom `zero_ne_succ n`, a proof that `0 ‚â† succ n`.\n"
"To learn about this result, click on it in the list of lemmas on the right."
msgstr ""
"Comme √©chauffement pour `2 + 2 ‚â† 5`, prouvons `0 ‚â† 1`. Pour cela, nous devons\n"
"introduire le dernier axiome de Peano `zero_ne_succ n`, une preuve que `0 ‚â† succ n`.\n"
"Pour en savoir plus sur ce r√©sultat, cliquez dessus dans la liste des lemmes √† droite."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "`zero_ne_one` is a proof of `0 ‚â† 1`."
msgstr "`zero_ne_one` est une preuve de `0 ‚â† 1`."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "$0\\neq1$."
msgstr "$0\\neq1$."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Start with `intro h`."
msgstr "Commencez par `intro h`."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Now change `1` to `succ 0` in `h`."
msgstr "Maintenant, changez `1` en `succ 0` dans `h`."

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Now you can `apply zero_ne_succ at h`."
msgstr "Maintenant, vous pouvez utiliser `apply zero_ne_succ at h`."

#: Game.Levels.Implication.L09zero_ne_succ Game.Levels.AdvAddition.L01add_right_cancel
msgid "Nice!"
msgstr "Bien !"

#: Game.Levels.Implication.L10one_ne_zero
msgid "1 ‚â† 0"
msgstr "1 ‚â† 0"

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"We know `zero_ne_succ n` is a proof of `0 = succ n ‚Üí False` -- but what\n"
"if we have a hypothesis `succ n = 0`? It's the wrong way around!\n"
"\n"
"The `symm` tactic changes a goal `x = y` to `y = x`, and a goal `x ‚â† y`\n"
"to `y ‚â† x`. And `symm at h`\n"
"does the same for a hypothesis `h`. We've proved $0 \\neq 1$ and called\n"
"the proof `zero_ne_one`; now try proving $1 \\neq 0$."
msgstr ""
"Nous savons que `zero_ne_succ n` est une preuve de `0 = succ n ‚Üí False` -- mais que faire\n"
"si nous avons une hypoth√®se `succ n = 0` ? C'est dans le mauvais sens !\n"
"\n"
"La tactique `symm` change un but `x = y` en `y = x`, et un but `x ‚â† y`\n"
"en `y ‚â† x`. Et `symm at h`\n"
"fait la m√™me chose pour une hypoth√®se `h`. Nous avons prouv√© $0 \\neq 1$ et nous avions appel√©\n"
"la preuve `zero_ne_one` ; maintenant essayez de prouver $1 \\neq 0$."

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"## Summary\n"
"\n"
"The `symm` tactic will change a goal or hypothesis of\n"
"the form `X = Y` to `Y = X`. It will also work on `X ‚â† Y`\n"
"and on `X ‚Üî Y`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `symm` will change it to `4 = 2 + 2`.\n"
"\n"
"### Example\n"
"\n"
"If `h : 2 + 2 ‚â† 5` then `symm at h` will change `h` to `5 ‚â† 2 + 2`."
msgstr ""
"## R√©sum√©\n"
"\n"
"La tactique `symm` changera un but ou une hypoth√®se de\n"
"la forme `X = Y` en `Y = X`. Elle fonctionnera aussi sur `X ‚â† Y`\n"
"et sur `X ‚Üî Y`.\n"
"\n"
"### Exemple\n"
"\n"
"Si le but est `2 + 2 = 4` alors `symm` le changera en `4 = 2 + 2`.\n"
"\n"
"### Exemple\n"
"\n"
"Si `h : 2 + 2 ‚â† 5` alors `symm at h` changera `h` en `5 ‚â† 2 + 2`."

#: Game.Levels.Implication.L10one_ne_zero
msgid "`one_ne_zero` is a proof that `1 ‚â† 0`."
msgstr "`one_ne_zero` est une preuve que `1 ‚â† 0`."

#: Game.Levels.Implication.L10one_ne_zero
msgid "$1\\neq0$."
msgstr "$1\\neq0$."

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"What do you think of this two-liner:\n"
"```\n"
"symm\n"
"exact zero_ne_one\n"
"```\n"
"\n"
"`exact` doesn't just take hypotheses, it will eat any proof which exists\n"
"in the system."
msgstr ""
"Que pensez-vous de cette solution en deux lignes :\n"
"```\n"
"symm\n"
"exact zero_ne_one\n"
"```\n"
"\n"
"`exact` ne prend pas seulement des hypoth√®ses, il acceptera toute preuve existante\n"
"dans le syst√®me."

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "2 + 2 ‚â† 5"
msgstr "2 + 2 ‚â† 5"

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid ""
"2 + 2 ‚â† 5 is boring to prove in full, given only the tools we have currently.\n"
"To make it a bit less painful, I have unfolded all of the numerals for you.\n"
"See if you can use `zero_ne_succ` and `succ_inj` to prove this."
msgstr ""
"2 + 2 ‚â† 5 est ennuyeux √† prouver enti√®rement, avec les seuls outils dont nous disposons "
"actuellement.\n"
"Pour le rendre un peu moins p√©nible, j'ai d√©velopp√© tous les entiers pour vous.\n"
"Voyez si vous pouvez utiliser `zero_ne_succ` et `succ_inj` pour le prouver."

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "$2+2‚â†5$."
msgstr "$2+2‚â†5$."

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid ""
"Here's my proof:\n"
"```\n"
"intro h\n"
"rw [add_succ, add_succ, add_zero] at h\n"
"repeat apply succ_inj at h\n"
"apply zero_ne_succ at h\n"
"exact h\n"
"```\n"
"\n"
"Even though Lean is a theorem prover, right now it's pretty clear that we have not\n"
"developed enough material to make it an adequate calculator. In Algorithm\n"
"World, a more computer-sciency world, we will develop machinery which makes\n"
"questions like this much easier, and goals like $20 + 20 ‚â† 41$ feasible.\n"
"Alternatively you can do more mathematics in Advanced Addition World, where we prove\n"
"the lemmas needed to get a working theory of inequalities. Click \"Leave World\" and\n"
"decide your route."
msgstr ""
"Voici ma preuve :\n"
"```\n"
"intro h\n"
"rw [add_succ, add_succ, add_zero] at h\n"
"repeat apply succ_inj at h\n"
"apply zero_ne_succ at h\n"
"exact h\n"
"```\n"
"\n"
"Bien que Lean soit un prouveur de th√©or√®mes, il est clair que nous n'avons pas\n"
"d√©velopp√© suffisamment de mat√©riel pour en faire une calculatrice ad√©quate. Dans le monde "
"Algorithmique,\n"
"un monde plus informatique, nous d√©velopperons des m√©canismes qui rendent\n"
"des questions comme celle-ci beaucoup plus faciles, et des buts comme $20 + 20 ‚â† 41$ r√©alisables.\n"
"Alternativement, vous pouvez faire plus de math√©matiques dans le monde de l'Addition Avanc√©e, o√π "
"nous prouvons\n"
"les lemmes n√©cessaires pour obtenir une th√©orie op√©rationnelle des in√©galit√©s. Cliquez sur "
"\"Quitter le monde\" et\n"
"d√©cidez de votre route."

#: Game.Levels.Implication
msgid "Implication World"
msgstr "Monde de l'Implication"

#: Game.Levels.Implication
msgid ""
"We've proved that $2+2=4$; in Implication World we'll learn\n"
"how to prove $2+2\\neq 5$.\n"
"\n"
"In Addition World we proved *equalities* like $x + y = y + x$.\n"
"In this second tutorial world we'll learn some new tactics,\n"
"enabling us to prove *implications*\n"
"like $x+1=4 \\implies x=3.$\n"
"\n"
"We'll also learn two new fundamental facts about\n"
"natural numbers, which Peano introduced as axioms.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"Nous avons prouv√© que $2+2=4$ ; dans le monde de l'Implication, nous apprendrons\n"
"comment prouver $2+2\\neq 5$.\n"
"\n"
"Dans le monde de l'Addition, nous avons prouv√© des *√©galit√©s* comme $x + y = y + x$.\n"
"Dans ce deuxi√®me monde tutoriel, nous apprendrons de nouvelles tactiques,\n"
"nous permettant de prouver des *implications*\n"
"comme $x+1=4 \\implies x=3$.\n"
"\n"
"Nous apprendrons √©galement deux nouveaux faits fondamentaux sur\n"
"les nombres naturels, que Peano a introduits comme axiomes.\n"
"\n"
"Cliquez sur \"Commencer\" pour continuer."

#: Game.Levels.Algorithm.L01add_left_comm
msgid "add_left_comm"
msgstr "add_left_comm"

#: Game.Levels.Algorithm.L01add_left_comm
msgid "`add_left_comm a b c` is a proof that `a + (b + c) = b + (a + c)`."
msgstr "`add_left_comm a b c` est une preuve que `a + (b + c) = b + (a + c)`."

#: Game.Levels.Algorithm.L01add_left_comm
msgid ""
"Having to rearrange variables manually using commutativity and\n"
"associativity is very tedious. We start by reminding you of this. `add_left_comm`\n"
"is a key component in the first algorithm which we'll explain, but we need\n"
"to prove it manually.\n"
"\n"
"Remember that you can do precision commutativity rewriting\n"
"with things like `rw [add_comm b c]`. And remember that\n"
"`a + b + c` means `(a + b) + c`."
msgstr ""
"Devoir r√©arranger manuellement les variables en utilisant la commutativit√© et\n"
"l'associativit√© est tr√®s fastidieux. Nous commen√ßons par vous le rappeler. `add_left_comm`\n"
"est un composant cl√© du premier algorithme que nous expliquerons, mais nous devons\n"
"d'abord le prouver manuellement.\n"
"\n"
"Rappelez-vous que vous pouvez faire des r√©√©critures de commutativit√© pr√©cises\n"
"avec des choses comme `rw [add_comm b c]`. Et rappelez-vous que\n"
"`a + b + c` signifie `(a + b) + c`."

#: Game.Levels.Algorithm.L01add_left_comm
msgid "If $a, b, c$ are numbers, then $a+(b+c)=b+(a+c)$."
msgstr "Si $a, b, c$ sont des nombres, alors $a+(b+c)=b+(a+c)$."

#: Game.Levels.Algorithm.L02add_algo1
msgid "making life easier"
msgstr "rendre la vie plus facile"

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"In some later worlds, we're going to see some much nastier levels,\n"
"like `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`.\n"
"Brackets need to be moved around, and variables need to be swapped.\n"
"\n"
"In this level, `(a + b) + (c + d) = ((a + c) + d) + b`,\n"
"let's forget about the brackets and just think about\n"
"the variable order.\n"
"To turn `a+b+c+d` into `a+c+d+b` we need to swap `b` and `c`,\n"
"and then swap `b` and `d`. But this is easier than you\n"
"think with `add_left_comm`."
msgstr ""
"Dans certains mondes ult√©rieurs, nous verrons des niveaux bien plus d√©sagr√©ables,\n"
"comme `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`.\n"
"Les parenth√®ses doivent √™tre d√©plac√©es et les variables √©chang√©es.\n"
"\n"
"Dans ce niveau, `(a + b) + (c + d) = ((a + c) + d) + b`,\n"
"oublions les parenth√®ses et pensons simplement √†\n"
"l'ordre des variables.\n"
"Pour transformer `a+b+c+d` en `a+c+d+b`, nous devons √©changer `b` et `c`,\n"
"puis √©changer `b` et `d`. Mais c'est plus facile que vous ne le\n"
"pensez avec `add_left_comm`."

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"If $a, b$, $c$ and $d$ are numbers, we have\n"
"$(a + b) + (c + d) = ((a + c) + d) + b.$"
msgstr ""
"Si $a, b$, $c$ et $d$ sont des nombres, nous avons\n"
"$(a + b) + (c + d) = ((a + c) + d) + b.$"

#: Game.Levels.Algorithm.L02add_algo1
msgid "Start with `repeat rw [add_assoc]` to push all the brackets to the right."
msgstr "Commencez par `repeat rw [add_assoc]` pour pousser toutes les parenth√®ses vers la droite."

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"Now use `rw [add_left_comm b c]` to switch `b` and `c` on the left\n"
"hand side."
msgstr ""
"Utilisez maintenant `rw [add_left_comm b c]` pour √©changer `b` et `c` du c√¥t√©\n"
"gauche."

#: Game.Levels.Algorithm.L02add_algo1
msgid "Finally use a targetted `add_comm` to switch `b` and `d`"
msgstr "Enfin, utilisez un `add_comm` cibl√© pour √©changer `b` et `d`"

#: Game.Levels.Algorithm.L02add_algo1
msgid "`rw [add_comm b d]`."
msgstr "`rw [add_comm b d]`."

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"So that's the algorithm: now let's use automation to perform it\n"
"automatically."
msgstr ""
"Voil√† donc l'algorithme : utilisons maintenant l'automatisation pour l'ex√©cuter\n"
"automatiquement."

#: Game.Levels.Algorithm.L03add_algo2
msgid "making life simple"
msgstr "rendre la vie simple"

#: Game.Levels.Algorithm.L03add_algo2
msgid ""
"# Overview\n"
"\n"
"Lean's simplifier, `simp`, will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"Furthermore, it will attempt to order variables into an internal order if fed\n"
"lemmas such as `add_comm`, so that it does not go into an infinite loop."
msgstr ""
"# Aper√ßu\n"
"\n"
"Le simplificateur de Lean, `simp`, r√©√©crira chaque lemme\n"
"marqu√© `simp` et chaque lemme fourni par l'utilisateur, autant que possible.\n"
"De plus, il tentera d'ordonner les variables dans un ordre interne si on lui donne\n"
"des lemmes comme `add_comm`, afin de ne pas tomber dans une boucle infinie."

#: Game.Levels.Algorithm.L03add_algo2
msgid ""
"Lean's simplifier, `simp`, is \"`rw` on steroids\". It will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"\n"
"This level is not a level which you want to solve by hand.\n"
"Get the simplifier to solve it for you."
msgstr ""
"Le simplificateur de Lean, `simp`, est \"`rw` sous st√©ro√Ødes\". Il r√©√©crira chaque lemme\n"
"marqu√© `simp` et chaque lemme fourni par l'utilisateur, autant que possible.\n"
"\n"
"Ce n'est pas un niveau que vous voulez r√©soudre √† la main.\n"
"Demandez au simplificateur de le r√©soudre pour vous."

#: Game.Levels.Algorithm.L03add_algo2 Game.Levels.Algorithm.L04add_algo3
msgid ""
"If $a, b,\\ldots h$ are arbitrary natural numbers, we have\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$."
msgstr ""
"Si $a, b,\\ldots h$ sont des nombres naturels arbitraires, nous avons\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$."

#: Game.Levels.Algorithm.L03add_algo2
msgid "Solve this level in one line with `simp only [add_assoc, add_left_comm, add_comm]`"
msgstr "R√©solvez ce niveau en une ligne avec `simp only [add_assoc, add_left_comm, add_comm]`"

#: Game.Levels.Algorithm.L03add_algo2
msgid "Let's now make our own tactic to do this."
msgstr "Cr√©ons maintenant notre propre tactique pour faire cela."

#: Game.Levels.Algorithm.L04add_algo3
msgid "the simplest approach"
msgstr "l'approche la plus simple"

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"# Overview\n"
"\n"
"Our home-made tactic `simp_add` will solve arbitrary goals of\n"
"the form `a + (b + c) + (d + e) = e + (d + (c + b)) + a`."
msgstr ""
"# Aper√ßu\n"
"\n"
"Notre tactique maison `simp_add` r√©soudra tout but de\n"
"la forme `a + (b + c) + (d + e) = e + (d + (c + b)) + a`."

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"You can make your own tactics in Lean.\n"
"This code here\n"
"```\n"
"macro \"simp_add\" : tactic => `(tactic|(\n"
"  simp only [add_assoc, add_left_comm, add_comm]))\n"
"```\n"
"was used to create a new tactic `simp_add`, which runs\n"
"`simp only [add_assoc, add_left_comm, add_comm]`.\n"
"Try running `simp_add` to solve this level!"
msgstr ""
"Vous pouvez cr√©er vos propres tactiques dans Lean.\n"
"Ce code ci-dessous\n"
"```\n"
"macro \"simp_add\" : tactic => `(tactic|(\n"
"  simp only [add_assoc, add_left_comm, add_comm]))\n"
"```\n"
"a √©t√© utilis√© pour cr√©er une nouvelle tactique `simp_add`, qui ex√©cute\n"
"`simp only [add_assoc, add_left_comm, add_comm]`.\n"
"Essayez d'ex√©cuter `simp_add` pour r√©soudre ce niveau !"

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"Let's now move on to a more efficient approach to questions\n"
"involving numerals, such as `20 + 20 = 40`."
msgstr ""
"Passons maintenant √† une approche plus efficace pour les questions\n"
"impliquant des nombres, comme `20 + 20 = 40`."

#: Game.Levels.Algorithm.L05pred
msgid "pred"
msgstr "pred"

#: Game.Levels.Algorithm.L05pred
msgid ""
"We now start work on an algorithm to do addition more efficiently. Recall that\n"
"we defined addition by recursion, saying what it did on `0` and successors.\n"
"It is an axiom of Lean that recursion is a valid\n"
"way to define functions from types such as the naturals.\n"
"\n"
"Let's define a new function `pred` from the naturals to the naturals, which\n"
"attempts to subtract 1 from the input. The definition is this:\n"
"\n"
"```\n"
"pred 0 := 37\n"
"pred (succ n) := n\n"
"```\n"
"\n"
"We cannot subtract one from 0, so we just return a junk value. As well as this\n"
"definition, we also create a new lemma `pred_succ`, which says that `pred (succ n) = n`.\n"
"Let's use this lemma to prove `succ_inj`, the theorem which\n"
"Peano assumed as an axiom and which we have already used extensively without justification."
msgstr ""
"Nous commen√ßons maintenant √† travailler sur un algorithme pour faire l'addition plus efficacement. "
"Rappelons que\n"
"nous avons d√©fini l'addition par une formule de r√©currence, en disant ce qu'elle fait sur `0` et "
"les successeurs.\n"
"C'est un axiome de Lean que la r√©cursion est une mani√®re valide\n"
"de d√©finir des fonctions √† partir de types comme les naturels.\n"
"\n"
"D√©finissons une nouvelle fonction `pred` des naturels vers les naturels, qui\n"
"tente de soustraire 1 de l'entr√©e. La d√©finition est :\n"
"\n"
"```\n"
"pred 0 := 37\n"
"pred (succ n) := n\n"
"```\n"
"\n"
"Nous ne pouvons pas soustraire un de 0, donc nous renvoyons simplement une valeur quelconque. En "
"plus de cette\n"
"d√©finition, nous cr√©ons √©galement un nouveau lemme `pred_succ`, qui dit que `pred (succ n) = n`.\n"
"Utilisons ce lemme pour prouver `succ_inj`, le th√©or√®me que\n"
"Peano a suppos√© comme axiome et que nous avons d√©j√† largement utilis√© sans justification."

#: Game.Levels.Algorithm.L05pred
msgid "`pred_succ n` is a proof of `pred (succ n) = n`."
msgstr "`pred_succ n` est une preuve de `pred (succ n) = n`."

#: Game.Levels.Algorithm.L05pred
msgid "If $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ then $a=b$."
msgstr "Si $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ alors $a=b$."

#: Game.Levels.Algorithm.L05pred
msgid "Start with `rw [‚Üê pred_succ a]` and take it from there."
msgstr "Commencez par `rw [‚Üê pred_succ a]` et continuez √† partir de l√†."

#: Game.Levels.Algorithm.L05pred
msgid ""
"Nice! You've proved `succ_inj`!\n"
"Let's now prove Peano's other axiom, that successors can't be $0$."
msgstr ""
"Bien ! Vous avez prouv√© `succ_inj` !\n"
"Prouvons maintenant l'autre axiome de Peano, que les successeurs ne peuvent pas √™tre $0$."

#: Game.Levels.Algorithm.L06is_zero
msgid "is_zero"
msgstr "is_zero"

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"We define a function `is_zero` thus:\n"
"\n"
"```\n"
"is_zero 0 := True\n"
"is_zero (succ n) := False\n"
"```\n"
"\n"
"We also create two lemmas, `is_zero_zero` and `is_zero_succ n`, saying that `is_zero 0 = True`\n"
"and `is_zero (succ n) = False`. Let's use these lemmas to prove `succ_ne_zero`, Peano's\n"
"Last Axiom. Actually, we have been using `zero_ne_succ` before, but it's handy to have\n"
"this opposite version too, which can be proved in the same way. Note: you can\n"
"cheat here by using `zero_ne_succ` but the point of this world is to show\n"
"you how to *prove* results like that.\n"
"\n"
"If you can turn your goal into `True`, then the `trivial` tactic will solve it."
msgstr ""
"Nous d√©finissons une fonction `is_zero` ainsi :\n"
"\n"
"```\n"
"is_zero 0 := True\n"
"is_zero (succ n) := False\n"
"```\n"
"\n"
"Nous cr√©ons √©galement deux lemmes, `is_zero_zero` et `is_zero_succ n`, disant que `is_zero 0 = "
"True`\n"
"et `is_zero (succ n) = False`. Utilisons ces lemmes pour prouver `succ_ne_zero`, le dernier\n"
"axiome de Peano. En fait, nous avons d√©j√† utilis√© `zero_ne_succ` auparavant, mais il est utile "
"d'avoir\n"
"cette version oppos√©e aussi, qui peut √™tre prouv√©e de la m√™me mani√®re. Note : vous pouvez\n"
"tricher ici en utilisant `zero_ne_succ` mais l'objectif de ce monde est de vous montrer\n"
"comment *prouver* des r√©sultats comme celui-ci.\n"
"\n"
"Si vous pouvez transformer votre but en `True`, alors la tactique `trivial` le r√©soudra."

#: Game.Levels.Algorithm.L06is_zero
msgid "`is_zero_zero` is a proof of `is_zero 0 = True`."
msgstr "`is_zero_zero` est une preuve de `is_zero 0 = True`."

#: Game.Levels.Algorithm.L06is_zero
msgid "`is_zero_succ a` is a proof of `is_zero (succ a) = False`."
msgstr "`is_zero_succ a` est une preuve de `is_zero (succ a) = False`."

#: Game.Levels.Algorithm.L06is_zero
msgid "`succ_ne_zero a` is a proof of `succ a ‚â† 0`."
msgstr "`succ_ne_zero a` est une preuve de `succ a ‚â† 0`."

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"# Summary\n"
"\n"
"`trivial` will solve the goal `True`."
msgstr ""
"# R√©sum√©\n"
"\n"
"`trivial` r√©soudra le but `True`."

#: Game.Levels.Algorithm.L06is_zero
msgid "$\\operatorname{succ}(a) \\neq 0$."
msgstr "$\\operatorname{succ}(a) \\neq 0$."

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"Start with `intro h` (remembering that `X ‚â† Y` is just notation\n"
"for `X = Y ‚Üí False`)."
msgstr ""
"Commencez par `intro h` (en rappelant que `X ‚â† Y` est juste une notation\n"
"pour `X = Y ‚Üí False`)."

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"We're going to change that `False` into `True`. Start by changing it into\n"
"`is_zero (succ a)` by executing `rw [‚Üê is_zero_succ a]`."
msgstr ""
"Nous allons changer ce `False` en `True`. Commencez par le changer en\n"
"`is_zero (succ a)` en ex√©cutant `rw [‚Üê is_zero_succ a]`."

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"See if you can take it from here. Look at the new lemmas and tactic\n"
"available on the right."
msgstr ""
"Voyez si vous pouvez continuer. Regardez les nouveaux lemmes et la tactique\n"
"disponibles √† droite."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "An algorithm for equality"
msgstr "Un algorithme pour l'√©galit√©"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Here we begin to\n"
"develop an algorithm which, given two naturals `a` and `b`, returns the answer\n"
"to \"does `a = b`?\"\n"
"\n"
"Here is the algorithm. First note that `a` and `b` are numbers, and hence\n"
"are either `0` or successors.\n"
"\n"
"*) If `a` and `b` are both `0`, return \"yes\".\n"
"\n"
"*) If one is `0` and the other is `succ n`, return \"no\".\n"
"\n"
"*) If `a = succ m` and `b = succ n`, then return the answer to \"does `m = n`?\"\n"
"\n"
"Our job now is to *prove* that this algorithm always gives the correct answer. The proof that\n"
"`0 = 0` is `rfl`. The proof that `0 ‚â† succ n` is `zero_ne_succ n`, and the proof\n"
"that `succ m ‚â† 0` is `succ_ne_zero m`. The proof that if `h : m = n` then\n"
"`succ m = succ n` is `rw [h]` and then `rfl`. This level is a proof of the one\n"
"remaining job we have to do: if `a ‚â† b` then `succ a ‚â† succ b`."
msgstr ""
"Ici, nous commen√ßons √†\n"
"d√©velopper un algorithme qui, √©tant donn√©s deux naturels `a` et `b`, renvoie la r√©ponse\n"
"√† \"`a = b` ?\"\n"
"\n"
"Voici l'algorithme. D'abord, notez que `a` et `b` sont des nombres, et donc\n"
"sont soit `0` soit des successeurs.\n"
"\n"
"*) Si `a` et `b` sont tous deux `0`, renvoyer \"oui\".\n"
"\n"
"*) Si l'un est `0` et l'autre est `succ n`, renvoyer \"non\".\n"
"\n"
"*) Si `a = succ m` et `b = succ n`, alors renvoyer la r√©ponse √† \"`m = n` ?\"\n"
"\n"
"Notre travail maintenant est de *prouver* que cet algorithme donne toujours la bonne r√©ponse. La "
"preuve de\n"
"`0 = 0` est `rfl`. La preuve que `0 ‚â† succ n` est `zero_ne_succ n`, et la preuve\n"
"que `succ m ‚â† 0` est `succ_ne_zero m`. La preuve que si `h : m = n` alors\n"
"`succ m = succ n` est `rw [h]` puis `rfl`. Ce niveau est une preuve de la seule\n"
"t√¢che restante que nous devons faire : si `a ‚â† b` alors `succ a ‚â† succ b`."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"# Summary\n"
"\n"
"If you have a hypothesis\n"
"\n"
"`h : a ‚â† b`\n"
"\n"
"and goal\n"
"\n"
"`c ‚â† d`\n"
"\n"
"then `contrapose! h` replaces the set-up with its so-called \\\"contrapositive\\\":\n"
"a hypothesis\n"
"\n"
"`h : c = d`\n"
"\n"
"and goal\n"
"\n"
"`a = b`."
msgstr ""
"# R√©sum√©\n"
"\n"
"Si vous avez une hypoth√®se\n"
"\n"
"`h : a ‚â† b`\n"
"\n"
"et un but\n"
"\n"
"`c ‚â† d`\n"
"\n"
"alors `contrapose! h` remplace la proposition par sa d√©nomm√©e \"contrapos√©e\" :\n"
"c'est-√†-dire une hypoth√®se\n"
"\n"
"`h : c = d`\n"
"\n"
"et un but\n"
"\n"
"`a = b`."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "`succ_ne_succ m n` is the proof that `m ‚â† n ‚Üí succ m ‚â† succ n`."
msgstr "`succ_ne_succ m n` est la preuve que `m ‚â† n ‚Üí succ m ‚â† succ n`."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "If $a \\neq b$ then $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$."
msgstr "Si $a \\neq b$ alors $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Start with `contrapose! h`, to change the goal into its\n"
"contrapositive, namely a hypothesis of `succ m = succ n` and a goal of `m = n`."
msgstr ""
"Commencez par `contrapose! h`, pour changer le but en sa\n"
"contrapos√©e, c'est-√†-dire une hypoth√®se `succ m = succ n` et un but `m = n`."

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Can you take it from here? (note: if you try `contrapose! h` again, it will\n"
"take you back to where you started!)"
msgstr ""
"Pouvez-vous continuer ? (note : si vous essayez `contrapose! h` √† nouveau, cela vous\n"
"ram√®nera √† votre point de d√©part !)"

#: Game.Levels.Algorithm.L08decide
msgid "decide"
msgstr "decide"

#: Game.Levels.Algorithm.L08decide
msgid ""
"# Summary\n"
"\n"
"`decide` will attempt to solve a goal if it can find an algorithm which it\n"
"can run to solve it.\n"
"\n"
"## Example\n"
"\n"
"A term of type `DecidableEq ‚Ñï` is an algorithm to decide whether two naturals\n"
"are equal or different. Hence, once this term is made and made into an `instance`,\n"
"the `decide` tactic can use it to solve goals of the form `a = b` or `a ‚â† b`."
msgstr ""
"# R√©sum√©\n"
"\n"
"`decide` essaiera de r√©soudre un but s'il peut trouver un algorithme qu'il\n"
"peut ex√©cuter pour le r√©soudre.\n"
"\n"
"## Exemple\n"
"\n"
"Un terme de type `DecidableEq ‚Ñï` est un algorithme pour d√©cider si deux entiers naturels\n"
"sont √©gaux ou diff√©rents. Ainsi, une fois ce terme cr√©√© et transform√© en `instance`,\n"
"la tactique `decide` peut l'utiliser pour r√©soudre des buts de la forme `a = b` ou `a ‚â† b`."

#: Game.Levels.Algorithm.L08decide
msgid ""
"Implementing the algorithm for equality of naturals, and the proof that it is correct,\n"
"looks like this:\n"
"\n"
"```\n"
"instance instDecidableEq : DecidableEq ‚Ñï\n"
"| 0, 0 => isTrue <| by\n"
"  show 0 = 0\n"
"  rfl\n"
"| succ m, 0 => isFalse <| by\n"
"  show succ m ‚â† 0\n"
"  exact succ_ne_zero m\n"
"| 0, succ n => isFalse <| by\n"
"  show 0 ‚â† succ n\n"
"  exact zero_ne_succ n\n"
"| succ m, succ n =>\n"
"  match instDecidableEq m n with\n"
"  | isTrue (h : m = n) => isTrue <| by\n"
"    show succ m = succ n\n"
"    rw [h]\n"
"    rfl\n"
"  | isFalse (h : m ‚â† n) => isFalse <| by\n"
"    show succ m ‚â† succ n\n"
"    exact succ_ne_succ m n h\n"
"```\n"
"\n"
"This Lean code is a formally verified algorithm for deciding equality\n"
"between two naturals. I've typed it in already, behind the scenes.\n"
"Because the algorithm is formally verified to be correct, we can\n"
"use it in Lean proofs. You can run the algorithm with the `decide` tactic."
msgstr ""
"L'impl√©mentation de l'algorithme pour l'√©galit√© des naturels, et la preuve qu'il est correct,\n"
"ressemble √† ceci :\n"
"\n"
"```\n"
"instance instDecidableEq : DecidableEq ‚Ñï\n"
"| 0, 0 => isTrue <| by\n"
"  show 0 = 0\n"
"  rfl\n"
"| succ m, 0 => isFalse <| by\n"
"  show succ m ‚â† 0\n"
"  exact succ_ne_zero m\n"
"| 0, succ n => isFalse <| by\n"
"  show 0 ‚â† succ n\n"
"  exact zero_ne_succ n\n"
"| succ m, succ n =>\n"
"  match instDecidableEq m n with\n"
"  | isTrue (h : m = n) => isTrue <| by\n"
"    show succ m = succ n\n"
"    rw [h]\n"
"    rfl\n"
"  | isFalse (h : m ‚â† n) => isFalse <| by\n"
"    show succ m ‚â† succ n\n"
"    exact succ_ne_succ m n h\n"
"```\n"
"\n"
"Ce code Lean est un algorithme formellement v√©rifi√© pour d√©cider de l'√©galit√©\n"
"entre deux naturels. Je l'ai d√©j√† tap√©, en coulisses.\n"
"Comme l'algorithme est formellement v√©rifi√© comme correct, nous pouvons\n"
"l'utiliser dans les preuves Lean. Vous pouvez ex√©cuter l'algorithme avec la tactique `decide`."

#: Game.Levels.Algorithm.L08decide
msgid "$20+20=40$."
msgstr "$20+20=40$."

#: Game.Levels.Algorithm.L08decide
msgid ""
"You can read more about the `decide` tactic by clicking\n"
"on it in the top right."
msgstr ""
"Vous pouvez en savoir plus sur la tactique `decide` en cliquant\n"
"dessus en haut √† droite."

#: Game.Levels.Algorithm.L09decide2
msgid "decide again"
msgstr "decide √† nouveau"

#: Game.Levels.Algorithm.L09decide2
msgid "We gave a pretty unsatisfactory proof of `2 + 2 ‚â† 5` earlier on; now give a nicer one."
msgstr ""
"Nous avons donn√© une preuve assez peu satisfaisante de `2 + 2 ‚â† 5` plus t√¥t ; maintenant donnez-en "
"une meilleure."

#: Game.Levels.Algorithm.L09decide2
msgid "$2+2 \\neq 5.$"
msgstr "$2+2 \\neq 5.$"

#: Game.Levels.Algorithm.L09decide2
msgid ""
"Congratulations! You've finished Algorithm World. These algorithms\n"
"will be helpful for you in Even-Odd World (when someone gets around to\n"
"implementing it)."
msgstr ""
"F√©licitations ! Vous avez termin√© le monde Algorithmique. Ces algorithmes\n"
"vous seront utiles dans le monde Pair-Impair (quand quelqu'un trouvera le temps\n"
"de l'impl√©menter)."

#: Game.Levels.Algorithm
msgid "Algorithm World"
msgstr "Monde Algorithmique"

#: Game.Levels.Algorithm
msgid ""
"Proofs like $2+2=4$ and $a+b+c+d+e=e+d+c+b+a$ are very tedious to do by hand.\n"
"In Algorithm World we learn how to get the computer to do them for us.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"Les preuves comme $2+2=4$ et $a+b+c+d+e=e+d+c+b+a$ sont tr√®s fastidieuses √† faire √† la main.\n"
"Dans le monde Algorithmique, nous apprenons √† faire cela √† l'aide de l'ordinateur.\n"
"\n"
"Cliquez sur \"Commencer\" pour continuer."

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "add_right_cancel"
msgstr "add_right_cancel"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "`add_right_cancel a b n` is the theorem that $a+n=b+n \\implies a=b.$"
msgstr "`add_right_cancel a b n` est le th√©or√®me que $a+n=b+n \\implies a=b.$"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid ""
"In this world I will mostly leave you on your own.\n"
"\n"
"`add_right_cancel a b n` is the theorem that $a+n=b+n\\implies a=b$."
msgstr ""
"Dans ce monde, je vais principalement vous laisser seul.\n"
"\n"
"`add_right_cancel a b n` est le th√©or√®me que $a+n=b+n\\implies a=b$."

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "$a+n=b+n\\implies a=b$."
msgstr "$a+n=b+n\\implies a=b$."

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "Start with induction on `n`."
msgstr "Commencez par une induction sur `n`."

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "add_left_cancel"
msgstr "add_left_cancel"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "`add_left_cancel a b n` is the theorem that $n+a=n+b \\implies a=b.$"
msgstr "`add_left_cancel a b n` est le th√©or√®me que $n+a=n+b \\implies a=b.$"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid ""
"`add_left_cancel a b n` is the theorem that $n+a=n+b\\implies a=b$.\n"
"You can prove it by induction on `n` or you can deduce it from `add_right_cancel`."
msgstr ""
"`add_left_cancel a b n` est le th√©or√®me que $n+a=n+b\\implies a=b$.\n"
"Vous pouvez le prouver par induction sur `n` ou le d√©duire de `add_right_cancel`."

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "$n+a=n+b\\implies a=b$."
msgstr "$n+a=n+b\\implies a=b$."

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid ""
"How about this for a proof:\n"
"```\n"
"repeat rw [add_comm n]\n"
"exact add_right_cancel a b n\n"
"```"
msgstr ""
"Que pensez-vous de cette preuve :\n"
"```\n"
"repeat rw [add_comm n]\n"
"exact add_right_cancel a b n\n"
"```"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "add_left_eq_self"
msgstr "add_left_eq_self"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "`add_left_eq_self x y` is the theorem that $x + y = y \\implies x=0.$"
msgstr "`add_left_eq_self x y` est le th√©or√®me que $x + y = y \\implies x=0.$"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "`add_left_eq_self x y` is the theorem that $x + y = y\\implies x=0.$"
msgstr "`add_left_eq_self x y` est le th√©or√®me que $x + y = y\\implies x=0.$"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "$x + y = y\\implies x=0.$"
msgstr "$x + y = y\\implies x=0.$"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid ""
"Did you use induction on `y`?\n"
"Here's a two-line proof of `add_left_eq_self` which uses `add_right_cancel`.\n"
"If you want to inspect it, you can go into editor mode by clicking `</>` in the top right\n"
"and then just cut and paste the proof and move your cursor around it\n"
"to see the hypotheses and goal at any given point\n"
"(although you'll lose your own proof this way). Click `>_` to get\n"
"back to command line mode.\n"
"```\n"
"nth_rewrite 2 [‚Üê zero_add y]\n"
"exact add_right_cancel x 0 y\n"
"```"
msgstr ""
"Avez-vous utilis√© l'induction sur `y` ?\n"
"Voici une preuve en deux lignes de `add_left_eq_self` qui utilise `add_right_cancel`.\n"
"Si vous voulez l'inspecter, vous pouvez passer en mode √©diteur en cliquant sur `</>` en haut √† "
"droite\n"
"puis copier et coller la preuve et d√©placer votre curseur autour\n"
"pour voir les hypoth√®ses et le but √† n'importe quel point\n"
"(bien que vous perdiez ainsi votre propre preuve). Cliquez sur `>_` pour\n"
"revenir en mode ligne de commande.\n"
"```\n"
"nth_rewrite 2 [‚Üê zero_add y]\n"
"exact add_right_cancel x 0 y\n"
"```"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "add_right_eq_self"
msgstr "add_right_eq_self"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "`add_right_eq_self x y` is the theorem that $x + y = x \\implies y=0.$"
msgstr "`add_right_eq_self x y` est le th√©or√®me que $x + y = x \\implies y=0.$"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid ""
"`add_right_eq_self x y` is the theorem that $x + y = x\\implies y=0.$\n"
"Two ways to do it spring to mind; I'll mention them when you've solved it."
msgstr ""
"`add_right_eq_self x y` est le th√©or√®me que $x + y = x\\implies y=0$.\n"
"Deux fa√ßons de le faire me viennent √† l'esprit ; je les mentionnerai quand vous l'aurez r√©solu."

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "$x+y=x\\implies y=0$."
msgstr "$x+y=x\\implies y=0$."

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid ""
"This state is not provable! Did you maybe use `rw [add_left_eq_self] at h`\n"
"instead of `apply [add_left_eq_self] at h`? You can complare the two in the inventory."
msgstr ""
"Cet √©tat n'est pas prouvable ! Avez-vous peut-√™tre utilis√© `rw [add_left_eq_self] at h`\n"
"au lieu de `apply [add_left_eq_self] at h` ? Vous pouvez comparer les deux dans l'inventaire."

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid ""
"Here's a proof using `add_left_eq_self`:\n"
"```\n"
"rw [add_comm]\n"
"intro h\n"
"apply add_left_eq_self at h\n"
"exact h\n"
"```\n"
"\n"
"and here's an even shorter one using the same idea:\n"
"```\n"
"rw [add_comm]\n"
"exact add_left_eq_self y x\n"
"```\n"
"\n"
"Alternatively you can just prove it by induction on `x`:\n"
"\n"
"```\n"
"induction x with d hd\n"
"intro h\n"
"rw [zero_add] at h\n"
"exact h\n"
"intro h\n"
"rw [succ_add] at h\n"
"apply succ_inj at h\n"
"apply hd at h\n"
"exact h\n"
"```"
msgstr ""
"Voici une preuve utilisant `add_left_eq_self` :\n"
"```\n"
"rw [add_comm]\n"
"intro h\n"
"apply add_left_eq_self at h\n"
"exact h\n"
"```\n"
"\n"
"et en voici une encore plus courte utilisant la m√™me id√©e :\n"
"```\n"
"rw [add_comm]\n"
"exact add_left_eq_self y x\n"
"```\n"
"\n"
"Alternativement, vous pouvez simplement le prouver par induction sur `x` :\n"
"\n"
"```\n"
"induction x with d hd\n"
"intro h\n"
"rw [zero_add] at h\n"
"exact h\n"
"intro h\n"
"rw [succ_add] at h\n"
"apply succ_inj at h\n"
"apply hd at h\n"
"exact h\n"
"```"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "add_right_eq_zero"
msgstr "add_right_eq_zero"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid ""
"The next result we'll need in `‚â§` World is that if `a + b = 0` then `a = 0` and `b = 0`.\n"
"Let's prove one of these facts in this level, and the other in the next.\n"
"\n"
"## A new tactic: `cases`\n"
"\n"
"The `cases` tactic will split an object or hypothesis up into the possible ways\n"
"that it could have been created.\n"
"\n"
"For example, sometimes you want to deal with the two cases `b = 0` and `b = succ d` separately,\n"
"but don't need the inductive hypothesis `hd` that comes with `induction b with d hd`.\n"
"In this situation you can use `cases b with d` instead. There are two ways to make\n"
"a number: it's either zero or a successor. So you will end up with two goals, one\n"
"with `b = 0` and one with `b = succ d`.\n"
"\n"
"Another example: if you have a hypothesis `h : False` then you are done, because a false statement "
"implies\n"
"any statement. Here `cases h` will close the goal, because there are *no* ways to\n"
"make a proof of `False`! So you will end up with no goals, meaning you have proved everything."
msgstr ""
"Le prochain r√©sultat dont nous aurons besoin dans le monde `‚â§` est que si `a + b = 0` alors `a = "
"0` et `b = 0`.\n"
"Prouvons l'un de ces faits dans ce niveau, et l'autre dans le prochain.\n"
"\n"
"## Une nouvelle tactique : `cases`\n"
"\n"
"La tactique `cases` divisera un objet ou une hypoth√®se selon les fa√ßons possibles\n"
"dont il aurait pu √™tre cr√©√©.\n"
"\n"
"Par exemple, parfois vous voulez traiter les deux cas `b = 0` et `b = succ d` s√©par√©ment,\n"
"mais n'avez pas besoin de l'hypoth√®se d'induction `hd` qui vient avec `induction b with d hd`.\n"
"Dans cette situation, vous pouvez utiliser `cases b with d` √† la place. Il y a deux fa√ßons de "
"cr√©er\n"
"un nombre : soit z√©ro, soit un successeur. Vous vous retrouverez donc avec deux buts, un\n"
"avec `b = 0` et un avec `b = succ d`.\n"
"\n"
"Autre exemple : si vous avez une hypoth√®se `h : False`, alors vous avez termin√©, car un √©nonc√© "
"faux implique\n"
"n'importe quel √©nonc√©. Ici, `cases h` fermera le but, car il n'y a *aucune* fa√ßon de\n"
"faire une preuve de `False` ! Vous vous retrouverez donc sans buts, ce qui signifie que vous avez "
"tout prouv√©."


#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "## Summary\n"
"\n"
"If `n` is a number, then `cases n with d` will break the goal into two goals,\n"
"one with `n = 0` and the other with `n = succ d`.\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `n : ‚Ñï` is a number, then `cases n with d` will break the goal into two goals,\n"
"one with `n` replaced by 0 and the other with `n` replaced by `succ d`. This\n"
"corresponds to the mathematical idea that every natural number is either `0`\n"
"or a successor.\n"
"\n"
"## Example\n"
"\n"
"If `h : P ‚à® Q` is a hypothesis, then `cases h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"## Example\n"
"\n"
"If `h : a ‚â§ b` is a hypothesis, then `cases h with c hc` will create a new number `c`\n"
"and a proof `hc : b = a + c`. This is because the *definition* of `a ‚â§ b` is\n"
"`‚àÉ c, b = a + c`."
msgstr "## R√©sum√©\n"
"\n"
"Si `n` est un nombre, `cases n with d` scindera le but en deux sous-buts :\n"
"un avec `n = 0` et l'autre avec `n = succ d`.\n"
"\n"
"Si `h` est une preuve (par exemple une hypoth√®se), `cases h with...` d√©composera\n"
"la preuve en ses √©l√©ments constitutifs.\n"
"\n"
"## Exemple\n"
"\n"
"Si `n : ‚Ñï` est un nombre, `cases n with d` scindera le but en deux sous-buts :\n"
"un o√π `n` est remplac√© par 0 et l'autre o√π `n` est remplac√© par `succ d`.\n"
"Cela correspond √† l'id√©e math√©matique que tout nombre naturel est soit `0`\n"
"soit un successeur.\n"
"\n"
"## Exemple\n"
"\n"
"Si `h : P ‚à® Q` est une hypoth√®se, `cases h with hp hq` transformera un but\n"
"en deux buts : un avec l'hypoth√®se `hp : P` et l'autre avec l'hypoth√®se `hq : Q`.\n"
"\n"
"## Exemple\n"
"\n"
"Si `h : False` est une hypoth√®se, `cases h` fera dispara√Ætre le but actuel,\n"
"car il n'existe aucun moyen de construire une preuve de `False` ! Et s'il ne reste\n"
"aucun but, vous avez termin√© le niveau.\n"
"\n"
"## Exemple\n"
"\n"
"Si `h : a ‚â§ b` est une hypoth√®se, `cases h with c hc` cr√©era un nouveau nombre `c`\n"
"et une preuve `hc : b = a + c`. Ceci parce que la *d√©finition* de `a ‚â§ b` est\n"
"`‚àÉ c, b = a + c`."


#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "A proof that $a+b=0 \\implies a=0$."
msgstr "Une preuve que $a+b=0 \\implies a=0$."

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "If $a+b=0$ then $a=0$."
msgstr "Si $a+b=0$ alors $a=0$."

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid ""
"Here we want to deal with the cases `b = 0` and `b ‚â† 0` separately,\n"
"so start with `cases b with d`."
msgstr ""
"Ici, nous voulons traiter les cas `b = 0` et `b ‚â† 0` s√©par√©ment,\n"
"donc commencez par `cases b with d`."

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "Well done!"
msgstr "Bien jou√© !"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "add_left_eq_zero"
msgstr "add_left_eq_zero"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid ""
"You can just mimic the previous proof to do this one -- or you can figure out a way\n"
"of using it."
msgstr ""
"Vous pouvez simplement imiter la preuve pr√©c√©dente pour celui-ci -- ou trouver un moyen\n"
"de l'utiliser."

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "A proof that $a+b=0 \\implies b=0$."
msgstr "Une preuve que $a+b=0 \\implies b=0$."

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "If $a+b=0$ then $b=0$."
msgstr "Si $a+b=0$ alors $b=0$."

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid ""
"How about this for a proof:\n"
"\n"
"```\n"
"rw [add_comm]\n"
"exact add_right_eq_zero b a\n"
"```\n"
"\n"
"That's the end of Advanced Addition World! You'll need these theorems\n"
"for the next world, `‚â§` World. Click on \"Leave World\" to access it."
msgstr ""
"Que pensez-vous de cette preuve :\n"
"\n"
"```\n"
"rw [add_comm]\n"
"exact add_right_eq_zero b a\n"
"```\n"
"\n"
"C'est la fin du monde de l'Addition Avanc√©e ! Vous aurez besoin de ces th√©or√®mes\n"
"pour le prochain monde, le monde `‚â§`. Cliquez sur \"Quitter le monde\" pour y acc√©der."

#: Game.Levels.AdvAddition
msgid "Advanced Addition World"
msgstr "Monde de l'Addition Avanc√©e"

#: Game.Levels.AdvAddition
msgid ""
"In Advanced Addition World we will prove some basic\n"
"addition facts such as $x+y=x\\implies y=0$. The theorems\n"
"proved in this world will be used to build\n"
"a theory of inequalities in `‚â§` World.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"Dans le monde de l'Addition Avanc√©e, nous prouverons des faits de base\n"
"sur l'addition comme $x+y=x\\implies y=0$. Les th√©or√®mes\n"
"prouv√©s dans ce monde seront utilis√©s pour construire\n"
"une th√©orie des in√©galit√©s dans le monde `‚â§`.\n"
"\n"
"Cliquez sur \"Commencer\" pour continuer."

#: Game.Levels.LessOrEqual.L01le_refl
msgid "The `use` tactic"
msgstr "La tactique `use`"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a ‚â§ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a ‚â§ b` by `use`ing the\n"
"number which is morally `b - a` (i.e. `use b - a`)\n"
"\n"
"Any of the following examples is possible assuming the type of the argument passed to the `use` "
"function is accurate:\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"
msgstr ""
"## R√©sum√©\n"
"\n"
"La tactique `use` fait progresser les buts qui affirement que quelque chose *existe*.\n"
"Si le but affirme qu'un certain `x` existe avec une certaine propri√©t√©, et que vous savez\n"
"que `x = 37` fonctionnera, alors `use 37` fera progresser.\n"
"\n"
"Comme `a ‚â§ b` est une notation pour \"il existe `c` tel que `b = a + c`\",\n"
"vous pouvez faire progresser les buts de la forme `a ‚â§ b` en utilisant `use` avec le\n"
"nombre qui moralement est `b - a` (c'est-√†-dire `use b - a`)\n"
"\n"
"Tous les exemples suivants sont possibles en supposant que le type de l'argument pass√© √† la fonction "
"`use` est correct :\n"
"\n"
"- `use 37`\n"
"- `use a`\n"
"- `use a * a + 1`"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`a ‚â§ b` is *notation* for `‚àÉ c, b = a + c`.\n"
"\n"
"Because this game doesn't have negative numbers, this definition\n"
"is mathematically valid.\n"
"\n"
"This means that if you have a goal of the form `a ‚â§ b` you can\n"
"make progress with the `use` tactic, and if you have a hypothesis\n"
"`h : a ‚â§ b`, you can make progress with `cases h with c hc`."
msgstr ""
"`a ‚â§ b` est une *notation* pour `‚àÉ c, b = a + c`.\n"
"\n"
"Comme ce jeu n'a pas de nombres n√©gatifs, cette d√©finition\n"
"est math√©matiquement valide.\n"
"\n"
"Cela signifie que si vous avez un but de la forme `a ‚â§ b`, vous pouvez\n"
"progresser avec la tactique `use`, et si vous avez une hypoth√®se\n"
"`h : a ‚â§ b`, vous pouvez progresser avec `cases h with c hc`."

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`a ‚â§ b` is *notation* for `‚àÉ c, b = a + c`. This \"backwards E\"\n"
"means \"there exists\". So `a ‚â§ b` means that there exists\n"
"a number `c` such that `b = a + c`. This definition works\n"
"because there are no negative numbers in this game.\n"
"\n"
"To *prove* an \"exists\" statement, use the `use` tactic.\n"
"Let's see an example."
msgstr ""
"`a ‚â§ b` est une *notation* pour `‚àÉ c, b = a + c`. Ce \"E √† l'envers\"\n"
"signifie \"il existe\". Ainsi, `a ‚â§ b` signifie qu'il existe\n"
"un nombre `c` tel que `b = a + c`. Cette d√©finition fonctionne\n"
"car il n'y a pas de nombres n√©gatifs dans ce jeu.\n"
"\n"
"Pour *prouver* une affirmation \"il existe\", utilisez la tactique `use`.\n"
"Voyons un exemple."

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`le_refl x` is a proof of `x ‚â§ x`.\n"
"\n"
"The reason for the name is that this lemma is \"reflexivity of $\\le$\""
msgstr ""
"`le_refl x` est une preuve de `x ‚â§ x`.\n"
"\n"
"La raison du nom est que ce lemme est \"la r√©flexivit√© de $\\le$\""

#: Game.Levels.LessOrEqual.L01le_refl
msgid "If $x$ is a number, then $x \\le x$."
msgstr "Si $x$ est un nombre, alors $x \\le x$."

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"The reason `¬´{x}¬ª ‚â§ ¬´{x}¬ª` is because `¬´{x}¬ª = ¬´{x}¬ª + 0`.\n"
"So you should start this proof with `use 0`."
msgstr ""
"La raison pour laquelle `¬´{x}¬ª ‚â§ ¬´{x}¬ª` est que `¬´{x}¬ª = ¬´{x}¬ª + 0`.\n"
"Vous devriez donc commencer cette preuve par `use 0`."

#: Game.Levels.LessOrEqual.L01le_refl
msgid "You can probably take it from here."
msgstr "Vous pouvez probablement continuer √† partir d'ici."

#: Game.Levels.LessOrEqual.L02zero_le
msgid "0 ‚â§ x"
msgstr "0 ‚â§ x"

#: Game.Levels.LessOrEqual.L02zero_le
msgid "To solve this level, you need to `use` a number `c` such that `x = 0 + c`."
msgstr "Pour r√©soudre ce niveau, vous devez utiliser `use` un nombre `c` tel que `x = 0 + c`."

#: Game.Levels.LessOrEqual.L02zero_le
msgid "`zero_le x` is a proof that `0 ‚â§ x`."
msgstr "`zero_le x` est une preuve que `0 ‚â§ x`."

#: Game.Levels.LessOrEqual.L02zero_le
msgid "If $x$ is a number, then $0 \\le x$."
msgstr "Si $x$ est un nombre, alors $0 \\le x$."

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "x ‚â§ succ x"
msgstr "x ‚â§ succ x"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "`le_succ_self x` is a proof that `x ‚â§ succ x`."
msgstr "`le_succ_self x` est une preuve que `x ‚â§ succ x`."

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid ""
"If you `use` the wrong number, you get stuck with a goal you can't prove.\n"
"What number will you `use` here?"
msgstr ""
"Si vous utiliser `use` avec le mauvais nombre, vous restez bloqu√© avec un but que vous ne pourrez "
"pas prouver.\n"
"Quel nombre allez-vous choisir ici ?"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "If $x$ is a number, then $x \\le \\operatorname{succ}(x)$."
msgstr "Si $x$ est un nombre, alors $x \\le \\operatorname{succ}(x)$."

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid ""
"Here's a two-liner:\n"
"```\n"
"use 1\n"
"exact succ_eq_add_one x\n"
"```\n"
"\n"
"This works because `succ_eq_add_one x` is a proof of `succ x = x + 1`."
msgstr ""
"Voici une solution en deux lignes :\n"
"```\n"
"use 1\n"
"exact succ_eq_add_one x\n"
"```\n"
"\n"
"Cela fonctionne car `succ_eq_add_one x` est une preuve de `succ x = x + 1`."

#: Game.Levels.LessOrEqual.L04le_trans
msgid "x ‚â§ y and y ‚â§ z implies x ‚â§ z"
msgstr "x ‚â§ y et y ‚â§ z implique x ‚â§ z"

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"`le_trans x y z` is a proof that if `x ‚â§ y` and `y ‚â§ z` then `x ‚â§ z`.\n"
"More precisely, it is a proof that `x ‚â§ y ‚Üí (y ‚â§ z ‚Üí x ‚â§ z)`. In words,\n"
"If $x \\le y$ then (pause) if $y \\le z$ then $x \\le z$.\n"
"\n"
"## A note on associativity\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, because `+` is left associative. However\n"
"`‚Üí` is right associative. This means that `x ‚â§ y ‚Üí y ‚â§ z ‚Üí x ‚â§ z` in Lean means\n"
"exactly that `‚â§` is transitive. This is different to how mathematicians use\n"
"$P \\implies Q \\implies R$; for them, this usually means that $P \\implies Q$\n"
"and $Q \\implies R$."
msgstr ""
"`le_trans x y z` est une preuve que si `x ‚â§ y` et `y ‚â§ z` alors `x ‚â§ z`.\n"
"Plus pr√©cis√©ment, c'est une preuve que `x ‚â§ y ‚Üí (y ‚â§ z ‚Üí x ‚â§ z)`. En fran√ßais,\n"
"Si $x \\le y$ alors (pause) si $y \\le z$ alors $x \\le z$.\n"
"\n"
"## Note sur l'associativit√©\n"
"\n"
"Dans Lean, `a + b + c` signifie `(a + b) + c`, car `+` est associatif √† gauche. Cependant\n"
"`‚Üí` est associatif √† droite. Cela signifie que dans Lean `x ‚â§ y ‚Üí y ‚â§ z ‚Üí x ‚â§ z` signifie\n"
"exactement que `‚â§` est transitive. C'est diff√©rent de la fa√ßon dont les math√©maticiens utilisent\n"
"$P \\implies Q \\implies R$ ; pour eux, cela signifie g√©n√©ralement que $P \\implies Q$\n"
"et $Q \\implies R$."

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"In this level, we see inequalities as *hypotheses*. We have not seen this before.\n"
"The `cases` tactic can be used to take `hxy` apart."
msgstr ""
"Dans ce niveau, nous voyons des in√©galit√©s comme *hypoth√®ses*. Nous n'avons pas vu cela "
"auparavant.\n"
"La tactique `cases` peut √™tre utilis√©e pour d√©composer `hxy`."

#: Game.Levels.LessOrEqual.L04le_trans
msgid "If $x \\leq y$ and $y \\leq z$, then $x \\leq z$."
msgstr "Si $x \\leq y$ et $y \\leq z$, alors $x \\leq z$."

#: Game.Levels.LessOrEqual.L04le_trans
msgid "Start with `cases ¬´{hxy}¬ª with a ha`."
msgstr "Commencez par `cases ¬´{hxy}¬ª with a ha`."

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"Now `¬´{ha}¬ª` is a proof that `¬´{y}¬ª = ¬´{x}¬ª + ¬´{a}¬ª`, and `hxy` has vanished. Similarly, you can "
"destruct\n"
"`¬´{hyz}¬ª` into its parts with `cases ¬´{hyz}¬ª with b hb`."
msgstr ""
"Maintenant `¬´{ha}¬ª` est une preuve que `¬´{y}¬ª = ¬´{x}¬ª + ¬´{a}¬ª`, et `hxy` a disparu. De m√™me, vous "
"pouvez d√©composer\n"
"`¬´{hyz}¬ª` avec `cases ¬´{hyz}¬ª with b hb`."

#: Game.Levels.LessOrEqual.L04le_trans
msgid "Now you need to figure out which number to `use`. See if you can take it from here."
msgstr ""
"Maintenant, vous devez d√©terminer quel nombre `use`. Voyez si vous pouvez continuer √† partir d'ici."

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"A passing mathematician remarks that with reflexivity and transitivity out of the way,\n"
"you have proved that `‚â§` is a *preorder* on `‚Ñï`."
msgstr ""
"Un math√©maticien de passage remarque qu'avec la r√©flexivit√© et la transitivit√©,\n"
" vous avez prouv√© que `‚â§` est un *pr√©ordre* sur `‚Ñï`."

#: Game.Levels.LessOrEqual.L05le_zero
msgid "x ‚â§ 0 ‚Üí x = 0"
msgstr "x ‚â§ 0 ‚Üí x = 0"

#: Game.Levels.LessOrEqual.L05le_zero
msgid "`le_zero x` is a proof of `x ‚â§ 0 ‚Üí x = 0`."
msgstr "`le_zero x` est une preuve de `x ‚â§ 0 ‚Üí x = 0`."

#: Game.Levels.LessOrEqual.L05le_zero
msgid ""
"It's \"intuitively obvious\" that there are no numbers less than zero,\n"
"but to prove it you will need a result which you showed in advanced\n"
"addition world."
msgstr ""
"C'est \"intuitivement √©vident\" qu'il n'y a pas de nombres inf√©rieurs √† z√©ro,\n"
"mais pour le prouver, vous aurez besoin d'un r√©sultat que vous avez montr√© dans le monde\n"
"de l'addition avanc√©e."

#: Game.Levels.LessOrEqual.L05le_zero
msgid "`le_zero x` is a proof of the implication `x ‚â§ 0 ‚Üí x = 0`."
msgstr "`le_zero x` est une preuve de l'implication `x ‚â§ 0 ‚Üí x = 0`."

#: Game.Levels.LessOrEqual.L05le_zero
msgid "If $x \\leq 0$, then $x=0$."
msgstr "Si $x \\leq 0$, alors $x=0$."

#: Game.Levels.LessOrEqual.L05le_zero
msgid ""
"You want to use `add_right_eq_zero`, which you already\n"
"proved, but you'll have to start with `symm at` your hypothesis."
msgstr ""
"Vous voulez utiliser `add_right_eq_zero`, que vous avez d√©j√†\n"
"prouv√©, mais vous devrez commencer par `symm at` votre hypoth√®se."

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "x ‚â§ y and y ‚â§ x implies x = y"
msgstr "x ‚â§ y et y ‚â§ x implique x = y"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "`le_antisymm x y` is a proof that if `x ‚â§ y` and `y ‚â§ x` then `x = y`."
msgstr "`le_antisymm x y` est une preuve que si `x ‚â§ y` et `y ‚â§ x` alors `x = y`."

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid ""
"This level asks you to prove *antisymmetry* of $\\leq$.\n"
"In other words, if $x \\leq y$ and $y \\leq x$ then $x = y$.\n"
"It's the trickiest one so far. Good luck!"
msgstr ""
"Ce niveau vous demande de prouver l'*antisym√©trie* de $\\leq$.\n"
"Autrement dit, si $x \\leq y$ et $y \\leq x$ alors $x = y$.\n"
"C'est le plus d√©licat jusqu'√† pr√©sent. Bonne chance !"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "If $x \\leq y$ and $y \\leq x$, then $x = y$."
msgstr "Si $x \\leq y$ et $y \\leq x$, alors $x = y$."

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid ""
"Here's my proof:\n"
"```\n"
"cases hxy with a ha\n"
"cases hyx with b hb\n"
"rw [ha]\n"
"rw [ha, add_assoc] at hb\n"
"symm at hb\n"
"apply add_right_eq_self at hb\n"
"apply add_right_eq_zero at hb\n"
"rw [hb, add_zero]\n"
"rfl\n"
"```\n"
"\n"
"A passing mathematician remarks that with antisymmetry as well,\n"
"you have proved that `‚â§` is a *partial order* on `‚Ñï`.\n"
"\n"
"The boss level of this world is to prove\n"
"that `‚â§` is a total order. Let's learn two more easy tactics\n"
"first."
msgstr ""
"Voici ma preuve :\n"
"```\n"
"cases hxy with a ha\n"
"cases hyx with b hb\n"
"rw [ha]\n"
"rw [ha, add_assoc] at hb\n"
"symm at hb\n"
"apply add_right_eq_self at hb\n"
"apply add_right_eq_zero at hb\n"
"rw [hb, add_zero]\n"
"rfl\n"
"```\n"
"\n"
"Un math√©maticien de passage remarque qu'avec l'antisym√©trie aussi,\n"
"vous avez prouv√© que `‚â§` est un *ordre partiel* sur `‚Ñï`.\n"
"\n"
"Le niveau boss de ce monde est de prouver\n"
"que `‚â§` est un ordre total. Apprenons d'abord deux autres tactiques faciles."

#: Game.Levels.LessOrEqual.L07or_symm
msgid "Dealing with `or`"
msgstr "G√©rer `or`"

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"# Summary\n"
"The `left` tactic changes a goal of `P ‚à® Q` into a goal of `P`.\n"
"Use it when your hypotheses guarantee that the reason that `P ‚à® Q`\n"
"is true is because in fact `P` is true.\n"
"\n"
"Internally this tactic is just `apply`ing a theorem\n"
"saying that $P \\implies P \\lor Q.$\n"
"\n"
"Note that this tactic can turn a solvable goal into an unsolvable\n"
"one."
msgstr ""
"# R√©sum√©\n"
"La tactique `left` change un but `P ‚à® Q` en un but `P`.\n"
"Utilisez-la lorsque vos hypoth√®ses garantissent que la raison pour laquelle `P ‚à® Q`\n"
"est vrai est qu'en fait `P` est vrai.\n"
"\n"
"En interne, cette tactique applique simplement un th√©or√®me\n"
"disant que $P \\implies P \\lor Q.$\n"
"\n"
"Notez que cette tactique peut transformer un but r√©soluble en un but insoluble."

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"# Summary\n"
"The `right` tactic changes a goal of `P ‚à® Q` into a goal of `Q`.\n"
"Use it when your hypotheses guarantee that the reason that `P ‚à® Q`\n"
"is true is because in fact `Q` is true.\n"
"\n"
"Internally this tactic is just `apply`ing a theorem\n"
"saying that $Q \\implies P \\lor Q.$\n"
"\n"
"Note that this tactic can turn a solvable goal into an unsolvable\n"
"one."
msgstr ""
"# R√©sum√©\n"
"La tactique `right` change un but `P ‚à® Q` en un but `Q`.\n"
"Utilisez-la lorsque vos hypoth√®ses garantissent que la raison pour laquelle `P ‚à® Q`\n"
"est vrai est qu'en fait `Q` est vrai.\n"
"\n"
"En interne, cette tactique applique simplement un th√©or√®me\n"
"disant que $Q \\implies P \\lor Q.$\n"
"\n"
"Notez que cette tactique peut transformer un but r√©soluble en un but insoluble."

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"Totality of `‚â§` is the boss level of this world, and it's coming up next. It says that\n"
"if `a` and `b` are naturals then either `a ‚â§ b` or `b ‚â§ a`.\n"
"But we haven't talked about `or` at all. Here's a run-through.\n"
"\n"
"1) The notation for \"or\" is `‚à®`. You won't need to type it, but you can\n"
"type it with `\\or`.\n"
"\n"
"2) If you have an \"or\" statement in the *goal*, then two tactics made\n"
"progress: `left` and `right`. But don't choose a direction unless your\n"
"hypotheses guarantee that it's the correct one.\n"
"\n"
"3) If you have an \"or\" statement as a *hypothesis* `h`, then\n"
"`cases h with h1 h2` will create two goals, one where you went left,\n"
"and the other where you went right."
msgstr ""
"Que `‚â§` soit un ordre total est le niveau boss de ce monde, et il arrive bient√¥t. Il signifie que\n"
"si `a` et `b` sont des naturels, alors soit `a ‚â§ b` soit `b ‚â§ a`.\n"
"Mais nous n'avons pas du tout parl√© de `or`. Voici un aper√ßu.\n"
"\n"
"1) La notation pour \"ou\" est `‚à®`. Vous n'aurez pas besoin de la taper, mais vous pouvez\n"
"la taper avec `\\or`.\n"
"\n"
"2) Si vous avez un terme \"ou\" dans le *but*, alors deux tactiques font\n"
"avancer : `left` et `right`. Mais ne choisissez pas une direction √† moins que vos\n"
"hypoth√®ses ne garantissent que c'est la bonne.\n"
"\n"
"3) Si vous avez un √©nonc√© \"ou\" comme *hypoth√®se* `h`, alors\n"
"`cases h with h1 h2` cr√©era deux buts, un o√π vous √™tes all√© √† gauche,\n"
"et un autre o√π vous √™tes all√© √† droite."

#: Game.Levels.LessOrEqual.L07or_symm
msgid "If $x=37$ or $y=42$, then $y=42$ or $x=37$."
msgstr "Si $x=37$ ou $y=42$, alors $y=42$ ou $x=37$."

#: Game.Levels.LessOrEqual.L07or_symm
msgid "We don't know whether to go left or right yet. So start with `cases ¬´{h}¬ª with hx hy`."
msgstr ""
"Nous ne savons pas encore si aller √† gauche ou √† droite. Commencez donc par `cases ¬´{h}¬ª with hx "
"hy`."

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"Now we can prove the `or` statement by proving the statement on the right,\n"
"so use the `right` tactic."
msgstr ""
"Maintenant, nous pouvons prouver l'√©nonc√© `or` en prouvant l'√©nonc√© de droite,\n"
"donc utilisez la tactique `right`."

#: Game.Levels.LessOrEqual.L07or_symm
msgid "This time, use the `left` tactic."
msgstr "Cette fois, utilisez la tactique `left`."

#: Game.Levels.LessOrEqual.L07or_symm
msgid "Ready for the boss level of this world?"
msgstr "Pr√™t pour le niveau boss de ce monde ?"

#: Game.Levels.LessOrEqual.L08le_total
msgid "x ‚â§ y or y ‚â§ x"
msgstr "x ‚â§ y ou y ‚â§ x"

#: Game.Levels.LessOrEqual.L08le_total
msgid "`le_total x y` is a proof that `x ‚â§ y` or `y ‚â§ x`."
msgstr "`le_total x y` est une preuve que `x ‚â§ y` ou `y ‚â§ x`."

#: Game.Levels.LessOrEqual.L08le_total
msgid ""
"This is I think the toughest level yet. Tips: if `a` is a number\n"
"then `cases a with b` will split into cases `a = 0` and `a = succ b`.\n"
"And don't go left or right until your hypotheses guarantee that\n"
"you can prove the resulting goal!\n"
"\n"
"I've left hidden hints; if you need them, retry from the beginning\n"
"and click on \"Show more help!\""
msgstr ""
"C'est je pense le niveau le plus difficile jusqu'√† pr√©sent. Conseils : si `a` est un nombre\n"
"alors `cases a with b` divisera en cas `a = 0` et `a = succ b`.\n"
"Et n'allez pas √† gauche ou √† droite tant que vos hypoth√®ses ne garantissent pas\n"
"que vous pouvez prouver le but r√©sultant !\n"
"\n"
"J'ai laiss√© des indices cach√©s ; si vous en avez besoin, r√©essayez depuis le d√©but\n"
"et cliquez sur \"Afficher plus d'aide !\""

#: Game.Levels.LessOrEqual.L08le_total
msgid "If $x$ and $y$ are numbers, then either $x \\leq y$ or $y \\leq x$."
msgstr "Si $x$ et $y$ sont des nombres, alors soit $x \\leq y$ soit $y \\leq x$."

#: Game.Levels.LessOrEqual.L08le_total
msgid "Start with `induction ¬´{y}¬ª with d hd`."
msgstr "Commencez par `induction ¬´{y}¬ª with d hd`."

#: Game.Levels.LessOrEqual.L08le_total
msgid "Try `cases ¬´{hd}¬ª with h1 h2`."
msgstr "Essayez `cases ¬´{hd}¬ª with h1 h2`."

#: Game.Levels.LessOrEqual.L08le_total
msgid "Now `cases ¬´{h2}¬ª with e he`."
msgstr "Maintenant `cases ¬´{h2}¬ª with e he`."

#: Game.Levels.LessOrEqual.L08le_total
msgid "You still don't know which way to go, so do `cases ¬´{e}¬ª with a`."
msgstr "Vous ne savez toujours pas quelle direction prendre, donc faites `cases ¬´{e}¬ª with a`."

#: Game.Levels.LessOrEqual.L08le_total
msgid ""
"Very well done.\n"
"\n"
"A passing mathematician remarks that with you've just proved that `‚Ñï` is totally\n"
"ordered.\n"
"\n"
"The final few levels in this world are much easier."
msgstr ""
"Tr√®s bien jou√©.\n"
"\n"
"Un math√©maticien de passage remarque que vous venez de prouver que `‚Ñï` est totalement\n"
"ordonn√©.\n"
"\n"
"Les derniers niveaux de ce monde sont beaucoup plus faciles."

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "succ x ‚â§ succ y ‚Üí x ‚â§ y"
msgstr "succ x ‚â§ succ y ‚Üí x ‚â§ y"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "`succ_le_succ x y` is a proof that if `succ x ‚â§ succ y` then `x ‚â§ y`."
msgstr "`succ_le_succ x y` est une preuve que si `succ x ‚â§ succ y` alors `x ‚â§ y`."

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid ""
"We've proved that `x ‚â§ 0` implies `x = 0`. The last two levels\n"
"in this world will prove which numbers are `‚â§ 1` and `‚â§ 2`.\n"
"This lemma will be helpful for them."
msgstr ""
"Nous avons prouv√© que `x ‚â§ 0` implique `x = 0`. Les deux derniers niveaux\n"
"de ce monde prouveront quels nombres sont `‚â§ 1` et `‚â§ 2`.\n"
"Ce lemme nous sera utile."

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "If $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ then $x \\leq y$."
msgstr "Si $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ alors $x \\leq y$."

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid ""
"Here's my proof:\n"
"```\n"
"cases hx with d hd\n"
"use d\n"
"rw [succ_add] at hd\n"
"apply succ_inj at hd\n"
"exact hd\n"
"```"
msgstr ""
"Voici ma preuve :\n"
"```\n"
"cases hx with d hd\n"
"use d\n"
"rw [succ_add] at hd\n"
"apply succ_inj at hd\n"
"exact hd\n"
"```"

#: Game.Levels.LessOrEqual.L10le_one
msgid "x ‚â§ 1"
msgstr "x ‚â§ 1"

#: Game.Levels.LessOrEqual.L10le_one
msgid "`le_one x` is a proof that if `x ‚â§ 1` then `x = 0` or `x = 1`."
msgstr "`le_one x` est une preuve que si `x ‚â§ 1` alors `x = 0` ou `x = 1`."

#: Game.Levels.LessOrEqual.L10le_one
msgid ""
"We've seen `le_zero`, the proof that if `x ‚â§ 0` then `x = 0`.\n"
"Now we'll prove that if `x ‚â§ 1` then `x = 0` or `x = 1`."
msgstr ""
"Nous avons vu `le_zero`, la preuve que si `x ‚â§ 0` alors `x = 0`.\n"
"Maintenant, nous prouverons que si `x ‚â§ 1` alors `x = 0` ou `x = 1`."

#: Game.Levels.LessOrEqual.L10le_one
msgid "If $x \\leq 1$ then either $x = 0$ or $x = 1$."
msgstr "Si $x \\leq 1$ alors soit $x = 0$ soit $x = 1$."

#: Game.Levels.LessOrEqual.L10le_one
msgid ""
"Here's my proof:\n"
"```\n"
"cases x with y\n"
"left\n"
"rfl\n"
"rw [one_eq_succ_zero] at hx ‚ä¢\n"
"apply succ_le_succ at hx\n"
"apply le_zero at hx\n"
"rw [hx]\n"
"right\n"
"rfl\n"
"```\n"
"\n"
"If you solved this level then you should be fine with the next level!"
msgstr ""
"Voici ma preuve :\n"
"```\n"
"cases x with y\n"
"left\n"
"rfl\n"
"rw [one_eq_succ_zero] at hx ‚ä¢\n"
"apply succ_le_succ at hx\n"
"apply le_zero at hx\n"
"rw [hx]\n"
"right\n"
"rfl\n"
"```\n"
"\n"
"Si vous avez r√©solu ce niveau, vous devriez vous en sortir avec le niveau suivant !"

#: Game.Levels.LessOrEqual.L11le_two
msgid "le_two"
msgstr "le_two"

#: Game.Levels.LessOrEqual.L11le_two
msgid "`le_two x` is a proof that if `x ‚â§ 2` then `x = 0` or `x = 1` or `x = 2`."
msgstr "`le_two x` est une preuve que si `x ‚â§ 2` alors `x = 0` ou `x = 1` ou `x = 2`."

#: Game.Levels.LessOrEqual.L11le_two
msgid ""
"We'll need this lemma to prove that two is prime!\n"
"\n"
"You'll need to know that `‚à®` is right associative. This means that\n"
"`x = 0 ‚à® x = 1 ‚à® x = 2` actually means `x = 0 ‚à® (x = 1 ‚à® x = 2)`.\n"
"This affects how `left` and `right` work."
msgstr ""
"Nous aurons besoin de ce lemme pour prouver que deux est premier !\n"
"\n"
"Vous devrez savoir que `‚à®` est associatif √† droite. Cela veut dire que\n"
"`x = 0 ‚à® x = 1 ‚à® x = 2` signifie en fait `x = 0 ‚à® (x = 1 ‚à® x = 2)`.\n"
"C'est important √† comprendre pour le fonctionnement de `left` et `right`."

#: Game.Levels.LessOrEqual.L11le_two
msgid "If $x \\leq 2$ then $x = 0$ or $1$ or $2$."
msgstr "Si $x \\leq 2$ alors $x = 0$ ou $1$ ou $2$."

#: Game.Levels.LessOrEqual.L11le_two
msgid ""
"Nice!\n"
"\n"
"The next step in the development of order theory is to develop\n"
"the theory of the interplay between `‚â§` and multiplication.\n"
"If you've already done Multiplication World, you're now ready for\n"
"Advanced Multiplication World. Click on \"Leave World\" to access it."
msgstr ""
"Bien !\n"
"\n"
"La prochaine √©tape dans le d√©veloppement de la th√©orie de l'ordre est de d√©velopper\n"
"la th√©orie de l'interaction entre `‚â§` et la multiplication.\n"
"Si vous avez d√©j√† fait le monde de la Multiplication, vous √™tes maintenant pr√™t pour\n"
"le monde de la Multiplication Avanc√©e. Cliquez sur \"Quitter le monde\" pour y acc√©der."

#: Game.Levels.LessOrEqual
msgid "‚â§ World"
msgstr "Monde ‚â§"

#: Game.Levels.LessOrEqual
msgid ""
"In this world we define `a ‚â§ b` and prove standard facts\n"
"about it, such as \"if `a ‚â§ b` and `b ‚â§ c` then `a ‚â§ c`.\"\n"
"\n"
"The definition of `a ‚â§ b` is \"there exists a number `c`\n"
"such that `b = a + c`. \" So we're going to have to learn\n"
"a tactic to prove \"exists\" theorems, and another one\n"
"to use \"exists\" hypotheses.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"Dans ce monde, nous d√©finissons `a ‚â§ b` et prouvons des faits classiques\n"
"√† ce sujet, comme \"si `a ‚â§ b` et `b ‚â§ c` alors `a ‚â§ c`.\"\n"
"\n"
"La d√©finition de `a ‚â§ b` est \"il existe un nombre `c`\n"
"tel que `b = a + c`\". Nous allons donc devoir apprendre\n"
"une tactique pour prouver des th√©or√®mes \"existentiels\", et une autre\n"
"pour utiliser des hypoth√®ses \"existentielles\".\n"
"\n"
"Cliquez sur \"Commencer\" pour continuer."

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "mul_le_mul_right"
msgstr "mul_le_mul_right"

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "`mul_le_mul_right a b t` is a proof that `a ‚â§ b ‚Üí a * t ‚â§ b * t`."
msgstr "`mul_le_mul_right a b t` est une preuve que `a ‚â§ b ‚Üí a * t ‚â§ b * t`."

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "Let's warm up with an easy one, which works even if `t = 0`."
msgstr "√âchauffons-nous avec un exercice facile, qui fonctionne m√™me si `t = 0`."

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid ""
"My proof:\n"
"```\n"
"cases h with d hd\n"
"use d * t\n"
"rw [hd, add_mul]\n"
"rfl\n"
"```"
msgstr ""
"Ma preuve :\n"
"```\n"
"cases h with d hd\n"
"use d * t\n"
"rw [hd, add_mul]\n"
"rfl\n"
"```"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "mul_left_ne_zero"
msgstr "mul_left_ne_zero"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "`mul_left_ne_zero a b` is a proof that `a * b ‚â† 0 ‚Üí b ‚â† 0`."
msgstr "`mul_left_ne_zero a b` est une preuve que `a * b ‚â† 0 ‚Üí b ‚â† 0`."

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid ""
"If you have completed Algorithm World then you can use the `contrapose!` tactic\n"
"here. If not then I'll talk you through a manual approach."
msgstr ""
"Si vous avez termin√© le monde Algorithmique, vous pouvez utiliser la tactique `contrapose!`\n"
"ici. Sinon, je vais vous guider √† travers une approche manuelle."

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid ""
"We want to reduce this to a hypothesis `b = 0` and a goal `a * b = 0`,\n"
"which is logically equivalent but much easier to prove. Remember that `X ‚â† 0`\n"
"is notation for `X = 0 ‚Üí False`. Click on `Show more help!` if you need hints."
msgstr ""
"Nous voulons r√©duire cela √† une hypoth√®se `b = 0` et un but `a * b = 0`,\n"
"ce qui est logiquement √©quivalent mais beaucoup plus facile √† prouver. Rappelez-vous que `X ‚â† 0`\n"
"est une notation pour `X = 0 ‚Üí False`. Cliquez sur `Afficher plus d'aide !` si vous avez besoin "
"d'indices."

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "Start with `intro hb`."
msgstr "Commencez par `intro hb`."

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "Now `apply h` and you can probably take it from here."
msgstr "Maintenant `apply h` et vous pouvez probablement continuer √† partir d'ici."

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "eq_succ_of_ne_zero"
msgstr "eq_succ_of_ne_zero"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"# Summary\n"
"\n"
"The `tauto` tactic will solve any goal which can be solved purely by logic (that is, by\n"
"truth tables).\n"
"\n"
"## Details\n"
"\n"
"`tauto` *does not do magic*! It doesn't know *anything* about addition or multiplication,\n"
"it doesn't even know `add_zero`. The only things that `tauto` knows about numbers\n"
"are firstly that `a = a` and secondly that `0 ‚â† 1`, `0 ‚â† 2`, `1 ‚â† 2` and so on.\n"
"What `tauto`'s strength is, is *logic*. If you have a hypothesis `x < 37`\n"
"and another hypothesis `x < 37 ‚Üí y + z = 42` and your goal is `y + z = 42` then `tauto` will\n"
"solve this goal, because to solve that goal you don't need to know any facts\n"
"about inequalities or addition, all you need to know is the rules of logic.\n"
"\n"
"## Example\n"
"\n"
"If you have `False` as a hypothesis, then `tauto` will solve\n"
"the goal. This is because a false hypothesis implies any hypothesis.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `True`, then `tauto` will solve the goal.\n"
"\n"
"## Example\n"
"\n"
"If you have two hypotheses `h1 : a = 37` and `h2 : a ‚â† 37` then `tauto` will\n"
"solve the goal because it can prove `False` from your hypotheses, and thus\n"
"prove the goal (as `False` implies anything).\n"
"\n"
"## Example\n"
"\n"
"If you have one hypothesis `h : a ‚â† a` then `tauto` will solve the goal because\n"
"`tauto` is smart enough to know that `a = a` is true, which gives the contradiction we seek.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis `h : 0 = 1` then `tauto` will solve the goal, because\n"
"`tauto` knows `0 ‚â† 1` and this is enough to prove `False`, which implies any goal.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis of the form `a = 0 ‚Üí a * b = 0` and your goal is `a * b ‚â† 0 ‚Üí a ‚â† 0`, "
"then\n"
"`tauto` will solve the goal, because the goal is logically equivalent to the hypothesis.\n"
"If you switch the goal and hypothesis in this example, `tauto` would solve it too."
msgstr ""
"# R√©sum√©\n"
"\n"
"La tactique `tauto` r√©soudra tout but qui peut √™tre r√©solu purement par logique (c'est-√†-dire par\n"
"tables de v√©rit√©).\n"
"\n"
"## D√©tails\n"
"\n"
"`tauto` *ne fait pas de magie* ! Il ne sait *rien* sur l'addition ou la multiplication,\n"
"il ne conna√Æt m√™me pas `add_zero`. Les seules choses que `tauto` sait sur les nombres\n"
"sont premi√®rement que `a = a` et deuxi√®mement que `0 ‚â† 1`, `0 ‚â† 2`, `1 ‚â† 2`, etc.\n"
"La force de `tauto` est la *logique*. Si vous avez une hypoth√®se `x < 37`\n"
"et une autre hypoth√®se `x < 37 ‚Üí y + z = 42` et que votre but est `y + z = 42`, alors `tauto`\n"
"r√©soudra ce but, car pour r√©soudre ce but, vous n'avez pas besoin de conna√Ætre des faits\n"
"sur les in√©galit√©s ou l'addition, tout ce que vous devez savoir ce sont les r√®gles de la logique.\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez `False` comme hypoth√®se, alors `tauto` r√©soudra\n"
"le but. C'est parce qu'une hypoth√®se fausse implique n'importe quelle hypoth√®se.\n"
"\n"
"## Exemple\n"
"\n"
"Si votre but est `True`, alors `tauto` r√©soudra le but.\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez deux hypoth√®ses `h1 : a = 37` et `h2 : a ‚â† 37` alors `tauto`\n"
"r√©soudra le but car il peut prouver `False` √† partir de vos hypoth√®ses, et ainsi\n"
"prouver le but (car `False` implique n'importe quoi).\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez une hypoth√®se `h : a ‚â† a` alors `tauto` r√©soudra le but car\n"
"`tauto` est assez intelligent pour savoir que `a = a` est vrai, ce qui donne la contradiction que "
"nous cherchons.\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez une hypoth√®se `h : 0 = 1` alors `tauto` r√©soudra le but, car\n"
"`tauto` sait que `0 ‚â† 1` et cela suffit √† prouver `False`, ce qui implique n'importe quel but.\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez une hypoth√®se de la forme `a = 0 ‚Üí a * b = 0` et que votre but est `a * b ‚â† 0 ‚Üí a ‚â† "
"0`, alors\n"
"`tauto` r√©soudra le but, car le but est logiquement √©quivalent √† l'hypoth√®se.\n"
"Si vous √©changez le but et l'hypoth√®se dans cet exemple, `tauto` le r√©soudrait aussi."

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "`eq_succ_of_ne_zero a` is a proof that `a ‚â† 0 ‚Üí ‚àÉ n, a = succ n`."
msgstr "`eq_succ_of_ne_zero a` est une preuve que `a ‚â† 0 ‚Üí ‚àÉ n, a = succ n`."

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"Multiplication usually makes a number bigger, but multiplication by zero can make\n"
"it smaller. Thus many lemmas about inequalities and multiplication need the\n"
"hypothesis `a ‚â† 0`. Here is a key lemma that enables us to use this hypothesis.\n"
"To help us with the proof, we can use the `tauto` tactic. Click on the tactic's name\n"
"on the right to see what it does."
msgstr ""
"La multiplication transforme g√©n√©ralement un nombre en un no√πmbre plus grand, mais la "
"multiplication par z√©ro peut le rendre\n"
"plus petit. Ainsi, de nombreux lemmes sur les in√©galit√©s et la multiplication n√©cessitent l'\n"
"hypoth√®se `a ‚â† 0`. Voici un lemme cl√© qui nous permet d'utiliser cette hypoth√®se.\n"
"Pour la preuve, nous pouvons utiliser la tactique `tauto`. Cliquez sur le nom de la tactique\n"
"√† droite pour voir ce qu'elle fait."

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "Start with `cases a with d` to do a case split on `a = 0` and `a = succ d`."
msgstr "Commencez par `cases a with d` pour faire une division de cas sur `a = 0` et `a = succ d`."

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"In the \"base case\" we have a hypothesis `ha : 0 ‚â† 0`, and you can deduce anything\n"
"from a false statement. The `tauto` tactic will close this goal."
msgstr ""
"Dans le \"cas de base\", nous avons une hypoth√®se `ha : 0 ‚â† 0`, et vous pouvez d√©duire n'importe "
"quoi\n"
"d'un √©nonc√© faux. La tactique `tauto` fermera ce but."

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "one_le_of_ne_zero"
msgstr "one_le_of_ne_zero"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "`one_le_of_ne_zero a` is a proof that `a ‚â† 0 ‚Üí 1 ‚â§ a`."
msgstr "`one_le_of_ne_zero a` est une preuve que `a ‚â† 0 ‚Üí 1 ‚â§ a`."

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "The previous lemma can be used to prove this one."
msgstr "Le lemme pr√©c√©dent peut √™tre utilis√© pour prouver celui-ci."

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Use the previous lemma with `apply eq_succ_of_ne_zero at ha`."
msgstr "Utilisez le lemme pr√©c√©dent avec `apply eq_succ_of_ne_zero at ha`."

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Now take apart the existence statement with `cases ha with n hn`."
msgstr "Maintenant, d√©composez l'√©nonc√© d'existence avec `cases ha with n hn`."

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "le_mul_right"
msgstr "le_mul_right"

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"`le_mul_right a b` is a proof that `a * b ‚â† 0 ‚Üí a ‚â§ a * b`.\n"
"\n"
"It's one way of saying that a divisor of a positive number\n"
"has to be at most that number."
msgstr ""
"`le_mul_right a b` est une preuve que `a * b ‚â† 0 ‚Üí a ‚â§ a * b`.\n"
"\n"
"C'est une fa√ßon de dire qu'un diviseur d'un nombre positif\n"
"doit √™tre au plus √©gal √† ce nombre."

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"One day this game will have a Prime Number World, with a final boss\n"
"of proving that $2$ is prime.\n"
"To do this, we will have to rule out things like $2 = 37 √ó 42.$\n"
"We will do this by proving that any factor of $2$ is at most $2$,\n"
"which we will do using this lemma. The proof I have in mind manipulates the hypothesis\n"
"until it becomes the goal, using `mul_left_ne_zero`, `one_le_of_ne_zero` and\n"
"`mul_le_mul_right`."
msgstr ""
"Un jour, ce jeu aura un monde des Nombres Premiers, avec un boss final\n"
"prouvant que $2$ est premier.\n"
"Pour cela, nous devrons exclure des choses comme $2 = 37 √ó 42$.\n"
"Nous ferons cela en prouvant que tout facteur de $2$ est au plus $2$,\n"
"en utilisant ce lemme. La preuve que j'ai en t√™te manipule l'hypoth√®se\n"
"jusqu'√† ce qu'elle devienne le but, en utilisant `mul_left_ne_zero`, `one_le_of_ne_zero` et\n"
"`mul_le_mul_right`."

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"Here's what I was thinking of:\n"
"```\n"
"apply mul_left_ne_zero at h\n"
"apply one_le_of_ne_zero at h\n"
"apply mul_le_mul_right 1 b a at h\n"
"rw [one_mul, mul_comm] at h\n"
"exact h\n"
"```"
msgstr ""
"Voici ce que j'avais en t√™te :\n"
"```\n"
"apply mul_left_ne_zero at h\n"
"apply one_le_of_ne_zero at h\n"
"apply mul_le_mul_right 1 b a at h\n"
"rw [one_mul, mul_comm] at h\n"
"exact h\n"
"```"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "mul_right_eq_one"
msgstr "mul_right_eq_one"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"# Summary\n"
"\n"
"The `have` tactic can be used to add new hypotheses to a level, but of course\n"
"you have to prove them.\n"
"\n"
"\n"
"## Example\n"
"\n"
"The simplest usage is like this. If you have `a` in your context and you execute\n"
"\n"
"`have ha : a = 0`\n"
"\n"
"then you will get a new goal `a = 0` to prove, and after you've proved\n"
"it you will have a new hypothesis `ha : a = 0` in your original goal.\n"
"\n"
"## Example\n"
"\n"
"If you already have a proof of what you want to `have`, you\n"
"can just create it immediately. For example, if you have `a` and `b`\n"
"number objects, then\n"
"\n"
"`have h2 : succ a = succ b ‚Üí a = b := succ_inj a b`\n"
"\n"
"will directly add a new hypothesis `h2 : succ a = succ b ‚Üí a = b`\n"
"to the context, because you just supplied the proof of it (`succ_inj a b`).\n"
"\n"
"## Example\n"
"\n"
"If you have a proof to hand, then you don't even need to state what you\n"
"are proving. For example\n"
"\n"
"`have h2 := succ_inj a b`\n"
"\n"
"will add `h2 : succ a = succ b ‚Üí a = b` as a hypothesis."
msgstr ""
"# R√©sum√©\n"
"\n"
"La tactique `have` permet d'ajouter de nouvelles hypoth√®ses √† un niveau, mais vous devez bien s√ªr\n"
"les prouver.\n"
"\n"
"\n"
"## Exemple\n"
"\n"
"L'utilisation la plus simple est la suivante. Si vous avez `a` dans votre contexte et que vous "
"ex√©cutez\n"
"\n"
"`have ha : a = 0`\n"
"\n"
"alors vous obtiendrez un nouveau but `a = 0` √† prouver, et apr√®s l'avoir prouv√©\n"
"vous aurez une nouvelle hypoth√®se `ha : a = 0` dans votre but initial.\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez d√©j√† une preuve de ce que vous voulez obtenir avec `have`, vous\n"
"pouvez la cr√©er imm√©diatement. Par exemple, si vous avez des objets num√©riques `a` et `b`,\n"
"alors\n"
"\n"
"`have h2 : succ a = succ b ‚Üí a = b := succ_inj a b`\n"
"\n"
"ajoutera directement une nouvelle hypoth√®se `h2 : succ a = succ b ‚Üí a = b`\n"
"dans le contexte, car vous avez fourni sa preuve (`succ_inj a b`).\n"
"\n"
"## Exemple\n"
"\n"
"Si vous avez une preuve sous la main, vous n'avez m√™me pas besoin d'√©noncer ce que vous\n"
"prouvez. Par exemple\n"
"\n"
"`have h2 := succ_inj a b`\n"
"\n"
"ajoutera `h2 : succ a = succ b ‚Üí a = b` comme hypoth√®se."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "`mul_right_eq_one a b` is a proof that `a * b = 1 ‚Üí a = 1`."
msgstr "`mul_right_eq_one a b` est une preuve que `a * b = 1 ‚Üí a = 1`."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"This level proves `x * y = 1 ‚Üí x = 1`, the multiplicative analogue of Advanced Addition\n"
"World's `x + y = 0 ‚Üí x = 0`. The strategy is to prove that `x ‚â§ 1` and then use the\n"
"lemma `le_one` from `‚â§` world.\n"
"\n"
"We'll prove it using a new and very useful tactic called `have`."
msgstr ""
"Ce niveau prouve `x * y = 1 ‚Üí x = 1`, c'est l'analogue multiplicatif de `x + y = 0 ‚Üí x = 0`\n"
"du Monde de l'Addition Avanc√©e. La strat√©gie consiste √† prouver que `x ‚â§ 1` puis √† utiliser\n"
"le lemme `le_one` du monde `‚â§`.\n"
"\n"
"Nous le prouverons en utilisant une nouvelle tactique tr√®s utile appel√©e `have`."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"We want to use `le_mul_right`, but we need a hypothesis `x * y ‚â† 0`\n"
"which we don't have. Yet. Execute `have h2 : x * y ‚â† 0` (you can type `‚â†` with `\\ne`).\n"
"You'll be asked to\n"
"prove it, and then you'll have a new hypothesis which you can apply\n"
"`le_mul_right` to."
msgstr ""
"Nous voulons utiliser `le_mul_right`, mais nous avons besoin d'une hypoth√®se `x * y ‚â† 0`\n"
"que nous n'avons pas encore. Ex√©cutez `have h2 : x * y ‚â† 0` (vous pouvez taper `‚â†` avec `\\ne`).\n"
"Vous devrez prouver cette hypoth√®se, puis vous disposerez d'une nouvelle hypoth√®se √† laquelle\n"
"appliquer `le_mul_right`."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now you can `apply le_mul_right at h2`."
msgstr "Maintenant vous pouvez utiliser `apply le_mul_right at h2`."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now `rw [¬´{h}¬ª] at ¬´{h2}¬ª` so you can `apply le_one at ¬´{h2}¬ª`."
msgstr "Maintenant `rw [¬´{h}¬ª] at ¬´{h2}¬ª` pour pouvoir `apply le_one at ¬´{h2}¬ª`."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"Now `cases h2 with h0 h1` and deal with the two\n"
"cases separately."
msgstr ""
"Maintenant `cases h2 with h0 h1` et traitez les deux\n"
"cas s√©par√©ment."

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "`tauto` is good enough to solve this goal."
msgstr "`tauto` est suffisant pour r√©soudre ce but."

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "mul_ne_zero"
msgstr "mul_ne_zero"

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "`mul_ne_zero a b` is a proof that if `a ‚â† 0` and `b ‚â† 0` then `a * b ‚â† 0`."
msgstr "`mul_ne_zero a b` est une preuve que si `a ‚â† 0` et `b ‚â† 0` alors `a * b ‚â† 0`."

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid ""
"This level proves that if `a ‚â† 0` and `b ‚â† 0` then `a * b ‚â† 0`. One strategy\n"
"is to write both `a` and `b` as `succ` of something, deduce that `a * b` is\n"
"also `succ` of something, and then `apply zero_ne_succ`."
msgstr ""
"Ce niveau prouve que si `a ‚â† 0` et `b ‚â† 0` alors `a * b ‚â† 0`. Une strat√©gie\n"
"consiste √† √©crire `a` et `b` comme `succ` de quelque chose, √† d√©duire que `a * b` est\n"
"aussi `succ` de quelque chose, puis √† `apply zero_ne_succ`."

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "Start with `apply eq_succ_of_ne_zero at ha` and `... at hb`"
msgstr "Commencez par `apply eq_succ_of_ne_zero at ha` et `... at hb`"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "mul_eq_zero"
msgstr "mul_eq_zero"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "`mul_eq_zero a b` is a proof that if `a * b = 0` then `a = 0` or `b = 0`."
msgstr "`mul_eq_zero a b` est une preuve que si `a * b = 0` alors `a = 0` ou `b = 0`."

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid ""
"This level proves that if `a * b = 0` then `a = 0` or `b = 0`. It is\n"
"logically equivalent to the last level, so there is a very short proof."
msgstr ""
"Ce niveau prouve que si `a * b = 0` alors `a = 0` ou `b = 0`. C'est\n"
"logiquement √©quivalent au niveau pr√©c√©dent, il existe donc une preuve tr√®s courte."

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "Start with `have h2 := mul_ne_zero a b`."
msgstr "Commencez par `have h2 := mul_ne_zero a b`."

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid ""
"Now the goal can be deduced from `h2` by pure logic, so use the `tauto`\n"
"tactic."
msgstr ""
"Maintenant le but peut √™tre d√©duit de `h2` par pure logique, utilisez donc la tactique\n"
"`tauto`."

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid ""
"Here's the short proof:\n"
"```\n"
"have h2 := mul_ne_zero a b\n"
"tauto\n"
"```\n"
"This works because, given `mul_ne_zero a b`,\n"
"the argument is reduced to pure logic."
msgstr ""
"Voici la preuve courte :\n"
"```\n"
"have h2 := mul_ne_zero a b\n"
"tauto\n"
"```\n"
"Cela fonctionne car, √©tant donn√© `mul_ne_zero a b`,\n"
"l'argument se r√©duit √† de la pure logique."

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "mul_left_cancel"
msgstr "mul_left_cancel"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "`mul_left_cancel a b c` is a proof that if `a ‚â† 0` and `a * b = a * c` then `b = c`."
msgstr "`mul_left_cancel a b c` est une preuve que si `a ‚â† 0` et `a * b = a * c` alors `b = c`."

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid ""
"In this level we prove that if `a * b = a * c` and `a ‚â† 0` then `b = c`. It is tricky, for\n"
"several reasons. One of these is that\n"
"we need to introduce a new idea: we will need to understand the concept of\n"
"mathematical induction a little better.\n"
"\n"
"Starting with `induction b with d hd` is too naive, because in the inductive step\n"
"the hypothesis is `a * d = a * c ‚Üí d = c` but what we know is `a * succ d = a * c`,\n"
"so the induction hypothesis does not apply!\n"
"\n"
"Assume `a ‚â† 0` is fixed. The actual statement we want to prove by induction on `b` is\n"
"\"for all `c`, if `a * b = a * c` then `b = c`\". This *can* be proved by induction,\n"
"because we now have the flexibility to change `c`."
msgstr ""
"Dans ce niveau, nous prouvons que si `a * b = a * c` et `a ‚â† 0` alors `b = c`. C'est difficile\n"
"pour plusieurs raisons. L'une d'elles est que\n"
"nous devons introduire une nouvelle id√©e : nous devons mieux comprendre le concept\n"
"d'induction math√©matique.\n"
"\n"
"Commencer par `induction b with d hd` est trop na√Øf, car √† l'√©tape inductive\n"
"l'hypoth√®se est `a * d = a * c ‚Üí d = c` mais ce que nous savons est `a * succ d = a * c`,\n"
"donc l'hypoth√®se d'induction ne s'applique pas !\n"
"\n"
"Supposons `a ‚â† 0` fix√©. L'√©nonc√© r√©el que nous voulons prouver par induction sur `b` est\n"
"\"pour tout `c`, si `a * b = a * c` alors `b = c`\". Ceci *peut* √™tre prouv√© par induction,\n"
"car nous avons maintenant la flexibilit√© de changer `c`."

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "The way to start this proof is `induction b with d hd generalizing c`."
msgstr "La fa√ßon de commencer cette preuve est `induction b with d hd generalizing c`."

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid ""
"Use `mul_eq_zero` and remember that `tauto` will solve a goal\n"
"if there are hypotheses `a = 0` and `a ‚â† 0`."
msgstr ""
"Utilisez `mul_eq_zero` et souvenez-vous que `tauto` r√©soudra un but\n"
"s'il y a des hypoth√®ses `a = 0` et `a ‚â† 0`."

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "The inductive hypothesis `hd` is \"For all natural numbers `c`, `a * d = a * c ‚Üí d = c`\".\n"
"You can `apply` it `at` any hypothesis of the form `a * d = a * ?`."
msgstr "L'hypoth√®se d'induction `hd` est \"Pour tous les entiers naturels `c`, `a * d = a * c ‚Üí d = c`\".\n"
"Vous pouvez l'utiliser avec `apply at` √† toute hypoth√®se de la forme `a * d = a * ?`."


#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "Split into cases `c = 0` and `c = succ e` with `cases c with e`."
msgstr "S√©parez en cas `c = 0` et `c = succ e` avec `cases c with e`."

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "mul_right_eq_self"
msgstr "mul_right_eq_self"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "`mul_right_eq_self a b` is a proof that if `a ‚â† 0` and `a * b = a` then `b = 1`."
msgstr "`mul_right_eq_self a b` est une preuve que si `a ‚â† 0` et `a * b = a` alors `b = 1`."

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid ""
"The lemma proved in the final level of this world will be helpful\n"
"in Divisibility World."
msgstr ""
"Le lemme prouv√© dans le niveau final de ce monde sera utile\n"
"dans le Monde de la Divisibilit√©."

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "Reduce to the previous lemma with `nth_rewrite 2 [‚Üê mul_one a] at h`"
msgstr "R√©duisez au lemme pr√©c√©dent avec `nth_rewrite 2 [‚Üê mul_one a] at h`"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "You can now `apply mul_left_cancel at h`"
msgstr "Vous pouvez maintenant `apply mul_left_cancel at h`"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid ""
"A two-line proof is\n"
"\n"
"```\n"
"nth_rewrite 2 [‚Üê mul_one a] at h\n"
"exact mul_left_cancel a b 1 ha h\n"
"```\n"
"\n"
"We now have all the tools necessary to set up the basic theory of divisibility of naturals."
msgstr ""
"Une preuve en deux lignes est :\n"
"\n"
"```\n"
"nth_rewrite 2 [‚Üê mul_one a] at h\n"
"exact mul_left_cancel a b 1 ha h\n"
"```\n"
"\n"
"Nous avons maintenant tous les outils n√©cessaires pour √©tablir la th√©orie de base sur la "
"divisibilit√© des entiers naturels."

#: Game.Levels.AdvMultiplication
msgid "Advanced Multiplication World"
msgstr "Monde de la Multiplication Avanc√©e"

#: Game.Levels.AdvMultiplication
msgid ""
"Advanced *Addition* World proved various implications\n"
"involving addition, such as `x + y = 0 ‚Üí x = 0` and `x + y = x ‚Üí y = 0`.\n"
"These lemmas were used to prove basic facts about ‚â§ in ‚â§ World.\n"
"\n"
"In Advanced Multiplication World we prove analogous\n"
"facts about multiplication, such as `x * y = 1 ‚Üí x = 1`, and\n"
"`x * y = x ‚Üí y = 1` (assuming `x ‚â† 0` in the latter result). This will prepare\n"
"us for Divisibility World.\n"
"\n"
"Multiplication World is more complex than Addition World. In the same\n"
"way, Advanced Multiplication world is more complex than Advanced Addition\n"
"World. One reason for this is that certain intermediate results are only\n"
"true under the additional hypothesis that one of the variables is non-zero.\n"
"This causes some unexpected extra twists."
msgstr ""
"Le Monde de l'Addition Avanc√©e a prouv√© diverses implications\n"
"impliquant l'addition, telles que `x + y = 0 ‚Üí x = 0` et `x + y = x ‚Üí y = 0`.\n"
"Ces lemmes ont √©t√© utilis√©s pour prouver des faits de base sur ‚â§ dans le Monde ‚â§.\n"
"\n"
"Dans le Monde de la Multiplication Avanc√©e, nous prouvons des r√©sultats\n"
"analogues sur la multiplication, tels que `x * y = 1 ‚Üí x = 1`, et\n"
"`x * y = x ‚Üí y = 1` (en supposant `x ‚â† 0` pour ce dernier r√©sultat). Cela nous pr√©parera\n"
"au Monde de la Divisibilit√©.\n"
"\n"
"Le Monde de la Multiplication est plus complexe que le Monde de l'Addition. De la m√™me\n"
"mani√®re, le Monde de la Multiplication Avanc√©e est plus complexe que le Monde de l'Addition "
"Avanc√©e.\n"
"Une raison est que certains r√©sultats interm√©diaires ne sont vrais\n"
"que sous l'hypoth√®se suppl√©mentaire qu'une des variables est non nulle.\n"
"Cela cr√©e des complications inattendues."

#: Game
msgid "Natural Number Game"
msgstr "Le Jeu des Nombres Naturels"

#: Game
msgid ""
"# Welcome to the Natural Number Game\n"
"#### An introduction to mathematical proof.\n"
"\n"
"In this game, we will build the basic theory of the natural\n"
"numbers `{0,1,2,3,4,...}` from scratch. Our first goal is to prove\n"
"that `2 + 2 = 4`. Next we'll prove that `x + y = y + x`.\n"
"And at the end we'll see if we can prove Fermat's Last Theorem.\n"
"We'll do this by solving levels of a computer puzzle game called Lean.\n"
"\n"
"# Read this.\n"
"\n"
"Learning how to use an interactive theorem prover takes time.\n"
"Tests show that the people who get the most out of this game are\n"
"those who read the help texts like this one.\n"
"\n"
"To start, click on \"Tutorial World\".\n"
"\n"
"Note: this is a new Lean 4 version of the game containing several\n"
"worlds which were not present in the old Lean 3 version. More new worlds\n"
"such as Strong Induction World, Even/Odd World and Prime Number World\n"
"are in development; if you want to see their state or even help out, checkout\n"
"out the [issues in the github repo](https://github.com/leanprover-community/NNG4/issues).\n"
"\n"
"## More\n"
"\n"
"Click on the three lines in the top right and select \"Game Info\" for resources,\n"
"links, and ways to interact with the Lean community."
msgstr ""
"# Bienvenue dans le Jeu des Nombres Naturels\n"
"#### Une introduction aux preuves math√©matiques.\n"
"\n"
"Dans ce jeu, nous construirons la th√©orie de base des nombres\n"
"naturels `{0,1,2,3,4,...}` √† partir de z√©ro. Notre premier objectif est de prouver\n"
"que `2 + 2 = 4`. Ensuite, nous prouverons que `x + y = y + x`.\n"
"Et √† la fin, nous verrons si nous pouvons prouver le Grand Th√©or√®me de Fermat.\n"
"Nous allons r√©soudre les niveaux d'un jeu de puzzle informatique appel√© Lean.\n"
"\n"
"# Lisez ceci.\n"
"\n"
"Apprendre √† utiliser un assistant de preuve interactif prend du temps.\n"
"Des tests montrent que les personnes qui tirent le meilleur parti de ce jeu sont\n"
"celles qui lisent les textes d'aide comme celui-ci.\n"
"\n"
"Pour commencer, cliquez sur \"Monde Tutoriel\".\n"
"\n"
"Note : ceci est une nouvelle version Lean 4 du jeu contenant plusieurs\n"
"mondes absents de l'ancienne version Lean 3. D'autres nouveaux mondes\n"
"tels que le Monde de l'Induction Forte, le Monde Pair/Impair et le Monde des Nombres Premiers\n"
"sont en d√©veloppement ; si vous souhaitez voir leur √©tat ou m√™me aider, consultez\n"
"les [probl√®mes dans le d√©p√¥t github](https://github.com/leanprover-community/NNG4/issues).\n"
"\n"
"## En savoir plus\n"
"\n"
"Cliquez sur les trois lignes en haut √† droite et s√©lectionnez \"Infos du jeu\" pour les "
"ressources,\n"
"liens et moyens d'interagir avec la communaut√© Lean."

#: Game
msgid ""
"*Game version: 4.3*\n"
"\n"
"*Recent additions: bug fixes*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Kevin Buzzard, Jon Eugster\n"
"* **Original Lean3-version:** Kevin Buzzard, Mohammad Pedramfar\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Additional levels:** Sian Carey, Ivan Farabella, Archie Browne.\n"
"* **Additional thanks:** All the student beta testers, all the schools\n"
"who invited Kevin to speak, and all the schoolkids who asked him questions\n"
"about the material.\n"
"\n"
"## Resources\n"
"\n"
"* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n"
"* [Original Lean3 version](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/) (no "
"longer maintained)\n"
"\n"
"## Problems?\n"
"\n"
"Please ask any questions about this game in the\n"
"[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\n"
"the stream \"New Members\". The community will happily help. Note that\n"
"the Lean Zulip chat is a professional research forum.\n"
"Please use your full real name there, stay on topic, and be nice. If you're\n"
"looking for somewhere less formal (e.g. you want to post natural number\n"
"game memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternatively, if you experience issues / bugs you can also open github issues:\n"
"\n"
"* For issues with the game engine, please open an\n"
"[issue at the lean4game](https://github.com/leanprover-community/lean4game/issues) repo.\n"
"* For issues about the game's content, please open an\n"
"[issue at the NNG](https://github.com/hhu-adam/NNG4/issues) repo."
msgstr ""
"*Version du jeu : 4.3*\n"
"\n"
"*Ajouts r√©cents : corrections de bugs*\n"
"\n"
"## Sauvegarde de la progression\n"
"\n"
"Le jeu stocke votre progression dans le stockage local de votre navigateur.\n"
"Si vous le supprimez, votre progression sera perdue !\n"
"\n"
"Avertissement : Dans la plupart des navigateurs, supprimer les cookies effacera √©galement le "
"stockage local\n"
"(ou \"donn√©es locales du site\"). Assurez-vous de t√©l√©charger d'abord votre progression dans le "
"jeu !\n"
"\n"
"## Cr√©dits\n"
"\n"
"* **Cr√©ateurs :** Kevin Buzzard, Jon Eugster\n"
"* **Version Lean3 originale :** Kevin Buzzard, Mohammad Pedramfar\n"
"* **Moteur de jeu :** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Niveaux suppl√©mentaires :** Sian Carey, Ivan Farabella, Archie Browne.\n"
"* **Remerciements suppl√©mentaires :** Tous les b√™ta-testeurs √©tudiants, toutes les √©coles\n"
"qui ont invit√© Kevin √† parler, et tous les √©coliers qui lui ont pos√© des questions\n"
"sur le contenu.\n"
"\n"
"## Ressources\n"
"\n"
"* Le forum [Lean Zulip chat](https://leanprover.zulipchat.com/)\n"
"* [Version Lean3 originale](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/) (non "
"maintenue)\n"
"\n"
"## Probl√®mes ?\n"
"\n"
"Veuillez poser toute question sur ce jeu dans le forum\n"
"[Lean Zulip chat](https://leanprover.zulipchat.com/), par exemple dans\n"
"le flux \"New Members\". La communaut√© se fera un plaisir d'aider. Notez que\n"
"le chat Lean Zulip est un forum de recherche professionnel.\n"
"Veuillez utiliser votre vrai nom complet, rester sur le sujet et √™tre courtois. Si vous\n"
"cherchez un endroit moins formel (par exemple pour poster des m√®mes sur le jeu des nombres "
"naturels),\n"
"rendez-vous sur le [Discord Lean](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternativement, si vous rencontrez des probl√®mes/bugs, vous pouvez ouvrir des issues GitHub :\n"
"\n"
"* Pour les probl√®mes li√©s au moteur de jeu, veuillez ouvrir une issue\n"
"[sur le d√©p√¥t lean4game](https://github.com/leanprover-community/lean4game/issues).\n"
"* Pour les probl√®mes li√©s au contenu du jeu, veuillez ouvrir une issue\n"
"[sur le d√©p√¥t NNG](https://github.com/hhu-adam/NNG4/issues)."

#: Game
msgid "The classical introduction game for Lean."
msgstr "Le jeu d'introduction classique pour Lean."

#: Game
msgid ""
"In this game you recreate the natural numbers $\\mathbb{N}$ from the Peano axioms,\n"
"learning the basics about theorem proving in Lean.\n"
"\n"
"This is a good first introduction to Lean!"
msgstr ""
"Dans ce jeu, vous recr√©ez les nombres naturels $\\mathbb{N}$ √† partir des axiomes de Peano,\n"
"en apprenant les bases de la preuve de th√©or√®mes dans Lean.\n"
"\n"
"C'est une excellente premi√®re introduction √† Lean !"
