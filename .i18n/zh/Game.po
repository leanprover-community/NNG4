#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Game v4.6.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-04-11 11:25+0800\n"
"PO-Revision-Date: \n"
"Last-Translator: @JiechengZhao\n"
"Language-Team: none\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.2\n"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr "å®Œæˆå…³å¡ï¼ğŸ‰"

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr "å®Œæˆå…³å¡ï¼ğŸ‰ï¼ˆæœ‰è­¦å‘Šï¼‰"

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr "ä¸­é—´ç›®æ ‡è¯æ˜ï¼ğŸ‰"

#: Game.Levels.Tutorial.L01rfl
msgid "The rfl tactic"
msgstr "rflç­–ç•¥"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"## Summary\n"
"\n"
"`rfl` proves goals of the form `X = X`.\n"
"\n"
"In other words, the `rfl` tactic will close any goal of the\n"
"form `A = B` if `A` and `B` are *identical*.\n"
"\n"
"`rfl` is short for \\\"reflexivity (of equality)\\\".\n"
"\n"
"## Example:\n"
"\n"
"If the goal looks like this:\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"then `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\n"
"though $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\n"
"The only term which is identical to `0 + x` is `0 + x`.\n"
"\n"
"## Details\n"
"\n"
"`rfl` is short for \\\"reflexivity of equality\\\".\n"
"\n"
"## Game Implementation\n"
"\n"
"*Note that our `rfl` is weaker than the version used in core Lean and `mathlib`,\n"
"for pedagogical purposes; mathematicians do not distinguish between propositional\n"
"and definitional equality because they think about definitions in a different way\n"
"to type theorists (`zero_add` and `add_zero` are both \\\"facts\\\" as far\n"
"as mathematicians are concerned, and who cares what the definition of addition is).*"
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"`rfl` è¯æ˜å½¢å¦‚ `X = X` çš„ç›®æ ‡ã€‚\n"
"\n"
"æ¢å¥è¯è¯´ï¼Œå¦‚æœ `A` å’Œ `B` *å®Œå…¨ç›¸åŒ*ï¼Œ`rfl` ç­–ç•¥å°†è¯æ˜å½¢å¦‚ `A = B` çš„ç›®æ ‡ã€‚\n"
"\n"
"`rfl` æ˜¯ â€œreflexivityï¼ˆç­‰ä»·å…³ç³»çš„åèº«æ€§ï¼‰â€çš„ç¼©å†™ã€‚\n"
"\n"
"## ç¤ºä¾‹ï¼š\n"
"\n"
"å¦‚æœç›®æ ‡å¦‚ä¸‹ï¼š\n"
"\n"
"```\n"
"x + 37 = x + 37\n"
"```\n"
"\n"
"é‚£ä¹ˆ `rfl` å°†è¯æ˜å®ƒã€‚ä½†å¦‚æœå®ƒçœ‹èµ·æ¥åƒ `0 + x = x`ï¼Œé‚£ä¹ˆ `rfl` å°†æ— æ³•å·¥ä½œï¼Œå› ä¸ºå³ä½¿ $0+x$ å’Œ $x$ ä½œä¸º*"
"æ•°å­—*æ€»æ˜¯ç›¸ç­‰ï¼Œä½†å®ƒä»¬ä½œä¸º*é¡¹*å¹¶ä¸ç›¸ç­‰ã€‚å”¯ä¸€ä¸ `0 + x` ç›¸åŒçš„é¡¹æ˜¯ `0 + x`ã€‚\n"
"\n"
"\n"
"## è¯¦ç»†ä¿¡æ¯\n"
"\n"
"`rfl` æ˜¯ â€œreflexivity of equalityï¼ˆç­‰ä»·å…³ç³»çš„åèº«æ€§ï¼‰â€çš„ç¼©å†™ã€‚\n"
"\n"
"## æ¸¸æˆå®ç°\n"
"\n"
"*è¯·æ³¨æ„ï¼Œå‡ºäºæ•™å­¦ç›®çš„ï¼Œæˆ‘ä»¬çš„ `rfl` æ¯”æ ¸å¿ƒ Lean å’Œ `mathlib` ä¸­ä½¿ç”¨çš„ç‰ˆæœ¬å¼±ä¸€äº›ï¼›æ•°å­¦å®¶ä¸åŒºåˆ†å‘½é¢˜ç­‰ä»·"
"å’Œå®šä¹‰ç­‰ä»·ï¼Œå› ä¸ºä»–ä»¬ä»¥ä¸åŒäºç±»å‹ç†è®ºå®¶çš„æ–¹å¼æ€è€ƒå®šä¹‰ï¼ˆå°±æ•°å­¦å®¶è€Œè¨€ï¼Œ`zero_add` å’Œ `add_zero` éƒ½æ˜¯ â€œäº‹"
"å®â€ï¼Œè°ä¼šåœ¨ä¹åŠ æ³•çš„å®šä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼‰ã€‚*\n"
"ï¼ˆè¯‘æ³¨ï¼šå› ä¸º `add_zero` æ˜¯åŠ æ³•å®šä¹‰çš„ä¸€éƒ¨åˆ†ï¼Œè€Œå®šä¹‰ç­‰ä»·æ˜¯å¯ä»¥ç›´æ¥ç”¨ `rfl` è¯æ˜çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ `x + 0 = "
"x` å¯ä»¥ç”¨ `rfl` è¯æ˜ã€‚æ‰€ä»¥ä½œè€…å¤šäº†ä¸€å˜´ï¼Œä½†å®é™…ä¸Šå› ä¸ºå¾ˆå°‘æœ‰äººçŸ¥é“ç±»å‹ç†è®ºå®¶æ€ä¹ˆæ€è€ƒï¼Œæ‰€ä»¥è¿™ä¸ªæ³¨è§£çœ‹èµ·"
"æ¥ä¼šæœ‰äº›å¥‡æ€ªã€‚ï¼‰"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical theorem (the \"Goal\").\n"
"The goal will be a statement about *numbers*. Some numbers in this game have known values.\n"
"Those numbers have names like $37$. Other numbers will be secret. They're called things\n"
"like $x$ and $q$. We know $x$ is a number, we just don't know which one.\n"
"\n"
"In this first level we're going to prove the theorem that $37x + q = 37x + q$.\n"
"You can see `x q : â„•` in the *Objects* below, which means that `x` and `q`\n"
"are numbers.\n"
"\n"
"We solve goals in Lean using *Tactics*, and the first tactic we're\n"
"going to learn is called `rfl`, which proves all theorems of the form $X = X$.\n"
"\n"
"Prove that $37x+q=37x+q$ by executing the `rfl` tactic."
msgstr ""
"# æ¸¸æˆæŒ‡å—\n"
"\n"
"åœ¨è¿™ä¸ªæ¸¸æˆçš„æ¯ä¸ªå…³å¡ä¸­ï¼Œä½ éƒ½å°†æŒ‘æˆ˜è¯æ˜ä¸€ä¸ªæ•°å­¦å®šç†ï¼Œè¿™é‡Œç§°ä¹‹ä¸ºâ€œç›®æ ‡â€ã€‚è¿™äº›ç›®æ ‡ä¸»è¦ä¸*è‡ªç„¶æ•°*ç›¸å…³ã€‚æ¸¸"
"æˆä¸­ï¼Œä¸€äº›æ•°å…·æœ‰æ˜ç¡®çš„å€¼ï¼Œä¾‹å¦‚ $37$ è¿™ç±»å…·ä½“çš„æ•°ã€‚ç„¶è€Œï¼Œè¿˜æœ‰ä¸€äº›æ•°æ˜¯æœªçŸ¥æ•°ï¼Œå®ƒä»¬è¢«ç§°ä¸º $x$ã€$q$ ç­‰ã€‚"
"è™½ç„¶æˆ‘ä»¬ä¸çŸ¥é“ $x$ çš„å…·ä½“å€¼ï¼Œä½†æˆ‘ä»¬çŸ¥é“å®ƒä»£è¡¨ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n"
"\n"
"åœ¨æ¸¸æˆçš„ç¬¬ä¸€å…³ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ˜¯è¯æ˜å®šç† $37x + q = 37x + q$ã€‚ä½ å°†åœ¨ä¸‹æ–¹çš„*å¯¹è±¡*ä¸­çœ‹åˆ° `x q : â„•`ï¼Œè¿™è¡¨ç¤º "
"`x` å’Œ `q` éƒ½æ˜¯è‡ªç„¶æ•°ã€‚\n"
"\n"
"ä¸ºäº†åœ¨ Lean ä¸­è¯æ˜è¿™äº›ç›®æ ‡ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å’Œä½¿ç”¨å„ç§*ç­–ç•¥*ã€‚é¦–å…ˆä»‹ç»çš„ç­–ç•¥æ˜¯ `rfl`ï¼Œå®ƒç”¨äºè¯æ˜æ‰€æœ‰å½¢å¼ä¸º "
"$X = X$ çš„å®šç†ã€‚\n"
"\n"
"è¦è¯æ˜ $37x+q=37x+q$ï¼Œè¯·ä½¿ç”¨ `rfl` ç­–ç•¥ã€‚"

#: Game.Levels.Tutorial.L01rfl
msgid "If $x$ and $q$ are arbitrary natural numbers, then $37x+q=37x+q.$"
msgstr "å¦‚æœ $x$ å’Œ $q$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ $37x+q=37x+q$ ã€‚"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"In order to use the tactic `rfl` you can enter it in the text box\n"
"under the goal and hit \"Execute\"."
msgstr "è¦ä½¿ç”¨ç­–ç•¥ \"rfl\"ï¼Œæ‚¨å¯ä»¥åœ¨ç›®æ ‡ä¸‹çš„æ–‡æœ¬æ¡†ä¸­è¾“å…¥å®ƒï¼Œç„¶åç‚¹å‡» \"æ‰§è¡Œ\"ã€‚"

#: Game.Levels.Tutorial.L01rfl
msgid ""
"Congratulations! You completed your first verified proof!\n"
"\n"
"Remember that `rfl` is a *tactic*. If you ever want information about the `rfl` tactic,\n"
"you can click on `rfl` in the list of tactics on the right.\n"
"\n"
"Now click on \"Next\" to learn about the `rw` tactic."
msgstr ""
"æ­å–œä½ ï¼ä½ å·²ç»å®Œæˆäº†ç¬¬ä¸€ä¸ªè¯æ˜ï¼\n"
"\n"
"è¯·è®°å¾—ï¼Œ`rfl` æ˜¯ä¸€ç§*ç­–ç•¥*ã€‚å¦‚æœä½ å¯¹ `rfl` ç­–ç•¥æœ‰æ›´å¤šçš„å…´è¶£æƒ³è¦æ·±å…¥äº†è§£ï¼Œå¯ä»¥å°è¯•ç‚¹å‡»å³ä¾§ç­–ç•¥åˆ—è¡¨ä¸­"
"çš„ `rfl` æŸ¥çœ‹è¯¦æƒ…ã€‚\n"
"\n"
"ç°åœ¨ï¼Œè¯·ç‚¹å‡»â€œä¸‹ä¸€å…³â€ï¼Œç»§ç»­å­¦ä¹  `rw`ï¼ˆé‡å†™ï¼‰ç­–ç•¥ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "the rw tactic"
msgstr "rw ç­–ç•¥"

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"If `h` is a proof of an equality `X = Y`, then `rw [h]` will change\n"
"all `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n"
"\n"
"## Variants\n"
"\n"
"* `rw [â† h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n"
"\n"
"* `rw [h1, h2]` (a sequence of rewrites)\n"
"\n"
"* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n"
"\n"
"* `rw [h] at h1 h2 âŠ¢` (changes `X`s to `Y`s in two hypotheses and the goal;\n"
"get the `âŠ¢` symbol with `\\|-`.)\n"
"\n"
"* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\n"
"until there are no more matches for `? + 0`.\n"
"\n"
"* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n"
"\n"
"### Example:\n"
"\n"
"If you have the assumption `h : x = y + y` and your goal is\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"will change the goal into `succ x = succ (y + y)`, and then\n"
"\n"
"`rw [h]`\n"
"\n"
"will change the goal into `succ (y + y) = succ (y + y)`, which\n"
"can be solved with `rfl`.\n"
"\n"
"### Example:\n"
"\n"
"You can use `rw` to change a hypothesis as well.\n"
"For example, if you have two hypotheses\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"then `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
"\n"
"## Common errors\n"
"\n"
"* You need the square brackets. `rw h` is never correct.\n"
"\n"
"* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\n"
"for example if `h` is a function or an implication,\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\n"
"not the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \\\"substituting in\\\". There\n"
"are two distinct situations where you can use this tactic.\n"
"\n"
"1) Basic usage: if `h : A = B` is an assumption or\n"
"the proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\n"
"will change them all to `B`'s. The tactic will error\n"
"if there are no `A`s in the goal.\n"
"\n"
"2) Advanced usage: Assumptions coming from theorem proofs\n"
"often have missing pieces. For example `add_zero`\n"
"is a proof that `? + 0 = ?` because `add_zero` really is a function,\n"
"and `?` is the input. In this situation `rw` will look through the goal\n"
"for any subterm of the form `x + 0`, and the moment it\n"
"finds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n"
"\n"
"Exercise: think about why `rw [add_zero]` changes the term\n"
"`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n"
"`0 + (x + 0) + 0 + (x + 0)`\n"
"\n"
"If you can't remember the name of the proof of an equality, look it up in\n"
"the list of lemmas on the right.\n"
"\n"
"## Targetted usage\n"
"\n"
"If your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\n"
"to `c + a`, then `rw [add_comm]` will not work because Lean finds another\n"
"addition first and swaps those inputs instead. Use `rw [add_comm a c]` to\n"
"guarantee that Lean rewrites `a + c` to `c + a`. This works because\n"
"`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\n"
"that `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n"
"\n"
"If `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\n"
"If you only want to change the 37th occurrence of `X`\n"
"to `Y` then do `nth_rewrite 37 [h]`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœ `h` æ˜¯ä¸€ä¸ªç­‰å¼ `X = Y` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šæŠŠç›®æ ‡ä¸­æ‰€æœ‰çš„ `X` æ”¹ä¸º `Y`ã€‚è¿™æ˜¯ä¸€ç§â€œä»£å…¥â€çš„æ–¹"
"å¼ã€‚\n"
"\n"
"## å˜ä½“\n"
"\n"
"* `rw [â† h]`ï¼ˆå°† `Y` æ”¹ä¸º `X`ï¼›é€šè¿‡è¾“å…¥ `\\left ` æˆ– `\\l` è·å–åå‘ç®­å¤´ã€‚ï¼‰\n"
"\n"
"* `rw [h1, h2]`ï¼ˆä¸€ç³»åˆ—é‡å†™ï¼‰\n"
"\n"
"* `rw [h] at h2`ï¼ˆåœ¨å‡è®¾ `h2` ä¸­å°† `X` æ”¹ä¸º `Y`ï¼‰\n"
"\n"
"* `rw [h] at h1 h2 âŠ¢`ï¼ˆåœ¨ä¸¤ä¸ªå‡è®¾å’Œç›®æ ‡ä¸­å°† `X` æ”¹ä¸º `Y`ï¼›é€šè¿‡è¾“å…¥ `\\|-` è·å– `âŠ¢` ç¬¦å·ã€‚ï¼‰\n"
"\n"
"* `repeat rw [add_zero]` å°†ä¼šä¸æ–­åœ°æŠŠ `? + 0` æ”¹ä¸º `?`ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šçš„ `? + 0` åŒ¹é…ä¸ºæ­¢ã€‚\n"
"\n"
"* `nth_rewrite 2 [h]` åªä¼šæŠŠç›®æ ‡ä¸­çš„ç¬¬äºŒä¸ª `X` æ”¹ä¸º `Y`ã€‚\n"
"\n"
"### ç¤ºä¾‹ï¼š\n"
"\n"
"å¦‚æœä½ æœ‰å‡è®¾ `h : x = y + y` å¹¶ä¸”ä½ çš„ç›®æ ‡æ˜¯\n"
"```\n"
"succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"é‚£ä¹ˆ\n"
"\n"
"`rw [add_zero]`\n"
"\n"
"å°†ä¼šæŠŠç›®æ ‡æ”¹ä¸º `succ x = succ (y + y)`ï¼Œç„¶å\n"
"\n"
"`rw [h]`\n"
"\n"
"å°†ä¼šæŠŠç›®æ ‡æ”¹ä¸º `succ (y + y) = succ (y + y)`ï¼Œè¿™ä¸ªå¯ä»¥é€šè¿‡ `rfl` è§£å†³ã€‚\n"
"\n"
"### ç¤ºä¾‹ï¼š\n"
"\n"
"ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ `rw` æ¥æ”¹å˜ä¸€ä¸ªå‡è®¾ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾\n"
"```\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"```\n"
"é‚£ä¹ˆ `rw [h1] at h2` å°†ä¼šæŠŠ `h2` å˜ä¸º `h2 : 2 * y = y + 3`ã€‚\n"
"\n"
"## å¸¸è§é”™è¯¯\n"
"\n"
"* ä½ éœ€è¦æ–¹æ‹¬å·ã€‚`rw h` æ˜¯ä¸æ­£ç¡®çš„ã€‚\n"
"\n"
"* å¦‚æœ `h` ä¸æ˜¯ä¸€ä¸ª*ç­‰å¼*çš„*è¯æ˜*ï¼ˆå½¢å¼ä¸º `A = B` çš„å£°æ˜ï¼‰ï¼Œä¾‹å¦‚å¦‚æœ `h` æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è•´å«ï¼Œé‚£ä¹ˆ `rw` "
"ä¸æ˜¯ä½ æƒ³è¦ä½¿ç”¨çš„ç­–ç•¥ã€‚ä¾‹å¦‚ï¼Œ`rw [P = Q]` æ°¸è¿œä¸æ­£ç¡®ï¼Œ å› ä¸º`P = Q` æ˜¯å®šç†çš„*é™ˆè¿°*ï¼Œè€Œä¸æ˜¯è¯æ˜ã€‚ä½†å¦‚æœ "
"`h : P = Q` æ˜¯è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šèµ·ä½œç”¨ã€‚\n"
"\n"
"## è¯¦æƒ…\n"
"\n"
"`rw` ç­–ç•¥æ˜¯ä¸€ç§è¿›è¡Œâ€œä»£å…¥â€çš„æ–¹å¼ã€‚æœ‰ä¸¤ç§ä¸åŒçš„æƒ…å†µä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªç­–ç•¥ã€‚\n"
"\n"
"1) åŸºæœ¬ä½¿ç”¨ï¼šå¦‚æœ `h : A = B` æ˜¯ä¸€ä¸ªå‡è®¾æˆ–å®šç†çš„è¯æ˜ï¼Œå¹¶ä¸”ç›®æ ‡ä¸­åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ª `A`ï¼Œé‚£ä¹ˆ `rw [h]` ä¼š"
"æŠŠå®ƒä»¬å…¨éƒ¨æ”¹ä¸º `B`ã€‚å¦‚æœç›®æ ‡ä¸­æ²¡æœ‰ `A`ï¼Œç­–ç•¥ä¼šæŠ¥é”™ã€‚\n"
"\n"
"2) é«˜çº§ä½¿ç”¨ï¼šæ¥è‡ªå®šç†è¯æ˜çš„å‡è®¾ç»å¸¸æœ‰ç¼ºå¤±çš„éƒ¨åˆ†ã€‚ä¾‹å¦‚ `add_zero` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `? + 0 = ?`ï¼Œå› ä¸º "
"`add_zero` å®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè€Œ `?` æ˜¯è¾“å…¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`rw` ä¼šåœ¨ç›®æ ‡ä¸­æŸ¥æ‰¾ä»»ä½•å½¢å¼ä¸º `x + 0` çš„å­"
"é¡¹ï¼Œä¸€æ—¦æ‰¾åˆ°ï¼Œå®ƒå°±å°† `?` å®šä½ä¸º `x`ï¼Œç„¶åæŠŠæ‰€æœ‰çš„ `x + 0` æ”¹ä¸º `x`ã€‚\n"
"\n"
"ç»ƒä¹ ï¼šæ€è€ƒä¸ºä»€ä¹ˆ `rw [add_zero]` ä¼šæŠŠé¡¹ `(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` æ”¹ä¸º `0 + (x + 0) + "
"0 + (x + 0)`\n"
"\n"
"å¦‚æœä½ ä¸èƒ½è®°ä½ç­‰å¼è¯æ˜çš„åç§°ï¼Œè¯·åœ¨å³ä¾§çš„å®šç†åˆ—è¡¨ä¸­æŸ¥æ‰¾ã€‚\n"
"\n"
"## é’ˆå¯¹æ€§ä½¿ç”¨\n"
"\n"
"å¦‚æœä½ çš„ç›®æ ‡æ˜¯ `b + c + a = b + (a + c)` å¹¶ä¸”ä½ æƒ³æŠŠ `a + c` é‡å†™ä¸º `c + a`ï¼Œé‚£ä¹ˆ `rw [add_comm]` å°†ä¸"
"èµ·ä½œç”¨ï¼Œå› ä¸º Lean ä¼šå…ˆæ‰¾åˆ°å¦ä¸€ä¸ªåŠ æ³•å¹¶äº¤æ¢å®ƒã€‚ä½¿ç”¨ `rw [add_comm a c]` æ¥ä¿è¯ Lean å°† `a + c` é‡å†™ä¸º "
"`c + a`ã€‚è¿™æ˜¯å› ä¸º `add_comm` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `?1 + ?2 = ?2 + ?1`ï¼Œ`add_comm a` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `a "
"+ ? = ? + a`ï¼Œè€Œ `add_comm a c` æ˜¯å¦ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `a + c = c + a`ã€‚\n"
"\n"
"å¦‚æœ `h : X = Y`ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šæŠŠæ‰€æœ‰çš„ `X` å˜ä¸º `Y`ã€‚å¦‚æœä½ åªæƒ³æ”¹å˜ç¬¬37æ¬¡å‡ºç°çš„ `X` ä¸º `Y`ï¼Œé‚£"
"ä¹ˆå¯ä»¥ä½¿ç”¨ `nth_rewrite 37 [h]`ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`.\n"
"\"\n"
"\n"
"TacticDoc nth_rewrite \"\n"
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""
"## å°ç»“\n"
"\n"
"`repeat t` åå¤åº”ç”¨ç­–ç•¥ `t` åˆ°ç›®æ ‡ä¸Šã€‚è¿™ä¸ªæ˜¯ä¸ªå¯é€‰ç­–ç•¥ï¼Œå®ƒåªæ˜¯æœ‰æ—¶å¯ä»¥èŠ‚çœæ­¥éª¤ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"`repeat rw [add_zero]` ä¼šå°†ç›®æ ‡\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"å˜ä¸º\n"
"`a = b`ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid ""
"## Summary\n"
"\n"
"If `h : X = Y` and there are several `X`s in the goal, then\n"
"`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n"
"\n"
"## Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\n"
"will change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\n"
"will change the goal to `succ 1 + succ 1 = 4`."
msgstr ""
"## å°ç»“\n"
"\n"
"å¦‚æœ `h : X = Y` å¹¶ä¸”åœ¨ç›®æ ‡ä¸­æœ‰å¤šä¸ª `X`ï¼Œé‚£ä¹ˆ `nth_rewrite 3 [h]` å°†ä»…æ›´æ”¹ç¬¬ä¸‰ä¸ª `X` ä¸º `Y`ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœç›®æ ‡æ˜¯ `2 + 2 = 4`ï¼Œé‚£ä¹ˆ `nth_rewrite 2 [two_eq_succ_one]` å°†ç›®æ ‡æ›´æ”¹ä¸º `2 + succ 1 = 4`ã€‚ç›¸æ¯”ä¹‹"
"ä¸‹ï¼Œ`rw [two_eq_succ_one]` å°†ç›®æ ‡æ›´æ”¹ä¸º `succ 1 + succ 1 = 4`ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid ""
"In this level the *goal* is $2y=2(x+7)$ but to help us we\n"
"have an *assumption* `h` saying that $y = x + 7$. Check that you can see `h` in\n"
"your list of assumptions. Lean thinks of `h` as being a secret proof of the\n"
"assumption, rather like `x` is a secret number.\n"
"\n"
"Before we can use `rfl`, we have to \"substitute in for $y$\".\n"
"We do this in Lean by *rewriting* the proof `h`,\n"
"using the `rw` tactic."
msgstr ""
"åœ¨è¿™ä¸ªå…³å¡é‡Œï¼Œ*ç›®æ ‡*æ˜¯è¯æ˜ $2y=2(x+7)$ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€æ¡*å‡è®¾* `h`ï¼Œå®ƒæŒ‡å‡º $y = x + 7$ã€‚è¯·æ£€æŸ¥å‡è®¾åˆ—è¡¨"
"ä¸­æ˜¯å¦åŒ…å«äº† `h`ã€‚åœ¨ Lean ä¸­ï¼Œ`h` è¢«è§†ä¸ºä¸€ç§å‡è®¾å­˜åœ¨çš„è¯æ®ï¼Œè¿™æœ‰ç‚¹åƒ `x` æ˜¯ä¸€ä¸ªæœªçŸ¥çš„å…·ä½“æ•°å€¼ã€‚\n"
"\n"
"è¦æƒ³ä½¿ç”¨ `rfl` å®Œæˆè¯æ˜ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å¯¹ $y$ è¿›è¡Œæ›¿æ¢ã€‚åœ¨ Lean ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡*é‡å†™*è¯æ˜ `h` æ¥å®ç°è¿™"
"ä¸€ç‚¹ï¼Œå³ä½¿ç”¨ `rw` ç­–ç•¥ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "If $x$ and $y$ are natural numbers, and $y = x + 7$, then $2y = 2(x + 7)$."
msgstr "å¦‚æœ $x$ å’Œ $y$ æ˜¯è‡ªç„¶æ•°ï¼Œå¹¶ä¸” $y = x + 7$ï¼Œé‚£ä¹ˆ $2y = 2(x + 7)$ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "First execute `rw [h]` to replace the `y` with `x + 7`."
msgstr "é¦–å…ˆæ‰§è¡Œ `rw [h]` å°† `y` æ›¿æ¢ä¸º `x + 7`ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "Can you take it from here? Click on \"Show more help!\" if you need a hint."
msgstr "ä½ èƒ½ä»è¿™é‡Œå¼€å§‹å—ï¼Ÿå¦‚æœæ‚¨éœ€è¦æç¤ºï¼Œè¯·ç‚¹å‡» \"æ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼\"ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "Now `rfl` will work."
msgstr "ç°åœ¨å¯ä»¥ç”¨ `rfl` äº†ã€‚"

#: Game.Levels.Tutorial.L02rw
msgid "You now know enough tactics to prove `2 + 2 = 4`! Let's begin the journey."
msgstr "ä½ ç°åœ¨å·²ç»å­¦ä¼šäº†è¶³å¤Ÿçš„ç­–ç•¥æ¥è¯æ˜ `2 + 2 = 4`ï¼è®©æˆ‘ä»¬å¼€å§‹è¿™æ®µæ—…ç¨‹å§ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Numbers"
msgstr "æ•°å­—"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"`â„•` is the natural numbers, just called \\\"numbers\\\" in this game. It's\n"
"defined via two rules:\n"
"\n"
"* `0 : â„•` (zero is a number)\n"
"* `succ (n : â„•) : â„•` (the successor of a number is a number)\n"
"\n"
"## Game Implementation\n"
"\n"
"*The game uses its own copy of the natural numbers, called `MyNat` with notation `â„•`.\n"
"It is distinct from the Lean natural numbers `Nat`, which should hopefully\n"
"never leak into the natural number game.*"
msgstr ""
"`â„•` æ˜¯è‡ªç„¶æ•°ï¼Œåœ¨è¿™ä¸ªæ¸¸æˆä¸­ç®€ç§°ä¸ºâ€œæ•°å­—â€ã€‚å®ƒé€šè¿‡ä¸¤æ¡è§„åˆ™å®šä¹‰ï¼š\n"
"\n"
"* `0 : â„•`ï¼ˆé›¶æ˜¯è‡ªç„¶æ•°ï¼‰\n"
"* `succ (n : â„•) : â„•`ï¼ˆè‡ªç„¶æ•°çš„åç»§æ•°æ˜¯è‡ªç„¶æ•°ï¼‰\n"
"\n"
"## æ¸¸æˆå®ç°\n"
"\n"
"*æ¸¸æˆä½¿ç”¨è‡ªå·±é‡æ–°å®šä¹‰çš„è‡ªç„¶æ•°ï¼Œç§°ä¸º `MyNat`ï¼Œæ ‡è®°ä¸º `â„•`ã€‚å®ƒä¸åŒäº Lean è‡ªç„¶æ•° `Nat`ï¼Œåè€…ä¸åº”æ³„éœ²åˆ°è‡ª"
"ç„¶æ•°æ¸¸æˆä¸­ã€‚*"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`one_eq_succ_zero` is a proof of `1 = succ 0`.\""
msgstr "`one_eq_succ_zero` æ˜¯ `1 = succ 0`çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`two_eq_succ_one` is a proof of `2 = succ 1`."
msgstr "`two_eq_succ_one` æ˜¯ `2 = succ 1` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`three_eq_succ_two` is a proof of `3 = succ 2`."
msgstr "`three_eq_succ_two` æ˜¯ `3 = succ 2` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "`four_eq_succ_three` is a proof of `4 = succ 3`."
msgstr "`four_eq_succ_three` æ˜¯ `4 = succ 3` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"## The birth of number.\n"
"\n"
"Numbers in Lean are defined by two rules.\n"
"\n"
"* `0` is a number.\n"
"* If `n` is a number, then the *successor* `succ n` of `n` is a number.\n"
"\n"
"The successor of `n` means the number after `n`. Let's learn to\n"
"count, and name a few small numbers.\n"
"\n"
"## Counting to four.\n"
"\n"
"`0` is a number, so `succ 0` is a number. Let's call this new number `1`.\n"
"Similarly let's define `2 = succ 1`, `3 = succ 2` and `4 = succ 3`.\n"
"This gives us plenty of numbers to be getting along with.\n"
"\n"
"The *proof* that `2 = succ 1` is called `two_eq_succ_one`.\n"
"Check out the \"012\" tab in the list of lemmas on the right\n"
"for this and other proofs.\n"
"\n"
"Let's prove that $2$ is the number after the number after zero."
msgstr ""
"## è‡ªç„¶æ•°çš„å®šä¹‰\n"
"\n"
"åœ¨ Lean ä¸­ï¼Œè‡ªç„¶æ•°çš„å®šä¹‰åŸºäºä¸¤ä¸ªç®€å•çš„è§„åˆ™ï¼š\n"
"\n"
"* `0` è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n"
"* å¦‚æœ `n` æ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ `n` çš„*åç»§æ•°* `succ n` ä¹Ÿæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n"
"\n"
"è¿™é‡Œï¼Œ`n`çš„åç»§æ•°æŒ‡çš„æ˜¯ç´§è·Ÿåœ¨ `n` ä¹‹åçš„è‡ªç„¶æ•°ã€‚è®©æˆ‘ä»¬é€šè¿‡è¿™ç§æ–¹å¼æ¥è®¡æ•°ï¼Œå¹¶ä¸ºä¸€äº›å°æ•°å­—å‘½åã€‚\n"
"\n"
"## è®¡æ•°è‡³å››\n"
"\n"
"ç”±äº `0` æ˜¯è‡ªç„¶æ•°ï¼Œå› æ­¤ `succ 0`ï¼ˆ`0`çš„åç»§æ•°ï¼‰ä¹Ÿæ˜¯è‡ªç„¶æ•°ã€‚æˆ‘ä»¬å°†è¿™ä¸ªæ–°çš„è‡ªç„¶æ•°å‘½åä¸º `1`ã€‚\n"
"åŒæ ·çš„é€»è¾‘ï¼Œæˆ‘ä»¬å®šä¹‰ `2 = succ 1`ã€`3 = succ 2` å’Œ `4 = succ 3`ã€‚\n"
"è¿™æ ·ï¼Œæˆ‘ä»¬å°±æ‹¥æœ‰äº†è¶³å¤Ÿçš„æ•°å­—å»åº”å¯¹æ¥ä¸‹æ¥çš„æŒ‘æˆ˜ã€‚\n"
"\n"
"è¯æ˜ `2 = succ 1` çš„å®šç†è¢«ç§°ä¸º `two_eq_succ_one`ã€‚\n"
"è¯·æŸ¥é˜…å³ä¾§å®šç†åˆ—è¡¨ä¸­çš„â€œ012â€æ ‡ç­¾ï¼Œä»¥äº†è§£è¿™ä¸ªè¯æ˜åŠå…¶ä»–ç›¸å…³çš„è¯æ˜ã€‚\n"
"\n"
"ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥è¯æ˜ $2$ æ˜¯ä»é›¶å¼€å§‹åçš„ç¬¬äºŒä¸ªæ•°å­—ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0 Game.Levels.Tutorial.L04rw_backwards
msgid "$2$ is the number after the number after $0$."
msgstr "$2$ æ˜¯ $0$ ä¹‹åå†ä¹‹åçš„æ•°å­—ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Start with `rw [two_eq_succ_one]` to begin to break `2` down into its definition."
msgstr "ä»ä½¿ç”¨ `rw [two_eq_succ_one]` å¼€å§‹ï¼Œå°† `2` åˆ†è§£ä¸ºå®ƒçš„å®šä¹‰ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Can you take it from here?"
msgstr "ä½ èƒ½ä»è¿™é‡Œæ¥æ‰‹å—ï¼Ÿ"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Next turn `1` into `succ 0` with `rw [one_eq_succ_zero]`."
msgstr "æ¥ä¸‹æ¥ç”¨ `rw [one_eq_succ_zero]` æŠŠ `1` å˜æˆ `succ 0'ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid "Now finish the job with `rfl`."
msgstr "ç°åœ¨ç”¨ `rfl` å®Œæˆè¯æ˜ã€‚"

#: Game.Levels.Tutorial.L03two_eq_ss0
msgid ""
"Note that you can do `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"and then `rfl` to solve this level in two lines."
msgstr ""
"è¯·æ³¨æ„ï¼Œæ‚¨å¯ä»¥å…ˆä½¿ç”¨ `rw [two_eq_succ_one, one_eq_succ_zero]`\n"
"ç„¶åå†ç”¨ `rfl` æ¥å¿«é€Ÿé€šè¿‡è¿™å…³ã€‚"

#: Game.Levels.Tutorial.L04rw_backwards
msgid "rewriting backwards"
msgstr "é€†å‘é‡å†™"

#: Game.Levels.Tutorial.L04rw_backwards
msgid ""
"If `h` is a proof of `X = Y` then `rw [h]` will\n"
"turn `X`s into `Y`s. But what if we want to\n"
"turn `Y`s into `X`s? To tell the `rw` tactic\n"
"we want this, we use a left arrow `â†`. Type\n"
"`\\l` and then hit the space bar to get this arrow.\n"
"\n"
"Let's prove that $2$ is the number after the number\n"
"after $0$ again, this time by changing `succ (succ 0)`\n"
"into `2`."
msgstr ""
"å¦‚æœ `h` æ˜¯ `X = Y` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†\n"
" `X` è½¬æ¢ä¸º `Y`sã€‚ä½†å¦‚æœæˆ‘ä»¬æƒ³è¦\n"
"å°† `Y`s è½¬æ¢ä¸º `X`sæ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬ä½¿ç”¨å·¦ç®­å¤´ `â†` æ¥å‘Šè¯‰`rw`ç­–ç•¥\n"
"æˆ‘ä»¬æƒ³è¦è¿™ä¸ªã€‚è¾“å…¥\n"
"`\\l` ç„¶åæŒ‰ç©ºæ ¼é”®æ¥è¾“å…¥è¿™ä¸ªç®­å¤´ã€‚\n"
"\n"
"æˆ‘ä»¬æ¥è¯æ˜ä¸€ä¸‹ $2$ å°±æ˜¯ $0$ ä¹‹åå†ä¹‹åçš„æ•°å­—ã€‚è¯·å°†`succ (succ 0)`\n"
"é‡å†™ä¸º `2`ã€‚"

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Try `rw [â† one_eq_succ_zero]` to change `succ 0` into `1`."
msgstr "å°è¯•ç”¨ `rw [â† one_eq_succ_zero]` å°† `succ 0` æ”¹ä¸º `1`ã€‚"

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Can you now change the goal into `2 = 2`?"
msgstr "ä½ ç°åœ¨èƒ½å°†ç›®æ ‡æ”¹ä¸º \"2 = 2 \"å—ï¼Ÿ"

#: Game.Levels.Tutorial.L04rw_backwards
msgid "Now `rw [â† two_eq_succ_one]` will change `succ 1` into `2`."
msgstr "ç°åœ¨ `rw [â† two_eq_succ_one]` ä¼šæŠŠ `succ 1` æ”¹ä¸º `2`ã€‚"

#: Game.Levels.Tutorial.L04rw_backwards
msgid ""
"Why did we not just define `succ n` to be `n + 1`? Because we have not\n"
"even *defined* addition yet! We'll do that in the next level."
msgstr ""
"ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸ç›´æ¥å°† `succ n` å®šä¹‰ä¸º `n + 1`ï¼Ÿå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰\n"
" *å®šä¹‰* åŠ æ³•ï¼æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€å…³åšåˆ°è¿™ä¸€ç‚¹ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid "Adding zero"
msgstr "åŠ é›¶"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"`Add a b`, with notation `a + b`, is\n"
"the usual sum of natural numbers. Internally it is defined\n"
"via the following two hypotheses:\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"Other theorems about naturals, such as `zero_add a : 0 + a = a`, are proved\n"
"by induction using these two basic theorems.\""
msgstr ""
"`Add a b`ï¼Œç¬¦å·ä¸º `a + b`ï¼Œæ˜¯\n"
"è‡ªç„¶æ•°ä¹‹å’Œã€‚\n"
"é€šè¿‡ä»¥ä¸‹ä¸¤ä¸ªå‡è®¾å®šä¹‰ï¼š\n"
"\n"
"* `add_zero a : a + 0 = a`\n"
"\n"
"* `add_succ a b : a + succ b = succ (a + b)`\n"
"\n"
"å…¶ä»–å…³äºè‡ªç„¶æ•°çš„å®šç†ï¼Œä¾‹å¦‚ `zero_add a : 0 + a = a`ï¼Œä¹Ÿ\n"
"é€šè¿‡æ•°å­¦å½’çº³æ³•ä½¿ç”¨è¿™ä¸¤ä¸ªåŸºæœ¬å®šä¹‰è¿›è¡Œè¯æ˜ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"`add_zero a` is a proof that `a + 0 = a`.\n"
"\n"
"## Summary\n"
"\n"
"`add_zero` is really a function, which\n"
"eats a number, and returns a proof of a theorem\n"
"about that number. For example `add_zero 37` is\n"
"a proof that `37 + 0 = 37`.\n"
"\n"
"The `rw` tactic will accept `rw [add_zero]`\n"
"and will try to figure out which number you omitted\n"
"to input.\n"
"\n"
"## Details\n"
"\n"
"A mathematician sometimes thinks of `add_zero`\n"
"as \\\"one thing\\\", namely a proof of $\\forall n âˆˆ â„•, n + 0 = n$.\n"
"This is just another way of saying that it's a function which\n"
"can eat any number n and will return a proof that `n + 0 = n`."
msgstr ""
"`add_zero a` æ˜¯ `a + 0 = a` çš„è¯æ˜ã€‚\n"
"\n"
"## å°ç»“\n"
"\n"
"`add_zero` å®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªæ•°å­—ï¼Œå¹¶è¿”å›å…³äºé‚£ä¸ªæ•°å­—çš„å®šç†çš„è¯æ˜ã€‚ä¾‹å¦‚ï¼Œ`add_zero 37` æ˜¯ "
"`37 + 0 = 37` çš„è¯æ˜ã€‚\n"
"\n"
"`rw` ç­–ç•¥ä¼šæ¥å— `rw [add_zero]` å¹¶å°è¯•æ¨æ–­å‡ºä½ çœç•¥è¾“å…¥çš„æ•°å­—ã€‚\n"
"\n"
"## ç»†èŠ‚\n"
"\n"
"æ•°å­¦å®¶æœ‰æ—¶å°† `add_zero` è§†ä¸ºâ€œä¸€ä¸ªä¸œè¥¿â€ï¼Œå³ $âˆ€ n âˆˆ â„•, n + 0 = n$ çš„è¯æ˜ã€‚è¿™åªæ˜¯å¦ä¸€ç§è¯´æ³•ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡½"
"æ•°ï¼Œå¯ä»¥æ¥å—ä»»ä½•æ•°å­— n å¹¶è¿”å› `n + 0 = n` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"## Summary\n"
"\n"
"`repeat t` repeatedly applies the tactic `t`\n"
"to the goal. You don't need to use this\n"
"tactic, it just speeds things up sometimes.\n"
"\n"
"## Example\n"
"\n"
"`repeat rw [add_zero]` will turn the goal\n"
"`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\n"
"into the goal\n"
"`a = b`."
msgstr ""
"## å°ç»“\n"
"\n"
"`repeat t` ä¼šé‡å¤åº”ç”¨ç­–ç•¥ `t` åˆ°ç›®æ ‡ä¸Šã€‚ä½ ä¸ä¸€å®šè¦ä½¿ç”¨è¿™ä¸ªç­–ç•¥ï¼Œå®ƒæœ‰æ—¶åªæ˜¯åŠ å¿«äº†é€Ÿåº¦ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"`repeat rw [add_zero]` ä¼šå°†ç›®æ ‡ `a + 0 + (0 + (0 + 0)) = b + 0 + 0` è½¬å˜ä¸ºç›®æ ‡ `a = b`ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"We'd like to prove `2 + 2 = 4` but right now\n"
"we can't even *state* it\n"
"because we haven't yet defined addition.\n"
"\n"
"## Defining addition.\n"
"\n"
"How are we going to add $37$ to an arbitrary number $x$? Well,\n"
"there are only two ways to make numbers in this game: $0$\n"
"and successors. So to define `37 + x` we will need\n"
"to know what `37 + 0` is and what `37 + succ x` is.\n"
"Let's start with adding `0`.\n"
"\n"
"### Adding 0\n"
"\n"
"To make addition agree with our intuition, we should *define* `37 + 0`\n"
"to be `37`. More generally, we should define `a + 0` to be `a` for\n"
"any number `a`. The name of this proof in Lean is `add_zero a`.\n"
"For example `add_zero 37` is a proof of `37 + 0 = 37`,\n"
"`add_zero x` is a proof of `x + 0 = x`, and `add_zero` is a proof\n"
"of `? + 0 = ?`.\n"
"\n"
"We write `add_zero x : x + 0 = x`, so `proof : statement`."
msgstr ""
"æˆ‘ä»¬æ­£å¯»æ±‚è¯æ˜ `2 + 2 = 4`ï¼Œä½†ç›®å‰æˆ‘ä»¬è¿*è¡¨è¿°*å®ƒéƒ½åšä¸åˆ°ï¼Œå› ä¸ºåŠ æ³•å°šæœªè¢«å®šä¹‰ã€‚\n"
"\n"
"## åŠ æ³•çš„å®šä¹‰\n"
"\n"
"å¦‚ä½•å®ç°å°†ä»»æ„æ•°å­— $x$ åŠ åˆ° $37$ ä¸Šå‘¢ï¼Ÿåœ¨è¿™ä¸ªæ¸¸æˆé‡Œï¼Œæˆ‘ä»¬åªæœ‰ä¸¤ç§æ–¹å¼ç”Ÿæˆæ•°å­—ï¼š$0$ å’Œåç»§æ•°ã€‚å› æ­¤ï¼Œä¸º"
"äº†å®šä¹‰ `37 + x`ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç™½ `37 + 0` å’Œ `37 + succ x` åˆ†åˆ«æ˜¯ä»€ä¹ˆã€‚å…ˆä»åŠ  `0` çš„æƒ…å†µå¼€å§‹æ¢ç´¢ã€‚\n"
"\n"
"### åŠ  0\n"
"\n"
"ä¸ºäº†è®©åŠ æ³•æ“ä½œç¬¦åˆç›´è§‰ï¼Œæˆ‘ä»¬åº”å½“*å®šä¹‰* `37 + 0` ä¸º `37`ã€‚æ›´å¹¿æ³›æ¥è¯´ï¼Œå¯¹äºä»»ä½•æ•°å­— `a`ï¼Œæˆ‘ä»¬å®šä¹‰ `a + "
"0` åº”ç­‰äº `a`ã€‚åœ¨ Lean ä¸­ï¼Œä»è¿™ä¸ªå®šä¹‰ç›´æ¥è¡ç”Ÿå‡ºçš„å®šç†è¢«å‘½åä¸º `add_zero a`ã€‚æ¯”å¦‚ï¼Œ`add_zero 37` è¯æ˜"
"äº† `37 + 0 = 37`ï¼Œ`add_zero x` è¯æ˜äº† `x + 0 = x`ï¼Œè€Œ `add_zero` åˆ™è¯æ˜äº† `? + 0 = ?`ã€‚\n"
"\n"
"æˆ‘ä»¬å°†å®šç†è®°ä½œ `add_zero x : x + 0 = x`ï¼Œå…¶ä¸­å®šç†çš„åç§°ä½äºå‰é¢ï¼Œè€Œå®šç†çš„è¡¨è¿°åˆ™ä½äºåé¢ã€‚è¿™å’Œä¹‹å‰åœ¨*"
"å‡è®¾*ä¸­çš„è®°æ³•å¾ˆåƒã€‚"

#: Game.Levels.Tutorial.L05add_zero Game.Levels.Tutorial.L06add_zero2
msgid "$a+(b+0)+(c+0)=a+b+c.$"
msgstr "$a+(b+0)+(c+0)=a+b+c$ ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid "`rw [add_zero]` will change `b + 0` into `b`."
msgstr "`rw [add_zero]` ä¼šæŠŠ `b + 0` æ”¹ä¸º `b`ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid "Now `rw [add_zero]` will change `c + 0` into `c`."
msgstr "ç°åœ¨ï¼Œ`rw [add_zero]` ä¼šæŠŠ `c + 0` æ”¹ä¸º `c`ã€‚"

#: Game.Levels.Tutorial.L05add_zero
msgid ""
"Those of you interested in speedrunning the game may want to know\n"
"that `repeat rw [add_zero]` will do both rewrites at once."
msgstr ""
"å¯¹äºé‚£äº›å¯¹å¿«é€Ÿé€šå…³æ¸¸æˆæ„Ÿå…´è¶£çš„ç©å®¶ï¼Œä¸€ä¸ªå°æŠ€å·§æ˜¯ä½¿ç”¨ `repeat rw [add_zero]` å¯ä»¥ä¸€æ¬¡æ€§å®Œæˆä¸¤æ¬¡é‡å†™æ“"
"ä½œã€‚"

#: Game.Levels.Tutorial.L06add_zero2
msgid "Precision rewriting"
msgstr "ç²¾å‡†é‡å†™"

#: Game.Levels.Tutorial.L06add_zero2
msgid ""
"## Precision rewriting\n"
"\n"
"In the last level, there was `b + 0` and `c + 0`,\n"
"and `rw [add_zero]` changed the first one it saw,\n"
"which was `b + 0`. Let's learn how to tell Lean\n"
"to change `c + 0` first by giving `add_zero` an\n"
"explicit input."
msgstr ""
"## ç²¾å‡†é‡å†™\n"
"\n"
"åœ¨ä¸Šä¸€ä¸ªå…³å¡ä¸­ï¼Œæœ‰ `b + 0` å’Œ `c + 0`ï¼Œ\n"
"è€Œ `rw [add_zero]` æ”¹å˜äº†å®ƒçœ‹åˆ°çš„ç¬¬ä¸€ä¸ªåŠ 0ï¼Œ\n"
"ä¹Ÿå°±æ˜¯ `b + 0`ã€‚è®©æˆ‘ä»¬å­¦ä¹ å¦‚ä½•å‘Šè¯‰ Lean\n"
"é€šè¿‡ç»™ `add_zero` ä¸€ä¸ªæ˜ç¡®çš„è¾“å…¥æ¥é¦–å…ˆæ”¹å˜ `c + 0`ã€‚"

#: Game.Levels.Tutorial.L06add_zero2
msgid "Try `rw [add_zero c]`."
msgstr "å°è¯•ä½¿ç”¨ `rw [add_zero c]`ã€‚"

#: Game.Levels.Tutorial.L06add_zero2
msgid ""
"`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\n"
"You can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\n"
"can usually stick to `rw [add_zero]` unless you need real precision."
msgstr ""
"`add_zero c` æ˜¯ `c + 0 = c` çš„è¯æ˜ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥æ”¹å†™ç›®æ ‡äº†ã€‚ç°åœ¨ä½ å¯ä»¥ç”¨ `rw [add_zero]` æˆ– `rw "
"[add_zero b]` æŠŠ `b + 0` æ”¹æˆ `b`ã€‚æ‚¨é€šå¸¸å¯ä»¥ä½¿ç”¨ `rw [add_zero]`ï¼Œé™¤éä½ éœ€è¦ç²¾å‡†æ§åˆ¶æ”¹å†™çš„å†…å®¹ã€‚"

#: Game.Levels.Tutorial.L06add_zero2
msgid "Let's now learn about Peano's second axiom for addition, `add_succ`."
msgstr "ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å­¦ä¹ çš®äºšè¯ºåŠ æ³•çš„ç¬¬äºŒæ¡å…¬ç†â€”â€”`add_succ`ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "add_succ"
msgstr "add_succ"

#: Game.Levels.Tutorial.L07add_succ
msgid "`add_succ a b` is the proof of `a + succ b = succ (a + b)`."
msgstr "`add_succ a b` æ˜¯ `a + succ b = succ (a + b)` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "`succ_eq_add_one n` is the proof that `succ n = n + 1`."
msgstr "`succ_eq_add_one n` æ˜¯ `succ n = n + 1` çš„è¯æ˜ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid ""
"Every number in Lean is either $0$ or a successor. We know how to add $0$,\n"
"but we need to figure out how to add successors. Let's say we already know\n"
"that `37 + d = q`. What should the answer to `37 + succ d` be? Well,\n"
"`succ d` is one bigger than `d`, so `37 + succ d` should be `succ q`,\n"
"the number one bigger than `q`. More generally `x + succ d` should\n"
"be `succ (x + d)`. Let's add this as a lemma.\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"If you ever see `... + succ ...` in your goal, `rw [add_succ]` is\n"
"normally a good idea.\n"
"\n"
"Let's now prove that `succ n = n + 1`. Figure out how to get `+ succ` into\n"
"the picture, and then `rw [add_succ]`. Switch between the `+` (addition) and\n"
"`012` (numerals) tabs under \"Theorems\" on the right to\n"
"see which proofs you can rewrite."
msgstr ""
"Lean ä¸­çš„æ¯ä¸ªæ•°å­—è¦ä¹ˆæ˜¯ $0$ è¦ä¹ˆæ˜¯åç»§æ•°ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•åŠ  $0$ï¼Œ\n"
"æˆ‘ä»¬è¿˜éœ€è¦å¼„æ¸…æ¥šå¦‚ä½•æ·»åŠ åç»§æ•°ã€‚å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“\n"
"`37 + d = q`ã€‚ `37 + succ d` çš„ç­”æ¡ˆåº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ\n"
"`succ d` æ¯” `d` å¤§1ï¼Œå› æ­¤ `37 + succ d` åº”è¯¥æ˜¯ `succ q`ï¼Œ\n"
"ä¹Ÿå°±æ˜¯æ¯” `q` å¤§1ã€‚æ›´ä¸€èˆ¬åœ°è¯´ï¼Œ`x + succ d` åº”è¯¥\n"
"ä¸º `succ (x + d)`ã€‚è®©æˆ‘ä»¬å°†å…¶æ·»åŠ ä¸ºå®šç†ã€‚\n"
"\n"
"* `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"å¦‚æœæ‚¨åœ¨è¯æ˜ç›®æ ‡ä¸­çœ‹åˆ° `... + succ ...`ï¼Œé‚£ä¹ˆç”¨ `rw [add_succ]` æ”¹å†™\n"
"é€šå¸¸æ˜¯ä¸ªå¥½ä¸»æ„ã€‚\n"
"\n"
"ç°åœ¨è®©æˆ‘ä»¬è¯æ˜ `succ n = n + 1`ã€‚å¼„æ¸…æ¥šå¦‚ä½•å¼•å…¥ `+ succ` \n"
"ï¼Œç„¶åå† `rw [add_succ]`ã€‚åœ¨å³ä¾§â€œå®šç†â€ä¸‹çš„ `+`ï¼ˆåŠ æ³•ï¼‰å’Œ\n"
" `012`ï¼ˆæ•°å­—ï¼‰é€‰é¡¹å¡é‡Œ\n"
"çœ‹çœ‹ä½ å¯ä»¥ç”¨å“ªäº›è¯æ˜é‡å†™ç›®æ ‡ã€‚\n"
"\n"
"åœ¨ Lean ä¸­ï¼Œæ¯ä¸ªæ•°å­—è¦ä¹ˆæ˜¯ $0$ï¼Œè¦ä¹ˆæ˜¯æŸä¸ªæ•°å­—çš„åç»§æ•°ã€‚æˆ‘ä»¬å·²ç»æŒæ¡äº†å¦‚ä½•åŠ ä¸Š $0$ï¼Œä¸‹ä¸€æ­¥éœ€è¦æ˜ç™½å¦‚"
"ä½•åŠ ä¸Šåç»§æ•°ã€‚è®¾æƒ³æˆ‘ä»¬å·²ç»çŸ¥é“ `37 + d = q`ã€‚é‚£ä¹ˆ `37 + succ d` åº”è¯¥æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿç”±äº `succ d` æ¯” `d` "
"å¤š $1$ï¼Œæ‰€ä»¥ `37 + succ d` åº”è¯¥ç­‰äº `succ q`ï¼Œä¹Ÿå°±æ˜¯ `q` åŠ  $1$ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œ`x + succ d` åº”ç­‰äº `succ "
"(x + d)`ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ªè§„åˆ™åŠ ä¸ºä¸€ä¸ªå¼•ç†ï¼š\n"
"\n"
"- `add_succ x d : x + succ d = succ (x + d)`\n"
"\n"
"å½“ä½ åœ¨è¯æ˜ç›®æ ‡ä¸­é‡åˆ° `... + succ ...` å½¢å¼æ—¶ï¼Œä½¿ç”¨ `rw [add_succ]` æ¥é‡å†™é€šå¸¸æ˜¯ä¸€ä¸ªå¥½ç­–ç•¥ã€‚\n"
"\n"
"ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥è¯æ˜ `succ n = n + 1`ã€‚æ€è€ƒå¦‚ä½•å…ˆå¼•å…¥ `+ succ` å½¢å¼ï¼Œç„¶åå†åº”ç”¨ `rw [add_succ]` ç­–ç•¥ã€‚"
"è¯·åœ¨å³ä¾§â€œå®šç†â€éƒ¨åˆ†çš„ `+`ï¼ˆä»£è¡¨åŠ æ³•ï¼‰å’Œ `012`ï¼ˆä»£è¡¨æ•°å­—ï¼‰æ ‡ç­¾é¡µä¸­æŸ¥æ‰¾å¯ä»¥ç”¨æ¥é‡å†™ç›®æ ‡çš„å®šç†ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "For all natural numbers $a$, we have $\\operatorname{succ}(a) = a+1$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ï¼Œæˆ‘ä»¬æœ‰ $\\operatorname{succ}(a) = a+1$ ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "Start by unravelling the `1`."
msgstr "ä»å±•å¼€ \"1 \"å¼€å§‹ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "`rw [one_eq_succ_zero]` will do this."
msgstr "`rw [one_eq_succ_zero]` èƒ½è¿™æ ·åšã€‚"

#: Game.Levels.Tutorial.L07add_succ Game.Levels.Tutorial.L08twoaddtwo
msgid "Now you can `rw [add_succ]`"
msgstr "ç°åœ¨ï¼Œæ‚¨å¯ä»¥ `rw [add_succ]`"

#: Game.Levels.Tutorial.L07add_succ
msgid "And now `rw [add_zero]`"
msgstr "ç°åœ¨ä½¿ç”¨`rw [add_zero]`"

#: Game.Levels.Tutorial.L07add_succ
msgid "And finally `rfl`."
msgstr "æœ€åæ˜¯ `rfl`ã€‚"

#: Game.Levels.Tutorial.L07add_succ
msgid "[dramatic music]. Now are you ready to face the first boss of the game?"
msgstr "ã€èƒŒæ™¯éŸ³ä¹ã€‘ç°åœ¨ä½ å‡†å¤‡å¥½é¢å¯¹æ¸¸æˆé‡Œçš„ç¬¬ä¸€ä¸ªbossäº†å—ï¼Ÿ"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "2+2=4"
msgstr "2+2=4"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid ""
"Good luck!\n"
"\n"
"  One last hint. If `h : X = Y` then `rw [h]` will change *all* `X`s into `Y`s.\n"
"  If you only want to change one of them, say the 3rd one, then use\n"
"  `nth_rewrite 3 [h]`."
msgstr ""
"ç¥ä½ å¥½è¿ï¼\n"
"\n"
"æœ€åä¸€ä¸ªæç¤ºã€‚å¦‚æœ `h : X = Y`ï¼Œé‚£ä¹ˆ `rw [h]` ä¼šå°† *æ‰€æœ‰* çš„ `X` æ›¿æ¢ä¸º `Y`ã€‚å¦‚æœä½ åªæƒ³æ›¿æ¢å…¶ä¸­ä¸€ä¸ªï¼Œ"
"æ¯”å¦‚ç¬¬ 3 ä¸ªï¼Œé‚£ä¹ˆè¯·ä½¿ç”¨ `nth_rewrite 3 [h]`ã€‚"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "$2+2=4$."
msgstr "$2+2=4$ã€‚"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid "`nth_rewrite 2 [two_eq_succ_one]` is I think quicker than `rw [two_eq_succ_one]`."
msgstr "æˆ‘è®¤ä¸º `nth_rewrite 2 [two_eq_succ_one]` æ¯” `rw [two_eq_succ_one]` æ›´å¿«ã€‚"

#: Game.Levels.Tutorial.L08twoaddtwo
msgid ""
"Here is an example proof of 2+2=4 showing off various techniques.\n"
"\n"
"```lean\n"
"nth_rewrite 2 [two_eq_succ_one] -- only change the second `2` to `succ 1`.\n"
"rw [add_succ]\n"
"rw [one_eq_succ_zero]\n"
"rw [add_succ, add_zero] -- two rewrites at once\n"
"rw [â† three_eq_succ_two] -- change `succ 2` to `3`\n"
"rw [â† four_eq_succ_three]\n"
"rfl\n"
"```\n"
"\n"
"Optional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\n"
"on the `</>` button in the top right. You can now see your proof\n"
"written as several lines of code. Move your cursor between lines to see\n"
"the goal state at any point. Now cut and paste your code elsewhere if you\n"
"want to save it, and paste the above proof in instead. Move your cursor\n"
"around to investigate. When you've finished, click the `>_` button in the top right to\n"
"move back into \"Typewriter mode\".\n"
"\n"
"You have finished tutorial world!\n"
"Click \"Leave World\" to go back to the\n"
"overworld, and select Addition World, where you will learn\n"
"about the `induction` tactic."
msgstr ""
"ä¸‹é¢æ˜¯ä¸€ä¸ªè¯æ˜ 2+2=4 çš„ä¾‹å­ï¼Œå±•ç¤ºäº†å„ç§æŠ€å·§ã€‚\n"
"\n"
"```lean\n"
"nth_rewrite 2 [two_eq_succ_one] -- åªå°†ç¬¬äºŒä¸ª `2 ` æ”¹ä¸º `succ 1` ã€‚\n"
"rw [add_succï¼½\n"
"rw [one_eq_succ_zero]\n"
"rw [add_succ, add_zero] -- ä¸€æ¬¡æ”¹å†™ä¸¤ä¸ªå†…å®¹\n"
"rw [â† three_eq_succ_two] -- å°† `succ 2` æ”¹ä¸º `3`\n"
"rw [â† four_eq_succ_three] ã€‚\n"
"rfl\n"
"```\n"
"\n"
"å¯é€‰é™„åŠ åŠŸèƒ½ï¼šä½ å¯ä»¥è‡ªå·±è¿è¡Œè¿™ä¸ªè¯æ˜ã€‚ç‚¹å‡»å³ä¸Šè§’çš„\n"
"å³ä¸Šè§’çš„ `</>` æŒ‰é’®ï¼Œå°†æ¸¸æˆåˆ‡æ¢åˆ° \"ç¼–è¾‘å™¨æ¨¡å¼\"ã€‚ç°åœ¨ä½ å¯ä»¥çœ‹åˆ°ä½ çš„è¯æ˜\n"
"è¢«å†™æˆäº†å‡ è¡Œä»£ç ã€‚åœ¨å„è¡Œä»£ç ä¹‹é—´ç§»åŠ¨å…‰æ ‡ï¼Œå³å¯æŸ¥çœ‹\n"
"ç›®æ ‡çŠ¶æ€ã€‚ç°åœ¨ï¼Œå¦‚æœæƒ³ä¿å­˜ä»£ç ï¼Œä½ å°±è¦å°†ä»£ç å‰ªåˆ‡å¹¶ç²˜è´´åˆ°å…¶ä»–åœ°æ–¹\n"
"ï¼Œè¯·å°†ä¸Šè¿°è¯æ˜ç²˜è´´è¿›å»ã€‚ç§»åŠ¨å…‰æ ‡\n"
"è¿›è¡Œç ”ç©¶ã€‚å®Œæˆåï¼Œç‚¹å‡»å³ä¸Šè§’çš„ `>_` æŒ‰é’®ï¼Œå›åˆ° \"æ‰“å­—æœºæ¨¡å¼\"ã€‚\n"
"å›åˆ° \"æ‰“å­—æœºæ¨¡å¼\"ã€‚\n"
"\n"
"æ‚¨å·²ç»å®Œæˆäº† \"æ•™ç¨‹ä¸–ç•Œ\"ï¼\n"
"ç‚¹å‡» \"ç¦»å¼€ä¸–ç•Œ \"å›åˆ°ä¸–ç•Œé€‰æ‹©ç•Œé¢\n"
"é€‰æ‹© \"åŠ æ³•ä¸–ç•Œ\"ï¼Œåœ¨è¿™é‡Œæ‚¨å°†å­¦ä¹ \n"
"`induction ` ç­–ç•¥ã€‚"

#: Game.Levels.Tutorial
msgid "Tutorial World"
msgstr "æ•™ç¨‹ä¸–ç•Œ"

#: Game.Levels.Tutorial
msgid ""
"Welcome to tutorial world! In this world we learn the basics\n"
"of proving theorems. The boss level of this world\n"
"is the theorem `2 + 2 = 4`.\n"
"\n"
"You prove theorems by solving puzzles using tools called *tactics*.\n"
"The aim is to prove the theorem by applying tactics\n"
"in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below\n"
"to begin your quest."
msgstr ""
"æ¬¢è¿è¿›å…¥æ•™ç¨‹ä¸–ç•Œï¼åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æŒæ¡è¯æ˜å®šç†çš„åˆæ­¥æŠ€èƒ½ã€‚è¿™ä¸ªä¸–ç•Œä¸­çš„ç»ˆææŒ‘æˆ˜æ˜¯è¯æ˜ `2 + 2 = 4` è¿™ä¸€å®š"
"ç†ã€‚\n"
"\n"
"è§£å†³è¿™äº›è°œé¢˜å¹¶è¯æ˜å®šç†çš„è¿‡ç¨‹ä¸­ï¼Œä½ å°†ä½¿ç”¨ä¸€ç§åä¸º*ç­–ç•¥*çš„å¼ºå¤§å·¥å…·ã€‚è¯æ˜å®šç†çš„å…³é”®åœ¨äºå‡†ç¡®åœ°åº”ç”¨è¿™äº›ç­–"
"ç•¥ã€‚\n"
"\n"
"ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹å­¦ä¹ ä¸€äº›åŸºæœ¬ç­–ç•¥å§ã€‚è¯·ç‚¹å‡»ä¸‹é¢çš„â€œå¼€å§‹â€æŒ‰é’®ï¼Œå¼€å¯ä½ çš„è¯æ˜ä¹‹æ—…ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid "zero_add"
msgstr "zero_add"

#: Game.Levels.Addition.L01zero_add
msgid ""
"In this level we're going to prove that $0+n=n$, where $n$ is a secret natural number.\n"
"\n"
"Wait, don't we already know that? No! We know that $n+0=n$, but that's `add_zero`.\n"
"This is `zero_add`, which is different.\n"
"\n"
"The difficulty with proving `0 + n = n` is that we do not have a *formula* for\n"
"`0 + n` in general, we can only use `add_zero` and `add_succ` once\n"
"we know whether `n` is `0` or a successor. The `induction` tactic splits into these two cases.\n"
"\n"
"The base case will require us to prove `0 + 0 = 0`, and the inductive step\n"
"will ask us to show that if `0 + d = d` then `0 + succ d = succ d`. Because\n"
"`0` and successor are the only way to make numbers, this will cover all the cases.\n"
"\n"
"See if you can do your first induction proof in Lean.\n"
"\n"
"(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\n"
"back to \"Typewriter mode\" by clicking the `>_` button in the top right.)"
msgstr ""
"åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ $0+n=n$ï¼Œå…¶ä¸­ $n$ æ˜¯ä¸€ä¸ªæœªçŸ¥çš„è‡ªç„¶æ•°ã€‚\n"
"\n"
"ç­‰ç­‰ï¼Œæˆ‘ä»¬ä¸æ˜¯å·²ç»çŸ¥é“è¿™ä¸ªäº†å—ï¼Ÿä¸ï¼æˆ‘ä»¬çŸ¥é“çš„æ˜¯ $n+0=n$ï¼Œä½†é‚£æ˜¯ `add_zero`ã€‚è¿™é‡Œçš„ `zero_add` æ˜¯ä¸åŒ"
"çš„ã€‚\n"
"\n"
"è¯æ˜ `0 + n = n` çš„éš¾ç‚¹åœ¨äºæˆ‘ä»¬æ²¡æœ‰ä¸€ä¸ªä¸€èˆ¬çš„*å…¬å¼*æ¥è¡¨ç¤º `0 + n`ï¼Œæˆ‘ä»¬åªèƒ½åœ¨çŸ¥é“ `n` æ˜¯ `0` è¿˜æ˜¯åç»§"
"æ•°åï¼Œä½¿ç”¨ `add_zero` å’Œ `add_succ`ã€‚`induction` ï¼ˆå½’çº³ï¼‰ç­–ç•¥ä¼šæŠŠç›®æ ‡åˆ†è§£æˆè¿™ä¸¤ç§æƒ…å†µã€‚\n"
"\n"
"åŸºç¡€æƒ…å†µå°†è¦æ±‚æˆ‘ä»¬è¯æ˜ `0 + 0 = 0`ï¼Œå½’çº³æ­¥éª¤å°†è¦æ±‚æˆ‘ä»¬è¯æ˜å¦‚æœ `0 + d = d` é‚£ä¹ˆ `0 + succ d = succ "
"d`ã€‚å› ä¸º `0` å’Œåç»§æ•°æ˜¯æ„é€ æ•°å­—çš„å”¯ä¸€æ–¹å¼ï¼Œè¿™å°†æ¶µç›–æ‰€æœ‰æƒ…å†µã€‚\n"
"\n"
"çœ‹çœ‹ä½ æ˜¯å¦èƒ½åœ¨ Lean ä¸­å®Œæˆä½ çš„ç¬¬ä¸€ä¸ªå½’çº³è¯æ˜ã€‚\n"
"\n"
"(é¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœä½ è¿˜åœ¨ä¸Šä¸€ä¸ªä¸–ç•Œçš„ \"ç¼–è¾‘å™¨æ¨¡å¼ \"ä¸‹ï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡» \"ç¼–è¾‘å™¨æ¨¡å¼ \"ä¸‹çš„\n"
"ç‚¹å‡»å³ä¸Šè§’çš„ `>_` æŒ‰é’®æ¢å› \"æ¨¡å¼\"ï¼‰ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"`zero_add x` is the proof of `0 + x = x`.\n"
"\n"
"`zero_add` is a `simp` lemma, because replacing `0 + x` by `x`\n"
"is almost always what you want to do if you're simplifying an expression."
msgstr ""
"`zero_add x` æ˜¯ `0 + x = x` çš„è¯æ˜ã€‚\n"
"\n"
"`zero_add` æ˜¯ä¸€ä¸ªæœ‰ `simp` æ ‡è®°çš„å¼•ç†ï¼Œå› ä¸ºå¦‚æœä½ æ­£åœ¨ç®€åŒ–ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå‡ ä¹æ€»æ˜¯æƒ³è¦å°† `0 + x` æ›¿æ¢ä¸º "
"`x`ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid "For all natural numbers $n$, we have $0 + n = n$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $n$ï¼Œæˆ‘ä»¬æœ‰ $0 + n = n$ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"You can start a proof by induction on `n` by typing:\n"
"`induction n with d hd`."
msgstr ""
"ä½ å¯ä»¥é€šè¿‡è¾“å…¥ä»¥ä¸‹å†…å®¹æ¥å¼€å§‹å¯¹ `n` è¿›è¡Œå½’çº³è¯æ˜ï¼š\n"
"`induction n with d hd`ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"Now you have two goals. Once you proved the first, you will jump to the second one.\n"
"This first goal is the base case $n = 0$.\n"
"\n"
"Recall that you can rewrite the proof of any lemma which is visible\n"
"in your inventory, or of any assumption displayed above the goal,\n"
"as long as it is of the form `X = Y`."
msgstr ""
"ç°åœ¨ä½ æœ‰ä¸¤ä¸ªç›®æ ‡ã€‚ä¸€æ—¦ä½ è¯æ˜äº†ç¬¬ä¸€ä¸ªï¼Œä½ ä¼šè‡ªåŠ¨è·³åˆ°ç¬¬äºŒä¸ªã€‚\n"
"ç¬¬ä¸€ä¸ªç›®æ ‡æ˜¯åŸºç¡€æƒ…å½¢ $n = 0$ã€‚\n"
"\n"
"å›æƒ³ä¸€ä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»»ä½•åœ¨ä½ çš„æ¸…å•ä¸­å¯è§çš„å¼•ç†çš„è¯æ˜ï¼Œæˆ–è€…ä»»ä½•æ˜¾ç¤ºåœ¨ç›®æ ‡ä¸Šæ–¹çš„å‡è®¾\n"
"ï¼ˆåªè¦å®ƒæ˜¯å½¢å¦‚ `X = Y` çš„å½¢å¼ï¼‰æ¥é‡å†™ç›®æ ‡ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid "try rewriting `add_zero`."
msgstr "å°è¯•é‡å†™ `add_zero`ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"Now for to the second goal. Here you have the induction hypothesis\n"
"`Â«{hd}Â» : 0 + Â«{d}Â» = Â«{d}Â»`, and you need to prove that `0 + succ Â«{d}Â» = succ Â«{d}Â»`."
msgstr ""
"ç°åœ¨æ¥åˆ°ç¬¬äºŒä¸ªç›®æ ‡ã€‚è¿™é‡Œä½ æœ‰å½’çº³å‡è®¾\n"
"`Â«{hd}Â» : 0 + Â«{d}Â» = Â«{d}Â»`ï¼Œä½ éœ€è¦è¯æ˜ `0 + succ Â«{d}Â» = succ Â«{d}Â»`ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid "Use `add_succ`."
msgstr "ä½¿ç”¨ `add_succ`ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"At this point you see the term `0 + Â«{d}Â»`, so you can use the\n"
"induction hypothesis with `rw [Â«{hd}Â»]`."
msgstr "åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ çœ‹åˆ°äº†é¡¹ `0 + Â«{d}Â»`ï¼Œæ‰€ä»¥ä½ å¯ä»¥é€šè¿‡ `rw [Â«{hd}Â»]` æ¥ä½¿ç”¨å½’çº³å‡è®¾ã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"## Summary\n"
"\n"
"If `n : â„•` is an object, and the goal mentions `n`, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"variable in the successor case being `d`, and the inductive hypothesis being `hd`.\n"
"\n"
"### Example:\n"
"If the goal is\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will turn it into two goals. The first is `0 + 0 = 0`;\n"
"the second has an assumption `hd : 0 + d = d` and goal\n"
"`0 + succ d = succ d`.\n"
"\n"
"Note that you must prove the first\n"
"goal before you can access the second one."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœ `n : â„•` æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”ç›®æ ‡æåˆ°äº† `n`ï¼Œé‚£ä¹ˆ `induction n with d hd`\n"
"å°è¯•é€šè¿‡å¯¹ `n` è¿›è¡Œå½’çº³æ¥è¯æ˜ç›®æ ‡ï¼Œå…¶ä¸­åç»§æ•°æƒ…å†µä¸‹çš„å½’çº³å˜é‡æ˜¯ `d`ï¼Œå½’çº³å‡è®¾æ˜¯ `hd`ã€‚\n"
"\n"
"### ä¾‹å­:\n"
"å¦‚æœç›®æ ‡æ˜¯\n"
"```\n"
"0 + n = n\n"
"```\n"
"\n"
"é‚£ä¹ˆ\n"
"\n"
"`induction n with d hd`\n"
"\n"
"å°†æŠŠå®ƒå˜æˆä¸¤ä¸ªç›®æ ‡ã€‚ç¬¬ä¸€ä¸ªæ˜¯ `0 + 0 = 0`ï¼›\n"
"ç¬¬äºŒä¸ªæœ‰ä¸€ä¸ªå‡è®¾ `hd : 0 + d = d` å’Œç›®æ ‡\n"
"`0 + succ d = succ d` ã€‚\n"
"\n"
"æ³¨æ„ä½ å¿…é¡»å…ˆè¯æ˜ç¬¬ä¸€ä¸ªç„¶åæ‰èƒ½è¯ç¬¬äºŒä¸ªã€‚"

#: Game.Levels.Addition.L01zero_add
msgid ""
"This lemma would have been easy if we had known that `x + y = y + x`. That theorem\n"
"  is called `add_comm` and it is *true*, but unfortunately its proof *uses* both\n"
"  `add_zero` and `zero_add`!\n"
"\n"
"  Let's continue on our journey to `add_comm`, the proof of `x + y = y + x`."
msgstr ""
"å¦‚æœæˆ‘ä»¬çŸ¥é“ `x + y = y + x` ï¼Œé‚£ä¹ˆè¯æ˜è¿™ä¸ªå¼•ç†å°±ä¼šå¾ˆå®¹æ˜“ã€‚é‚£ä¸ªå®šç†\n"
"  è¢«ç§°ä¸º `add_comm`  å¹¶ä¸”å®ƒæ˜¯ *æˆç«‹çš„* ï¼Œä½†ä¸å¹¸çš„æ˜¯å®ƒçš„è¯æ˜ *ç”¨åˆ°äº†* \n"
"  `add_zero` å’Œ `zero_add`ï¼\n"
"\n"
"  è®©æˆ‘ä»¬ç»§ç»­æˆ‘ä»¬è¯æ˜ `add_comm`ï¼Œå³ `x + y = y + x` çš„æ—…ç¨‹ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid "succ_add"
msgstr "succ_add"

#: Game.Levels.Addition.L02succ_add
msgid ""
"Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add a b`\n"
"is the proof that `(succ a) + b = succ (a + b)` for `a` and `b` numbers.\n"
"This result is what's standing in the way of `x + y = y + x`. Again\n"
"we have the problem that we are adding `b` to things, so we need\n"
"to use induction to split into the cases where `b = 0` and `b` is a successor."
msgstr ""
"å“¦ä¸ï¼åœ¨å‰å¾€ `add_comm` çš„è·¯ä¸Šï¼Œä¸€ä¸ªé‡ç”Ÿçš„ `succ_add` å‡ºç°äº†ã€‚\n"
"`succ_add a b` æ˜¯ `(succ a) + b = succ (a + b)` çš„è¯æ˜ï¼Œå¯¹äºæ•°å­— `a` å’Œ `b`ã€‚\n"
"è¿™ä¸ªç»“æœæ˜¯è¯æ˜ `x + y = y + x` çš„ä¸­é—´æ­¥éª¤ã€‚è¿™é‡Œæˆ‘ä»¬å†æ¬¡é‡åˆ°äº†å‘äº‹ç‰©ä¸­åŠ å…¥ `b` çš„é—®é¢˜ï¼Œ\n"
"æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨å½’çº³æ³•æ¥åˆ†è§£æˆ `b = 0` å’Œ `b` æ˜¯åç»§æ•°çš„æƒ…å†µã€‚"

#: Game.Levels.Addition.L02succ_add
msgid "`succ_add a b` is a proof that `succ a + b = succ (a + b)`."
msgstr "`succ_add a b` æ˜¯ `succ a + b = succ (a + b)` çš„è¯æ˜ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid ""
"For all natural numbers $a, b$, we have\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$."
msgstr ""
"å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a, b$ï¼Œæˆ‘ä»¬æœ‰\n"
"$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid ""
"You might want to think about whether induction\n"
"on `a` or `b` is the best idea."
msgstr "ä½ å¯èƒ½æƒ³è€ƒè™‘ä¸€ä¸‹ï¼Œå¯¹ `a` è¿˜æ˜¯ `b` è¿›è¡Œå½’çº³è¯æ˜æ‰æ˜¯æœ€å¥½çš„ä¸»æ„ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid ""
"Induction on `a` will not work here. You are still stuck with an `+ b`.\n"
"I suggest you delete this line and try a different approach."
msgstr ""
"å¯¹ `a` çš„å½’çº³åœ¨è¿™é‡Œä¸èµ·ä½œç”¨ã€‚ä½ ä»ç„¶å¡åœ¨ `+ b` ä¸Šã€‚\n"
"æˆ‘å»ºè®®ä½ åˆ é™¤è¿™ä¸€è¡Œï¼Œæ¢ä¸€ç§æ–¹æ³•ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid ""
"Note that `succ a + Â«{d}Â»` means `(succ a) + Â«{d}Â»`. Put your cursor\n"
"on any `succ` in the goal or assumptions to see what exactly it's eating."
msgstr ""
"è¯·æ³¨æ„ï¼Œ`succ a + Â«{d}Â»` çš„æ„æ€æ˜¯ `(succ a) + Â«{d}Â»`ã€‚å°†ä½ çš„å…‰æ ‡æ”¾åœ¨ç›®æ ‡æˆ–å‡è®¾ä¸­çš„ä»»ä½• `succ` ä¸Šï¼Œä»¥"
"æŸ¥çœ‹å®ƒç¡®åˆ‡çš„å«ä¹‰ã€‚"

#: Game.Levels.Addition.L02succ_add
msgid "Well done! You now have enough tools to tackle the main boss of this level."
msgstr "åšå¾—å¥½ï¼ç°åœ¨ä½ æœ‰è¶³å¤Ÿçš„å·¥å…·æ¥å¯¹ä»˜è¿™ä¸ªå…³å¡çš„å¤§Bossäº†ã€‚"

#: Game.Levels.Addition.L03add_comm
msgid "add_comm (level boss)"
msgstr "add_commï¼ˆå…³å¡Bossï¼‰"

#: Game.Levels.Addition.L03add_comm
msgid ""
"[boss battle music]\n"
"\n"
"Look in your inventory to see the proofs you have available.\n"
"These should be enough."
msgstr ""
"ã€Bossæˆ˜éŸ³ä¹ã€‘\n"
"\n"
"æŸ¥çœ‹æ‚¨çš„åº“å­˜ä»¥æŸ¥çœ‹æ‚¨æ‹¥æœ‰çš„å¯ç”¨å®šç†ã€‚\n"
"è¿™äº›åº”è¯¥è¶³å¤Ÿäº†ã€‚"

#: Game.Levels.Addition.L03add_comm
msgid "`add_comm x y` is a proof of `x + y = y + x`."
msgstr "`add_comm x y` æ˜¯ `x + y = y + x` çš„è¯æ˜ã€‚"

#: Game.Levels.Addition.L03add_comm
msgid ""
"On the set of natural numbers, addition is commutative.\n"
"In other words, if `a` and `b` are arbitrary natural numbers, then\n"
"$a + b = b + a$."
msgstr ""
"åœ¨è‡ªç„¶æ•°é›†ä¸Šï¼ŒåŠ æ³•æ˜¯å¯äº¤æ¢çš„ã€‚\n"
"æ¢å¥è¯è¯´ï¼Œå¦‚æœ `a` å’Œ `b` æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ\n"
"$a + b = b + a$ã€‚"

#: Game.Levels.Addition.L03add_comm
msgid "Induction on `a` or `b` -- it's all the same in this one."
msgstr "å¯¹ `a` æˆ– `b` è¿›è¡Œå½’çº³è¯æ˜ â€”â€” å®ƒä»¬éƒ½æ˜¯ç›¸åŒçš„ã€‚"

#: Game.Levels.Addition.L04add_assoc
msgid "add_assoc (associativity of addition)"
msgstr "add_assocï¼ˆåŠ æ³•ç»“åˆå¾‹ï¼‰"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"We've been adding up two numbers; in this level we will add up three.\n"
"\n"
"  What does $x+y+z$ *mean*? It could either mean $(x+y)+z$, or it\n"
"  could mean $x+(y+z)$. In Lean, $x+y+z$ means $(x+y)+z$.\n"
"\n"
"  But why do we care which one it means; $(x+y)+z$ and $x+(y+z)$ are *equal*!\n"
"\n"
"  That's true, but we didn't prove it yet. Let's prove it now by induction."
msgstr ""
"æˆ‘ä»¬å·²ç»å­¦ä¼šäº†å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼›åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†ä¸‰ä¸ªæ•°ç›¸åŠ ã€‚\n"
"\n"
"$x+y+z$ *æ„å‘³*ç€ä»€ä¹ˆï¼Ÿå®ƒå¯ä»¥æ„å‘³ç€ $(x+y)+z$ï¼Œä¹Ÿå¯ä»¥æ„å‘³ç€ $x+(y+z)$ã€‚åœ¨ Lean ä¸­ï¼Œ$x+y+z$ æ„å‘³ç€ $(x"
"+y)+z$ã€‚\n"
"\n"
"ä½†æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦åœ¨æ„å®ƒçš„å«ä¹‰å‘¢ï¼›$(x+y)+z$ å’Œ $x+(y+z)$ æ˜¯*ç›¸ç­‰*çš„ï¼\n"
"\n"
"ç¡®å®å¦‚æ­¤ï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜å®ƒã€‚ç°åœ¨è®©æˆ‘ä»¬é€šè¿‡å½’çº³æ¥è¯æ˜å®ƒã€‚"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"`add_assoc a b c` is a proof\n"
"that `(a + b) + c = a + (b + c)`. Note that in Lean `(a + b) + c` prints\n"
"as `a + b + c`, because the notation for addition is defined to be left\n"
"associative."
msgstr ""
"`add_assoc a b c` æ˜¯ä¸€ä¸ª `(a + b) + c = a + (b + c)` çš„è¯æ˜ã€‚\n"
"è¯·æ³¨æ„ï¼Œåœ¨ Lean `(a + b) + c` ä¸­æ˜¾ç¤º\n"
"ä¸º `a + b + c`ï¼Œå› ä¸ºåŠ æ³•ç¬¦å·è¢«å®šä¹‰ä¸ºå·¦\n"
"ç»“åˆçš„ã€‚"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"On the set of natural numbers, addition is associative.\n"
"In other words, if $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$ (a + b) + c = a + (b + c). $"
msgstr ""
"åœ¨è‡ªç„¶æ•°é›†ä¸Šï¼ŒåŠ æ³•æœä»ç»“åˆå¾‹ã€‚\n"
"æ¢å¥è¯è¯´ï¼Œå¦‚æœ $a, b$ å’Œ $c$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n"
"$ (a + b) + c = a + (b + c)$ ã€‚"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\n"
"If you are not sure where the brackets are in an expression, just hover\n"
"your cursor over it and look at what gets highlighted. For example,\n"
"hover over both `+` symbols on the left hand side of the goal and\n"
"you'll see where the invisible brackets are."
msgstr ""
"è®°ä½ï¼Œå½“ Lean å†™ä½œ `a + b + c` æ—¶ï¼Œå®ƒçš„æ„æ€æ˜¯ `(a + b) + c`ã€‚\n"
"å¦‚æœä½ ä¸ç¡®å®šè¡¨è¾¾å¼ä¸­çš„æ‹¬å·åœ¨å“ªé‡Œï¼Œåªéœ€å°†å…‰æ ‡æ‚¬åœåœ¨å®ƒä¸Šé¢ï¼Œ\n"
"çœ‹çœ‹ä»€ä¹ˆè¢«é«˜äº®æ˜¾ç¤ºã€‚ä¾‹å¦‚ï¼Œå°†å…‰æ ‡æ‚¬åœåœ¨ç›®æ ‡å·¦ä¾§çš„ä¸¤ä¸ª `+` ç¬¦å·ä¸Šï¼Œ\n"
"ä½ å°±ä¼šçœ‹åˆ°çœ‹ä¸è§çš„æ‹¬å·åœ¨å“ªé‡Œã€‚"

#: Game.Levels.Addition.L04add_assoc
msgid ""
"A passing mathematician congratulates you on proving that naturals\n"
"are an additive commutative monoid.\n"
"\n"
"Let's practice using `add_assoc` and `add_comm` in one more level,\n"
"before we leave addition world."
msgstr ""
"ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶ç¥è´ºä½ è¯æ˜äº†è‡ªç„¶æ•°æ˜¯ä¸€ä¸ªåŠ æ³•äº¤æ¢å¹ºåŠç¾¤ã€‚\n"
"\n"
"åœ¨æˆ‘ä»¬ç¦»å¼€åŠ æ³•ä¸–ç•Œä¹‹å‰ï¼Œè®©æˆ‘ä»¬åœ¨å¦ä¸€å…³é‡Œç»ƒä¹ ä½¿ç”¨ `add_assoc` å’Œ `add_comm`ã€‚"

#: Game.Levels.Addition.L05add_right_comm
msgid "add_right_comm"
msgstr "add_right_comm"

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"`add_comm b c` is a proof that `b + c = c + b`. But if your goal\n"
"is `a + b + c = a + c + b` then `rw [add_comm b c]` will not\n"
"work! Because the goal means `(a + b) + c = (a + c) + b` so there\n"
"is no `b + c` term *directly* in the goal.\n"
"\n"
"Use associativity and commutativity to prove `add_right_comm`.\n"
"You don't need induction. `add_assoc` moves brackets around,\n"
"and `add_comm` moves variables around.\n"
"\n"
"Remember that you can do more targetted rewrites by\n"
"adding explicit variables as inputs to theorems. For example `rw [add_comm b]`\n"
"will only do rewrites of the form `b + ? = ? + b`, and `rw [add_comm b c]`\n"
"will only do rewrites of the form `b + c = c + b`."
msgstr ""
"`add_comm b c` æ˜¯ä¸€ä¸ª `b + c = c + b` çš„è¯æ˜ã€‚ä½†å¦‚æœæ‚¨çš„ç›®æ ‡æ˜¯ `a + b + c = a + c + b`ï¼Œé‚£ä¹ˆ `rw "
"[add_comm b c]` å°†ä¸èµ·ä½œç”¨ï¼å› ä¸ºç›®æ ‡æ˜¯ `(a + b) + c = (a + c) + b`ï¼Œæ‰€ä»¥ç›®æ ‡ä¸­*ç›´æ¥*æ²¡æœ‰ `b + c` "
"é¡¹ã€‚\n"
"\n"
"ä½¿ç”¨ç»“åˆå¾‹å’Œäº¤æ¢å¾‹æ¥è¯æ˜ `add_right_comm`ã€‚æ‚¨ä¸éœ€è¦ä½¿ç”¨å½’çº³æ³•ã€‚`add_assoc` ç§»åŠ¨æ‹¬å·ï¼Œ`add_comm` ç§»åŠ¨"
"å˜é‡ã€‚\n"
"\n"
"è¯·è®°ä½ï¼Œæ‚¨å¯ä»¥é€šè¿‡å°†æ˜¾å¼å˜é‡æ·»åŠ ä¸ºå®šç†çš„è¾“å…¥æ¥è¿›è¡Œæ›´æœ‰é’ˆå¯¹æ€§çš„é‡å†™ã€‚\n"
"ä¾‹å¦‚ï¼Œ`rw [add_comm b]` åªä¼šé‡å†™å½¢å¦‚ `b + ? = ? + b` çš„å½¢å¼ï¼Œè€Œ `rw [add_comm b c]` åªä¼šé‡å†™å½¢å¦‚ `b "
"+ c = c + b` çš„å½¢å¼ã€‚"

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"`add_right_comm a b c` is a proof that `(a + b) + c = (a + c) + b`\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, so this result gets displayed\n"
"as `a + b + c = a + c + b`."
msgstr ""
"`add_right_comm a b c` æ˜¯ `(a + b) + c = (a + c) + b` çš„è¯æ˜ã€‚\n"
"\n"
"åœ¨ Lean ä¸­ï¼Œ`a + b + c` æ„å‘³ç€ `(a + b) + c`ï¼Œæ‰€ä»¥è¿™ä¸ªç»“æœè¢«æ˜¾ç¤ºä¸º `a + b + c = a + c + b`ã€‚"

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"If $a, b$ and $c$ are arbitrary natural numbers, we have\n"
"$(a + b) + c = (a + c) + b$."
msgstr ""
"å¦‚æœ $a, b$ å’Œ $c$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n"
"$(a + b) + c = (a + c) + b$ã€‚"

#: Game.Levels.Addition.L05add_right_comm
msgid ""
"You've now seen all the tactics you need to beat the final boss of the game.\n"
"You can begin the journey towards this boss by entering Multiplication World.\n"
"\n"
"Or you can go off the beaten track and learn some new tactics in Implication\n"
"World. These tactics let you prove more facts about addition, such as\n"
"how to deduce `a = 0` from `x + a = x`.\n"
"\n"
"Click \"Leave World\" and make your choice."
msgstr ""
"ä½ ç°åœ¨å·²ç»æŒæ¡äº†å‡»è´¥æ¸¸æˆæœ€ç»ˆ BOSS æ‰€éœ€çš„æ‰€æœ‰ç­–ç•¥ã€‚\n"
"ä½ å¯ä»¥è¿›å…¥ä¹˜æ³•ä¸–ç•Œï¼Œå¼€å§‹å¾æœ BOSS çš„å†’é™©ä¹‹æ—…ã€‚\n"
"\n"
"æˆ–è€…ï¼Œä½ å¯ä»¥ç¦»å¼€å¸¸è§„è·¯çº¿ï¼Œåœ¨è•´æ¶µä¸–ç•Œä¸­å­¦ä¹ ä¸€äº›æ–°çš„ç­–ç•¥ã€‚\n"
"è¿™äº›ç­–ç•¥å¯ä»¥è®©ä½ è¯æ˜æ›´å¤šå…³äºåŠ æ³•çš„äº‹å®ï¼Œä¾‹å¦‚ä» `x + a = x` æ¨å¯¼ `a = 0`ã€‚\n"
"\n"
"ç‚¹å‡»â€œç¦»å¼€ä¸–ç•Œâ€ï¼Œåšå‡ºä½ çš„é€‰æ‹©å§ã€‚"

#: Game.Levels.Addition
msgid "Addition World"
msgstr "åŠ æ³•ä¸–ç•Œ"

#: Game.Levels.Addition
msgid ""
"Welcome to Addition World! In this world we'll learn the `induction` tactic.\n"
"This will enable us to defeat the boss level of this world, namely `x + y = y + x`.\n"
"\n"
"The tactics `rw`, `rfl` and `induction` are the only tactics you'll need to\n"
"beat all the levels in Addition World, Multiplication World, and Power World.\n"
"Power World contains the final boss of the game.\n"
"\n"
"There are plenty more tactics in this game, but you'll only need to know them if you\n"
"want to explore the game further (for example if you decide to 100%\n"
"the game)."
msgstr ""
"æ¬¢è¿æ¥åˆ°åŠ æ³•ä¸–ç•Œï¼åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  `induction`ï¼ˆå½’çº³ï¼‰ç­–ç•¥ã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿå‡»è´¥è¿™ä¸ªä¸–ç•Œçš„Boss"
"çº§åˆ«ï¼Œå³ `x + y = y + x`ã€‚\n"
"\n"
"ç­–ç•¥ `rw`ï¼ˆé‡å†™ï¼‰ã€`rfl`ï¼ˆåå°„ï¼‰å’Œ `induction`ï¼ˆå½’çº³ï¼‰æ˜¯ä½ åœ¨åŠ æ³•ä¸–ç•Œã€ä¹˜æ³•ä¸–ç•Œå’Œå¹‚ä¸–ç•Œä¸­å‡»è´¥æ‰€æœ‰å…³å¡"
"æ‰€éœ€è¦ç­–ç•¥ã€‚å¹‚ä¸–ç•ŒåŒ…å«äº†æ¸¸æˆçš„æœ€ç»ˆBossã€‚\n"
"\n"
"è¿™ä¸ªæ¸¸æˆä¸­è¿˜æœ‰æ›´å¤šçš„ç­–ç•¥ï¼Œä½†åªæœ‰å½“ä½ æƒ³è¿›ä¸€æ­¥æ¢ç´¢æ¸¸æˆæ—¶ï¼ˆä¾‹å¦‚å¦‚æœä½ å†³å®šå®Œæˆæ¸¸æˆçš„100%ï¼‰æ‰éœ€è¦äº†è§£å®ƒ"
"ä»¬ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid "mul_one"
msgstr "mul_one"

#: Game.Levels.Multiplication.L01mul_one
msgid ""
"See the new \"*\" tab in your lemmas, containing `mul_zero` and `mul_succ`.\n"
"Right now these are the only facts we know about multiplication.\n"
"Let's prove nine more.\n"
"\n"
"Let's start with a warm-up: no induction needed for this one,\n"
"because we know `1` is a successor."
msgstr ""
"æŸ¥çœ‹å¼•ç†åŒºä¸­çš„æ–°â€œ*â€æ ‡ç­¾ï¼ŒåŒ…å« `mul_zero` å’Œ `mul_succ`ã€‚\n"
"ç›®å‰è¿™äº›æ˜¯æˆ‘ä»¬å”¯ä¸€çŸ¥é“çš„å…³äºä¹˜æ³•çš„äº‹å®ã€‚\n"
"è®©æˆ‘ä»¬å†è¯æ˜ä¹ä¸ªã€‚\n"
"\n"
"è®©æˆ‘ä»¬ä»ä¸€ä¸ªçƒ­èº«å¼€å§‹ï¼šè¿™ä¸ªä¸éœ€è¦å½’çº³ï¼Œ\n"
"å› ä¸ºæˆ‘ä»¬çŸ¥é“ `1` æ˜¯ä¸€ä¸ªåç»§æ•°ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid ""
"`Mul a b`, with notation `a * b`, is the usual\n"
"  product of natural numbers. Internally it is\n"
"  via two axioms:\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"\n"
"  * `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"Other theorems about naturals, such as `zero_mul`,\n"
"are proved by induction from these two basic theorems."
msgstr ""
"`Mul a b`ï¼Œå…¶ç¬¦å·è¡¨ç¤ºä¸º `a * b`ï¼Œæ˜¯è‡ªç„¶æ•°çš„å¸¸è§„ä¹˜ç§¯ã€‚å®ƒæ˜¯é€šè¿‡ä¸¤æ¡è§„åˆ™å®šä¹‰çš„ï¼š\n"
"\n"
"* `mul_zero a : a * 0 = 0`\n"
"\n"
"* `mul_succ a b : a * succ b = a * b + a`\n"
"\n"
"å…³äºè‡ªç„¶æ•°çš„å…¶ä»–å®šç†ï¼Œæ¯”å¦‚ `zero_mul`ï¼Œéƒ½æ˜¯é€šè¿‡ä»è¿™ä¸¤ä¸ªåŸºæœ¬å®šç†è¿›è¡Œå½’çº³è¯æ˜å¾—åˆ°çš„ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_zero m` is the proof that `m * 0 = 0`."
msgstr "`mul_zero m` æ˜¯ `m * 0 = 0` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_succ a b` is the proof that `a * succ b = a * b + a`."
msgstr "`mul_succ a b` æ˜¯ `a * succ b = a * b + a` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid "`mul_one m` is the proof that `m * 1 = m`."
msgstr "`mul_one m` æ˜¯ `m * 1 = m` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L01mul_one
msgid "For any natural number $m$, we have $ m \\times 1 = m$."
msgstr "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ m \\times 1 = m$ã€‚"

#: Game.Levels.Multiplication.L02zero_mul
msgid "zero_mul"
msgstr "zero_mul"

#: Game.Levels.Multiplication.L02zero_mul
msgid ""
"Our first challenge is `mul_comm x y : x * y = y * x`,\n"
"and we want to prove it by induction. The zero\n"
"case will need `mul_zero` (which we have)\n"
"and `zero_mul` (which we don't), so let's\n"
"start with this."
msgstr ""
"æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªæŒ‘æˆ˜æ˜¯`mul_comm x y : x * y = y * x`ï¼Œ\n"
"æˆ‘ä»¬æƒ³é€šè¿‡å½’çº³æ³•æ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚åœ¨è¯æ˜0çš„ç›®æ ‡ä¸‹æˆ‘ä»¬éœ€è¦ `mul_zero` ï¼ˆæˆ‘ä»¬æœ‰ï¼‰å’Œ `zero_mul` ï¼ˆæˆ‘ä»¬æ²¡"
"æœ‰ï¼‰ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ä»è¿™é‡Œå¼€å§‹ã€‚"

#: Game.Levels.Multiplication.L02zero_mul
msgid ""
"`zero_mul x` is the proof that `0 * x = 0`.\n"
"\n"
"Note: `zero_mul` is a `simp` lemma."
msgstr ""
"`zero_mul x` æ˜¯ `0 * x = 0` çš„è¯æ˜ã€‚\n"
"\n"
"æ³¨æ„ï¼š`zero_mul` æ˜¯ä¸€ä¸ª `simp` å¼•ç†ã€‚"

#: Game.Levels.Multiplication.L02zero_mul
msgid "For all natural numbers $m$, we have $ 0 \\times m = 0$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 0 \\times m = 0$ã€‚"

#: Game.Levels.Multiplication.L03succ_mul
msgid "succ_mul"
msgstr "succ_mul"

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"Similarly we have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions).\n"
"\n"
"The last level from addition world might help you in this level.\n"
"If you can't remember what it is, you can go back to the\n"
"home screen by clicking the house icon and then taking a look.\n"
"You won't lose any progress."
msgstr ""
"åŒæ ·ï¼Œæˆ‘ä»¬æœ‰ `mul_succ`ï¼Œ\n"
"ä½†æˆ‘ä»¬éœ€è¦ `succ_mul`ï¼ˆçŒœçŒœå®ƒæ˜¯ä»€ä¹ˆæ„æ€ â€”â€” ä¹Ÿè®¸ä½ å·²ç»æŒæ¡äº† Lean çš„å‘½åèŒƒå¼ï¼‰ã€‚\n"
"\n"
"åŠ æ³•ä¸–ç•Œä¸­çš„æœ€åä¸€å…³ä¼šåœ¨è¿™ä¸ªå…³å¡ä¸­å¸®åŠ©ä½ ã€‚\n"
"å¦‚æœä½ å¿˜è®°äº†å®ƒæ˜¯ä»€ä¹ˆï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡»æˆ¿å±‹å›¾æ ‡å›åˆ°ä¸»ç•Œé¢ï¼Œç„¶åçœ‹ä¸€çœ‹ã€‚\n"
"ä½ ä¸ä¼šå› æ­¤å¤±å»ä»»ä½•è¿›åº¦ã€‚"

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"`succ_mul a b` is the proof that `succ a * b = a * b + b`.\n"
"\n"
"It could be deduced from `mul_succ` and `mul_comm`, however this argument\n"
"would be circular because the proof of `mul_comm` uses `mul_succ`."
msgstr ""
"`succ_mul a b` æ˜¯ `succ a * b = a * b + b` çš„è¯æ˜ã€‚\n"
"\n"
"å¯ä»¥ä» `mul_succ` å’Œ `mul_comm` æ¨å¯¼å‡ºæ¥ï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯å¾ªç¯è®ºè¯ï¼Œ\n"
"å› ä¸º `mul_comm` çš„è¯æ˜ä½¿ç”¨äº† `mul_succ`ã€‚"

#: Game.Levels.Multiplication.L03succ_mul
msgid ""
"For all natural numbers $a$ and $b$, we have\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$."
msgstr ""
"å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ å’Œ $b$ï¼Œæˆ‘ä»¬æœ‰\n"
"$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$ã€‚"

#: Game.Levels.Multiplication.L04mul_comm
msgid "mul_comm"
msgstr "mul_comm"

#: Game.Levels.Multiplication.L04mul_comm
msgid ""
"The first sub-boss of Multiplication World is `mul_comm x y : x * y = y * x`.\n"
"\n"
"When you've proved this theorem we will have \"spare\" proofs\n"
"such as `zero_mul`, which is now easily deducible from `mul_zero`.\n"
"But we'll keep hold of these proofs anyway, because it's convenient\n"
"to have exactly the right tool for a job."
msgstr ""
"ä¹˜æ³•ä¸–ç•Œçš„ç¬¬ä¸€ä¸ªå° Boss æ˜¯ `mul_comm x y : x * y = y * x`ã€‚\n"
"\n"
"å½“ä½ è¯æ˜äº†è¿™ä¸ªå®šç†åï¼Œæˆ‘ä»¬å°†æœ‰ä¸€äº›â€œå¤šä½™â€çš„è¯æ˜\n"
"ä¾‹å¦‚ `zero_mul`ï¼Œå®ƒç°åœ¨å¯ä»¥è½»æ¾åœ°ä» `mul_zero` ä¸­æ¨å¯¼å‡ºæ¥ã€‚\n"
"ä½†æ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½ä¼šä¿ç•™è¿™äº›è¯æ˜ï¼Œå› ä¸º\n"
"æ‹¥æœ‰é€‚åˆå·¥ä½œçš„å·¥å…·ä¼šå¾ˆæ–¹ä¾¿ã€‚"

#: Game.Levels.Multiplication.L04mul_comm
msgid ""
"`mul_comm` is the proof that multiplication is commutative. More precisely,\n"
"`mul_comm a b` is the proof that `a * b = b * a`."
msgstr ""
"`mul_comm` æ˜¯ä¹˜æ³•å¯äº¤æ¢çš„è¯æ˜ã€‚æ›´ç¡®åˆ‡åœ°è¯´ï¼Œ\n"
"`mul_comm a b` æ˜¯ `a * b = b * a` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L04mul_comm
msgid "Multiplication is commutative."
msgstr "ä¹˜æ³•æ˜¯å¯äº¤æ¢çš„ã€‚"

#: Game.Levels.Multiplication.L05one_mul
msgid "one_mul"
msgstr "one_mul"

#: Game.Levels.Multiplication.L05one_mul
msgid ""
"You can prove $1\\times m=m$ in at least three ways.\n"
"Either by induction, or by using `succ_mul`, or\n"
"by using commutativity. Which do you think is quickest?"
msgstr ""
"æ‚¨å¯ä»¥è‡³å°‘é€šè¿‡ä¸‰ç§æ–¹å¼è¯æ˜ $1\\times m=m$ã€‚\n"
"é€šè¿‡å½’çº³æ³•ï¼Œæˆ–ä½¿ç”¨ `succ_mul`ï¼Œæˆ–\n"
"é€šè¿‡ä½¿ç”¨äº¤æ¢å¾‹ã€‚ä½ è®¤ä¸ºå“ªä¸ªæœ€å¿«ï¼Ÿ"

#: Game.Levels.Multiplication.L05one_mul
msgid "`one_mul m` is the proof `1 * m = m`."
msgstr "`one_mul m` æ˜¯è¯æ˜ `1 * m = m`ã€‚"

#: Game.Levels.Multiplication.L05one_mul
msgid "For any natural number $m$, we have $ 1 \\times m = m$."
msgstr "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 1 \\times m = m$ã€‚"

#: Game.Levels.Multiplication.L05one_mul
msgid ""
"Here's my solution:\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"
msgstr ""
"è¿™æ˜¯æˆ‘çš„è§£æ³•ï¼š\n"
"```\n"
"rw [mul_comm, mul_one]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L06two_mul
msgid "two_mul"
msgstr "two_mul"

#: Game.Levels.Multiplication.L06two_mul
msgid ""
"This level is more important than you think; it plays\n"
"a useful role when battling a big boss later on."
msgstr "è¿™ä¸ªå…³å¡æ¯”ä½ æƒ³è±¡çš„æ›´é‡è¦ï¼›åœ¨ä¹‹åä¸ä¸€ä¸ªå¤§bossæˆ˜æ–—æ—¶ï¼Œå®ƒå°†å¸®åŠ©ä½ ã€‚"

#: Game.Levels.Multiplication.L06two_mul
msgid "`two_mul m` is the proof that `2 * m = m + m`."
msgstr "`two_mul m` æ˜¯ `2 * m = m + m` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L06two_mul
msgid "For any natural number $m$, we have $ 2 \\times m = m+m$."
msgstr "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 2 \\times m = m+m$ã€‚"

#: Game.Levels.Multiplication.L06two_mul
msgid ""
"Here's my solution:\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"
msgstr ""
"è¿™æ˜¯æˆ‘çš„è§£æ³•ï¼š\n"
"```\n"
"rw [two_eq_succ_one, succ_mul, one_mul]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L07mul_add
msgid "mul_add"
msgstr "mul_add"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Our next goal is \"left and right distributivity\",\n"
"meaning $a(b+c)=ab+ac$ and $(b+c)a=ba+ca$. Rather than\n"
"these slightly pompous names, the name of the proofs\n"
"in Lean are descriptive. Let's start with\n"
"`mul_add a b c`, the proof of `a * (b + c) = a * b + a * c`.\n"
"Note that the left hand side contains a multiplication\n"
"and then an addition."
msgstr ""
"æˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯â€œå·¦å³åˆ†é…å¾‹â€ï¼Œæ„æ€æ˜¯ $a(b+c)=ab+ac$ å’Œ $(b+c)a=ba+ca$ã€‚ä¸å…¶ç”¨è¿™æ ·ç¨æ˜¾æµ®å¤¸çš„åå­—ï¼Œä¸"
"å¦‚ä½¿ç”¨ Lean ä¸­çš„è¯æ˜åç§°ï¼Œå®ƒä»¬æ˜¯æè¿°æ€§çš„ã€‚\n"
"è®©æˆ‘ä»¬ä» `mul_add a b c` å¼€å§‹ï¼Œè¿™æ˜¯ `a * (b + c) = a * b + a * c` çš„è¯æ˜ã€‚æ³¨æ„å·¦è¾¹åŒ…å«ä¸€ä¸ªä¹˜æ³•ç„¶åæ˜¯"
"ä¸€ä¸ªåŠ æ³•ã€‚"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Multiplication distributes\n"
"over addition on the left.\n"
"\n"
"`mul_add a b c` is the proof that `a * (b + c) = a * b + a * c`."
msgstr ""
"ä¹˜æ³•åœ¨å·¦ä¾§å¯¹åŠ æ³•å…·æœ‰åˆ†é…æ€§ã€‚\n"
"\n"
"`mul_add a b c` æ˜¯ `a * (b + c) = a * b + a * c` çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Multiplication is distributive over addition on the left.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$a(b + c) = ab + ac$."
msgstr ""
"ä¹˜æ³•å¯¹å·¦è¾¹çš„åŠ æ³•å…·æœ‰åˆ†é…æ€§ã€‚\n"
"æ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œæˆ‘ä»¬æœ‰\n"
"$a(b + c) = ab + ac$ã€‚"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"You can do induction on any of the three variables. Some choices\n"
"are harder to push through than others. Can you do the inductive step in\n"
"5 rewrites only?"
msgstr ""
"ä½ å¯ä»¥å¯¹ä»»ä½•ä¸‰ä¸ªå˜é‡ä¸­çš„ä»»ä½•ä¸€ä¸ªè¿›è¡Œå½’çº³ã€‚æœ‰äº›é€‰æ‹©æ¯”å…¶ä»–é€‰æ‹©æ›´éš¾ä»¥æ¨è¿›ã€‚ä½ èƒ½ä»…ç”¨5æ¬¡æ”¹å†™å®Œæˆå½’çº³æ­¥éª¤"
"å—ï¼Ÿ"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Induction on `a` is the most troublesome, then `b`,\n"
"and `c` is the easiest."
msgstr ""
"å¯¹ `a` çš„å½’çº³æœ€éº»çƒ¦ï¼Œç„¶åæ˜¯ `b`ã€\n"
"è€Œ `c` æ˜¯æœ€ç®€å•çš„ã€‚"

#: Game.Levels.Multiplication.L07mul_add
msgid ""
"Here's my solution:\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"Inducting on `a` or `b` also works, but might take longer."
msgstr ""
"è¿™æ˜¯ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä¸å”¯ä¸€ï¼š\n"
"```\n"
"induction c with d hd\n"
"rw [add_zero, mul_zero, add_zero]\n"
"rfl\n"
"rw [add_succ, mul_succ, hd, mul_succ, add_assoc]\n"
"rfl\n"
"```\n"
"\n"
"åœ¨ `a` æˆ– `b` ä¸Šè¿›è¡Œæ•°å­¦å½’çº³ä¹Ÿå¯ä»¥ï¼Œä½†éœ€è¦å¤šæ­¥éª¤ã€‚"

#: Game.Levels.Multiplication.L08add_mul
msgid "add_mul"
msgstr "add_mul"

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"`add_mul` is just as fiddly to prove by induction; but there's a trick\n"
"which avoids it. Can you spot it?"
msgstr ""
"ç”¨å½’çº³æ³•è¯æ˜ `add_mul` ä¹Ÿå¾ˆéº»çƒ¦ï¼Œä½†æœ‰ä¸ªå°çªé—¨å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚\n"
"å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚ä½ èƒ½å‘ç°å—ï¼Ÿ"

#: Game.Levels.Multiplication.L08add_mul
msgid "`add_mul a b c` is a proof that $(a+b)c=ac+bc$."
msgstr "`add_mul a b c` æ˜¯ $(a+b)c=ac+bc$ çš„è¯æ˜ã€‚"

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(a + b) \\times c = ac + bc$."
msgstr ""
"åŠ æ³•å’Œä¹˜æ³•æœ‰åˆ†é…å¾‹ã€‚æ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œ\n"
"æˆ‘ä»¬æœ‰ $(a + b) \\times c = ac + bc$ã€‚"

#: Game.Levels.Multiplication.L08add_mul
msgid ""
"Here's my proof:\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"
msgstr ""
"è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n"
"```\n"
"rw [mul_comm, mul_add]\n"
"repeat rw [mul_comm c]\n"
"rfl\n"
"```"

#: Game.Levels.Multiplication.L09mul_assoc
msgid "mul_assoc"
msgstr "mul_assoc"

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"We now have enough to prove that multiplication is associative,\n"
"the boss level of multiplication world. Good luck!"
msgstr ""
"æˆ‘ä»¬ç°åœ¨æœ‰è¶³å¤Ÿçš„å·¥å…·å»è¯æ˜ä¹˜æ³•æœä»ç»“åˆå¾‹ï¼Œ\n"
"ä¹˜æ³•ä¸–ç•Œçš„bosså…³ã€‚ç¥ä½ å¥½è¿ï¼"

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"`mul_assoc a b c` is a proof that `(a * b) * c = a * (b * c)`.\n"
"\n"
"Note that when Lean says `a * b * c` it means `(a * b) * c`.\n"
"\n"
"Note that `(a * b) * c = a * (b * c)` cannot be proved by \\\"pure thought\\\":\n"
"for example subtraction is not associative, as `(6 - 2) - 1` is not\n"
"equal to `6 - (2 - 1)`."
msgstr ""
"`mul_assoc a b c` æ˜¯ `(a * b) * c = a * (b * c)` çš„è¯æ˜ã€‚\n"
"\n"
"è¯·æ³¨æ„ï¼Œå½“ Lean è¡¨ç¤º `a * b * c` æ—¶ï¼Œå®ƒçš„æ„æ€æ˜¯ `(a * b) * c`ã€‚\n"
"\n"
"è¯·æ³¨æ„ï¼Œ`(a * b) * c = a * (b * c)` ä¸èƒ½ä»…å‡­â€œç©ºæƒ³â€æ¥è¯æ˜ï¼šä¾‹å¦‚ï¼Œå‡æ³•ä¸æ˜¯ç»“åˆçš„ï¼Œå› ä¸º `(6 - 2) - 1` ä¸"
"ç­‰äº `6 - (2 - 1)`ã€‚"

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$(ab)c = a(bc)$."
msgstr ""
"ä¹˜æ³•æœä»ç»“åˆå¾‹ã€‚\n"
"æ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œæˆ‘ä»¬æœ‰\n"
"$(ab)c = a(bc)$ã€‚"

#: Game.Levels.Multiplication.L09mul_assoc
msgid ""
"A passing mathematician notes that you've proved\n"
"that the natural numbers are a commutative semiring.\n"
"\n"
"If you want to begin your journey to the final boss, head for Power World."
msgstr ""
"ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶æŒ‡å‡ºï¼Œä½ å·²ç»è¯æ˜äº†è‡ªç„¶æ•°æ˜¯ä¸€ä¸ªäº¤æ¢åŠç¯ã€‚\n"
"\n"
"å¦‚æœä½ æƒ³å¼€å§‹é€šå¾€æœ€ç»ˆBossçš„æ—…ç¨‹ï¼Œé‚£å°±å‰å¾€å¹‚ä¸–ç•Œã€‚"

#: Game.Levels.Multiplication
msgid "Multiplication World"
msgstr "ä¹˜æ³•ä¸–ç•Œ"

#: Game.Levels.Multiplication
msgid ""
"How should we define `37 * x`? Just like addition, we need to give definitions\n"
"when $x=0$ and when $x$ is a successor.\n"
"\n"
"The zero case is easy: we define `37 * 0` to be `0`. Now say we know\n"
"`37 * d`. What should `37 * succ d` be? Well, that's $(d+1)$ $37$s,\n"
"so it should be `37 * d + 37`.\n"
"\n"
"Here are the definitions in Lean.\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"In this world, we must not only prove facts about multiplication like `a * b = b * a`,\n"
"we must also prove facts about how multiplication interacts with addition, like `a * (b + c) = a * b "
"+ a * c`.\n"
"Let's get started."
msgstr ""
"æˆ‘ä»¬åº”è¯¥å¦‚ä½•å®šä¹‰ `37 * x`ï¼Ÿå°±åƒåŠ æ³•ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ $x=0$ å’Œ $x$ æ˜¯åç»§æ•°æ—¶ç»™å‡ºå®šä¹‰ã€‚\n"
"\n"
"0çš„æƒ…å†µå¾ˆç®€å•ï¼šæˆ‘ä»¬å®šä¹‰ `37 * 0` ä¸º `0`ã€‚ç°åœ¨å‡è®¾æˆ‘ä»¬çŸ¥é“ `37 * d`ã€‚`37 * succ d` åº”è¯¥æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå—¯ï¼Œ"
"é‚£æ˜¯ $d+1$ ä¸ª $37$ï¼Œå®ƒåº”è¯¥æ˜¯ `37 * d + 37`ã€‚\n"
"\n"
"ä»¥ä¸‹æ˜¯ Lean ä¸­çš„å®šä¹‰ã€‚\n"
"\n"
"  * `mul_zero a : a * 0 = 0`\n"
"  * `mul_succ a d : a * succ d = a * d + a`\n"
"\n"
"åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬ä¸ä»…è¦è¯æ˜å…³äºä¹˜æ³•çš„äº‹å®ï¼Œå¦‚ `a * b = b * a`ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»è¯æ˜ä¹˜æ³•ä¸åŠ æ³•ç›¸äº’ä½œç”¨çš„äº‹"
"å®ï¼Œå¦‚ `a * (b + c) = a * b + a * c`ã€‚\n"
"è®©æˆ‘ä»¬å¼€å§‹å§ã€‚"

#: Game.Levels.Power.L01zero_pow_zero
msgid "zero_pow_zero"
msgstr "zero_pow_zero"

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"Mathematicians sometimes debate what `0 ^ 0` is;\n"
"the answer depends, of course, on your definitions. In this\n"
"game, `0 ^ 0 = 1`. See if you can prove it.\n"
"\n"
"Check out the *Pow* tab in your list of theorems\n"
"to see the new proofs which are available."
msgstr ""
"æ•°å­¦å®¶ä»¬æœ‰æ—¶ä¼šäº‰è®º `0 ^ 0` æ˜¯ä»€ä¹ˆï¼›\n"
"ç­”æ¡ˆå½“ç„¶å–å†³äºä½ çš„å®šä¹‰ã€‚åœ¨è¿™ä¸ª\n"
"æ¸¸æˆä¸­ï¼Œ`0 ^ 0 = 1`ã€‚çœ‹çœ‹ä½ èƒ½å¦è¯æ˜è¿™ä¸€ç‚¹ã€‚\n"
"\n"
"æŸ¥çœ‹å®šç†åˆ—è¡¨ä¸­çš„ *Pow* é€‰é¡¹å¡\n"
"æ ‡ç­¾ï¼ŒæŸ¥çœ‹å¯ç”¨çš„æ–°è¯æ˜ã€‚"

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"`Pow a b`, with notation `a ^ b`, is the usual\n"
"  exponentiation of natural numbers. Internally it is\n"
"  defined via two axioms:\n"
"\n"
"  * `pow_zero a : a ^ 0 = 1`\n"
"\n"
"  * `pow_succ a b : a ^ succ b = a ^ b * a`\n"
"\n"
"Note in particular that `0 ^ 0 = 1`."
msgstr ""
"`Pow a b`ï¼Œå…¶ç¬¦å·è¡¨ç¤ºä¸º `a ^ b`ï¼Œæ˜¯è‡ªç„¶æ•°çš„å¸¸è§„æŒ‡æ•°è¿ç®—ã€‚åœ¨å†…éƒ¨ï¼Œå®ƒæ˜¯é€šè¿‡ä¸¤ä¸ªå…¬ç†å®šä¹‰çš„ï¼š\n"
"\n"
"* `pow_zero a : a ^ 0 = 1`\n"
"\n"
"* `pow_succ a b : a ^ succ b = a ^ b * a`\n"
"\n"
"ç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ `0 ^ 0 = 1`ã€‚"

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"`pow_zero a : a ^ 0 = 1` is one of the two axioms\n"
"defining exponentiation in this game."
msgstr ""
"`pow_zero a : a ^ 0 = 1` æ˜¯ä¸¤ä¸ªå…¬ç†ä¹‹ä¸€\n"
"åœ¨è¿™ä¸ªæ¸¸æˆä¸­å®šä¹‰æŒ‡æ•°ã€‚"

#: Game.Levels.Power.L01zero_pow_zero
msgid ""
"Mathematicians sometimes argue that `0 ^ 0 = 0` is also\n"
"a good convention. But it is not a good convention in this\n"
"game; all the later levels come out beautifully with the\n"
"convention that `0 ^ 0 = 1`."
msgstr ""
"æ•°å­¦å®¶æœ‰æ—¶ä¼šäº‰è®ºè¯´ 0 ^ 0 = 0 ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„çº¦å®šã€‚\n"
"ä½†åœ¨æœ¬æ¸¸æˆä¸­ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¥½çš„çº¦å®šï¼›æ‰€æœ‰åé¢çš„å…³å¡ä¹Ÿå…¨éƒ½éµå¾ª 0 ^ 0 = 1 çš„çº¦å®šã€‚"

#: Game.Levels.Power.L01zero_pow_zero
msgid "$0 ^ 0 = 1$"
msgstr "$0 ^ 0 = 1$"

#: Game.Levels.Power.L02zero_pow_succ
msgid "zero_pow_succ"
msgstr "zero_pow_succ"

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"We've just seen that `0 ^ 0 = 1`, but if `n`\n"
"is a successor, then `0 ^ n = 0`. We prove that here."
msgstr ""
"æˆ‘ä»¬åˆšåˆšçœ‹åˆ° `0 ^ 0 = 1`ï¼Œä½†å¦‚æœ `n` æ˜¯åç»§æ•°ï¼Œ\n"
"åˆ™ `0 ^ n = 0`ã€‚æˆ‘ä»¬å°†åœ¨è¿™é‡Œè¯æ˜è¿™ä¸€ç‚¹ã€‚"

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"`pow_succ a b : a ^ (succ b) = a ^ b * a` is one of the\n"
"two axioms defining exponentiation in this game."
msgstr "`pow_succ a b : a ^ (succ b) = a ^ b * a` æ˜¯å®šä¹‰è¿™ä¸ªæ¸¸æˆä¸­å¹‚çš„ä¸¤ä¸ªå…¬ç†ä¸­çš„ä¸€ä¸ªã€‚"

#: Game.Levels.Power.L02zero_pow_succ
msgid ""
"Although $0^0=1$ in this game, $0^n=0$ if $n>0$, i.e., if\n"
"$n$ is a successor."
msgstr "è™½ç„¶åœ¨è¿™ä¸ªæ¸¸æˆä¸­ $0^0=1$ï¼Œä½†å¦‚æœ $n>0$ï¼Œå³å¦‚æœ $n$ æ˜¯åç»§æ•°ï¼Œé‚£ä¹ˆ $0^n=0$ã€‚"

#: Game.Levels.Power.L02zero_pow_succ
msgid "For all numbers $m$, $0 ^{\\operatorname{succ} (m)} = 0$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ã€$0 ^{\\operatorname{succ} (m)} = 0$ã€‚"

#: Game.Levels.Power.L03pow_one
msgid "pow_one"
msgstr "pow_one"

#: Game.Levels.Power.L03pow_one
msgid ""
"`pow_one a` says that `a ^ 1 = a`.\n"
"\n"
"Note that this is not quite true by definition: `a ^ 1` is\n"
"defined to be `a ^ 0 * a` so it's `1 * a`, and to prove\n"
"that this is equal to `a` you need to use induction somewhere."
msgstr ""
"`pow_one a` è¡¨ç¤º `a ^ 1 = a`ã€‚\n"
"\n"
"è¯·æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯å®Œå…¨æ ¹æ®å®šä¹‰æ¥çš„ï¼š`a ^ 1` è¢«å®šä¹‰ä¸º `a ^ 0 * a`ï¼Œæ‰€ä»¥å®ƒæ˜¯ `1 * a`ï¼Œè¦è¯æ˜è¿™ç­‰äº `a`ï¼Œ"
"ä½ éœ€è¦åœ¨æŸå¤„ä½¿ç”¨æ•°å­¦å½’çº³ã€‚"

#: Game.Levels.Power.L03pow_one
msgid "For all naturals $a$, $a ^ 1 = a$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$a ^ 1 = a$ã€‚"

#: Game.Levels.Power.L04one_pow
msgid "one_pow"
msgstr "one_pow"

#: Game.Levels.Power.L04one_pow
msgid "`one_pow n` is a proof that $1^n=1$."
msgstr "`one_pow n` æ˜¯ $1^n=1$ çš„è¯æ˜ã€‚"

#: Game.Levels.Power.L04one_pow
msgid "For all naturals $m$, $1 ^ m = 1$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ã€$1 ^ m = 1$ã€‚"

#: Game.Levels.Power.L05pow_two
msgid "pow_two"
msgstr "pow_two"

#: Game.Levels.Power.L05pow_two
msgid "Note: this lemma will be useful for the final boss!"
msgstr "æ³¨æ„ï¼šè¿™ä¸ªå¼•ç†å¯¹äºè§£å†³æœ€ç»ˆçš„ Boss å¾ˆæœ‰ç”¨ï¼"

#: Game.Levels.Power.L05pow_two
msgid "`pow_two a` says that `a ^ 2 = a * a`."
msgstr "`pow_two a` ä»£è¡¨äº† `a ^ 2 = a * a`ã€‚"

#: Game.Levels.Power.L05pow_two
msgid "For all naturals $a$, $a ^ 2 = a \\times a$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$a ^ 2 = a \\times a$ã€‚"

#: Game.Levels.Power.L06pow_add
msgid "pow_add"
msgstr "pow_add"

#: Game.Levels.Power.L06pow_add
msgid ""
"Let's now begin our approach to the final boss,\n"
"by proving some more subtle facts about powers."
msgstr "ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹é€šè¿‡è¯æ˜ä¸€äº›å…³äºå¹‚çš„æ›´å¾®å¦™çš„äº‹å®æ¥æ¥è¿‘æœ€ç»ˆçš„bossã€‚"

#: Game.Levels.Power.L06pow_add
msgid "`pow_add a m n` is a proof that $a^{m+n}=a^ma^n.$"
msgstr "`pow_add a m n` æ˜¯ $a^{m+n}=a^ma^n$ çš„è¯æ˜ã€‚"

#: Game.Levels.Power.L06pow_add
msgid "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$."
msgstr "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$m$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $a^{m + n} = a ^ m  a ^ n$ ã€‚"

#: Game.Levels.Power.L07mul_pow
msgid "mul_pow"
msgstr "mul_pow"

#: Game.Levels.Power.L07mul_pow
msgid ""
"The music gets ever more dramatic, as we explore\n"
"the interplay between exponentiation and multiplication.\n"
"\n"
"If you're having trouble exchanging the right `x * y`\n"
"because `rw [mul_comm]` swaps the wrong multiplication,\n"
"then read the documentation of `rw` for tips on how to fix this."
msgstr ""
"å½“æˆ‘ä»¬æ¢ç´¢æ—¶ï¼ŒéŸ³ä¹å˜å¾—æ›´åŠ æˆå‰§åŒ–\n"
"æ±‚å¹‚å’Œä¹˜æ³•ä¹‹é—´çš„ç›¸äº’ä½œç”¨ã€‚\n"
"\n"
"å¦‚æœæ‚¨åœ¨æ›´æ¢æ­£ç¡®çš„ `x * y` æ—¶é‡åˆ°é—®é¢˜\n"
"å› ä¸º `rw [mul_comm]` äº¤æ¢äº†é”™è¯¯çš„ä¹˜æ³•ï¼Œ\n"
"ç„¶åé˜…è¯» `rw` çš„æ–‡æ¡£ä»¥è·å–æœ‰å…³å¦‚ä½•è§£å†³æ­¤é—®é¢˜çš„æç¤ºã€‚"

#: Game.Levels.Power.L07mul_pow
msgid "`mul_pow a b n` is a proof that $(ab)^n=a^nb^n.$"
msgstr "`mul_pow a b n` æ˜¯ $(ab)^n=a^nb^n.$ çš„è¯æ˜"

#: Game.Levels.Power.L07mul_pow
msgid "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$."
msgstr "å¯¹äºæ‰€æœ‰çš„è‡ªç„¶æ•° $a$ã€$b$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $(ab) ^ n = a ^ nb ^ n$ã€‚"

#: Game.Levels.Power.L08pow_pow
msgid "pow_pow"
msgstr "pow_pow"

#: Game.Levels.Power.L08pow_pow
msgid ""
"One of the best named levels in the game, a savage `pow_pow`\n"
"sub-boss appears as the music reaches a frenzy. What\n"
"else could there be to prove about powers after this?"
msgstr ""
"æ¸¸æˆä¸­æœ€åå‰¯å…¶å®çš„å…³å¡ä¹‹ä¸€ã€‚\n"
"éšç€éŸ³ä¹è¾¾åˆ°ç‹‚çƒ­ï¼Œä¸€ä¸ªå‡¶çŒ›çš„ `pow_pow` å°bosså‡ºç°äº†ã€‚\n"
"åœ¨è¿™ä¹‹åï¼Œè¿˜æœ‰ä»€ä¹ˆå…³äºå¹‚çš„æ€§è´¨éœ€è¦è¯æ˜å‘¢ï¼Ÿ"

#: Game.Levels.Power.L08pow_pow
msgid "`pow_pow a m n` is a proof that $(a^m)^n=a^{mn}.$"
msgstr "`pow_pow a m n` æ˜¯ $(a^m)^n=a^{mn}$ çš„è¯æ˜ã€‚"

#: Game.Levels.Power.L08pow_pow
msgid "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$."
msgstr "å¯¹äºæ‰€æœ‰å¤©ç„¶ $a$ã€$m$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $(a ^ m) ^ n = a ^ {mn}$ã€‚"

#: Game.Levels.Power.L08pow_pow
msgid ""
"The music dies down. Is that it?\n"
"\n"
"Course it isn't, you can\n"
"clearly see that there are two worlds left.\n"
"\n"
"A passing mathematician says that mathematicians don't have a name\n"
"for the structure you just constructed. You feel cheated.\n"
"\n"
"Suddenly the music starts up again. This really is the final boss."
msgstr ""
"éŸ³ä¹æ¸æ¸å¹³æ¯ã€‚è¿™å°±ç»“æŸäº†å—ï¼Ÿ\n"
"\n"
"å½“ç„¶ä¸æ˜¯ï¼Œä½ å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°è¿˜æœ‰ä¸¤ä¸ªä¸–ç•Œæ²¡æœ‰æ¢ç´¢ã€‚\n"
"\n"
"ä¸€ä½è·¯è¿‡çš„æ•°å­¦å®¶è¯´ï¼Œä½ åˆšåˆšæ„å»ºçš„ç»“æ„åªæ˜¯ä¸ªæ— åå°å’ã€‚ä½ æ„Ÿåˆ°æœ‰äº›è¢«æ„šå¼„äº†ã€‚\n"
"\n"
"çªç„¶ï¼ŒéŸ³ä¹å†æ¬¡å“èµ·ã€‚è¿™çœŸçš„æ˜¯æœ€ç»ˆçš„Bossã€‚"

#: Game.Levels.Power.L09add_sq
msgid "add_sq"
msgstr "add_sq"

#: Game.Levels.Power.L09add_sq
msgid "[final boss music]"
msgstr "ã€æœ€ç»ˆBossèƒŒæ™¯éŸ³ä¹ã€‘"

#: Game.Levels.Power.L09add_sq
msgid "`add_sq a b` is the statement that $(a+b)^2=a^2+b^2+2ab.$"
msgstr "`add_sq a b` æ˜¯ $(a+b)^2=a^2+b^2+2ab$ çš„è¯æ˜ã€‚"

#: Game.Levels.Power.L09add_sq
msgid ""
"For all numbers $a$ and $b$, we have\n"
"$$(a+b)^2=a^2+b^2+2ab.$$"
msgstr ""
"å¯¹äºæ‰€æœ‰æ•°å­— $a$ å’Œ $b$ï¼Œæˆ‘ä»¬æœ‰\n"
"$$(a+b)^2=a^2+b^2+2ab.$$"

#: Game.Levels.Power.L09add_sq
msgid ""
"It's all over! You have proved a theorem which has tripped up\n"
"schoolkids for generations (some of them think $(a+b)^2=a^2+b^2$:\n"
"this is \"the freshman's dream\").\n"
"\n"
"How many rewrites did you use? I can do it in 12.\n"
"\n"
"But wait! This boss is stirring...and mutating into a second more powerful form!"
msgstr ""
"ä¸€åˆ‡éƒ½ç»“æŸäº†ï¼ä½ å·²ç»è¯æ˜äº†ä¸€ä¸ªå›°æ‰°äº†å‡ ä»£å­¦ç”Ÿçš„å®šç†\n"
"ï¼ˆä»–ä»¬ä¸­çš„ä¸€äº›äººè®¤ä¸º $(a+b)^2=a^2+b^2$ ï¼šè¿™å°±æ˜¯â€œæ–°ç”Ÿçš„é”™è§‰â€ï¼‰ã€‚\n"
"\n"
"ä½ ç”¨äº†å¤šå°‘æ¬¡é‡å†™ï¼Ÿæˆ‘å¯ä»¥ç”¨12æ¬¡åšåˆ°ã€‚\n"
"\n"
"ä½†ç­‰ç­‰ï¼è¿™ä¸ªBossè¢«æ¿€æ€’äº†â€¦â€¦å¹¶ä¸”å˜å¼‚æˆç¬¬äºŒç§æ›´å¼ºå¤§çš„å½¢å¼ï¼"

#: Game.Levels.Power.L10FLT
msgid "Fermat's Last Theorem"
msgstr "è´¹é©¬å¤§å®šç†"

#: Game.Levels.Power.L10FLT
msgid ""
"We now have enough to state a mathematically accurate, but slightly\n"
"clunky, version of Fermat's Last Theorem.\n"
"\n"
"Fermat's Last Theorem states that if $x,y,z>0$ and $m \\geq 3$ then $x^m+y^m\\not =z^m$.\n"
"If you didn't do inequality world yet then we can't talk about $m \\geq 3$,\n"
"so we have to resort to the hack of using `n + 3` for `m`,\n"
"which guarantees it's big enough. Similarly instead of `x > 0` we\n"
"use `a + 1`.\n"
"\n"
"This level looks superficially like other levels we have seen,\n"
"but the shortest solution known to humans would translate into\n"
"many millions of lines of Lean code. The author of this game,\n"
"Kevin Buzzard, is working on translating the proof by Wiles\n"
"and Taylor into Lean, although this task will take many years.\n"
"\n"
"## CONGRATULATIONS!\n"
"\n"
"You've finished the main quest of the natural number game!\n"
"If you would like to learn more about how to use Lean to\n"
"prove theorems in mathematics, then take a look\n"
"at [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\n"
"an interactive textbook which you can read in your browser,\n"
"and which explains how to work with many more mathematical concepts in Lean."
msgstr ""
"æˆ‘ä»¬ç°åœ¨å·²ç»æœ‰è¶³å¤Ÿçš„æ¡ä»¶æ¥é™ˆè¿°ä¸€ä¸ªæ•°å­¦ä¸Šå‡†ç¡®ä½†æœ‰äº›ç¬¨æ‹™çš„è´¹é©¬å¤§å®šç†äº†ã€‚\n"
"\n"
"è´¹é©¬å¤§å®šç†æŒ‡å‡ºï¼Œå¦‚æœ $x,y,z>0$ ä¸” $m \\geq 3$ï¼Œé‚£ä¹ˆ $x^m+y^m \\not = z^m$ã€‚\n"
"å¦‚æœä½ è¿˜æ²¡å­¦ä¹ è¿‡ä¸ç­‰å¼ä¸–ç•Œï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸èƒ½è®¨è®º $m \\geq 3$ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¾—ä¸é‡‡ç”¨ä½¿ç”¨ `n + 3` ä»£æ›¿ `m` çš„"
"æ–¹æ³•ï¼Œè¿™ä¿è¯äº†å®ƒè¶³å¤Ÿå¤§ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ç”¨ `a + 1` ä»£æ›¿ `x > 0`ã€‚\n"
"\n"
"è¿™ä¸€å…³è¡¨é¢ä¸Šçœ‹èµ·æ¥åƒæˆ‘ä»¬è§è¿‡çš„å…¶ä»–å…³å¡ï¼Œä½†äººç±»å·²çŸ¥çš„æœ€çŸ­è§£æ³•ä¹Ÿå°†è½¬åŒ–ä¸ºæ•°ç™¾ä¸‡è¡Œçš„ Lean ä»£ç ã€‚\n"
"è¿™ä¸ªæ¸¸æˆçš„ä½œè€…ï¼ŒKevin Buzzardï¼Œæ­£åœ¨å°† Wiles å’Œ Taylor çš„è¯æ˜ç¿»è¯‘æˆ Leanï¼Œå°½ç®¡è¿™é¡¹ä»»åŠ¡å°†èŠ±è´¹è®¸å¤šå¹´ã€‚\n"
"\n"
"## ç¥è´ºï¼\n"
"\n"
"ä½ å·²ç»å®Œæˆäº†è‡ªç„¶æ•°æ¸¸æˆçš„ä¸»çº¿ä»»åŠ¡ï¼\n"
"å¦‚æœä½ æƒ³äº†è§£æ›´å¤šå…³äºå¦‚ä½•ä½¿ç”¨ Lean æ¥è¯æ˜æ•°å­¦å®šç†çš„ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹ [Mathematics In Lean](https://"
"leanprover-community.github.io/mathematics_in_lean/)ï¼Œ\n"
"è¿™æ˜¯ä¸€æœ¬äº’åŠ¨æ•™ç§‘ä¹¦ï¼Œä½ å¯ä»¥åœ¨æµè§ˆå™¨ä¸­é˜…è¯»å®ƒï¼Œå®ƒè§£é‡Šäº†å¦‚ä½•åœ¨ Lean ä¸­å¤„ç†æ›´å¤šçš„æ•°å­¦æ¦‚å¿µã€‚"

#: Game.Levels.Power.L10FLT
msgid ""
"`xyzzy` is an ancient magic spell, believed to be the origin of the\n"
"modern word `sorry`. The game won't complain - or notice - if you\n"
"prove anything with `xyzzy`."
msgstr ""
"`xyzzy` æ˜¯ä¸€ä¸ªå¤è€çš„é­”æ³•å’’è¯­ï¼Œè¢«è®¤ä¸ºæ˜¯ç°ä»£è¯æ±‡ `sorry` çš„èµ·æºã€‚æ¸¸æˆä¸ä¼šå‘ç°â€”â€”æˆ–è€…æ³¨æ„åˆ°ä½ ç”¨ `xyzzy` "
"è¯æ˜ä»»ä½•ä¸œè¥¿ã€‚"

#: Game.Levels.Power.L10FLT
msgid ""
"For all naturals $a$ $b$ $c$ and $n$, we have\n"
"$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$"
msgstr ""
"å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ $b$ $c$ å’Œ $n$ï¼Œæˆ‘ä»¬æœ‰\n"
"$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$"

#: Game.Levels.Power.L10FLT
msgid ""
"Congratulations! You have proved Fermat's Last Theorem!\n"
"\n"
"Either that, or you used magic..."
msgstr ""
"æ­å–œï¼æ‚¨å·²ç»è¯æ˜äº†è´¹é©¬å¤§å®šç†ï¼\n"
"\n"
"è¦ä¹ˆå°±æ˜¯ï¼Œè¦ä¹ˆä½ ä½¿ç”¨äº†é­”æ³•â€¦â€¦"

#: Game.Levels.Power
msgid "Power World"
msgstr "å¹‚ä¸–ç•Œ"

#: Game.Levels.Power
msgid ""
"This world introduces exponentiation. If you want to define `37 ^ n`\n"
"then, as always, you will need to know what `37 ^ 0` is, and\n"
"what `37 ^ (succ d)` is, given only `37 ^ d`.\n"
"\n"
"You can probably guess the names of the general theorems:\n"
"\n"
"  * `pow_zero (a : â„•) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : â„•) : a ^ succ b = a ^ b * a`\n"
"\n"
"Using only these, can you get past the final boss level?\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship\n"
"in the summer of 2019. Thanks to Sian and also thanks to Imperial\n"
"College for funding her."
msgstr ""
"è¿™ä¸ªä¸–ç•Œå¼•å…¥äº†å¹‚è¿ç®—ã€‚å¦‚æœä½ æƒ³å®šä¹‰ `37 ^ n`ï¼Œé‚£ä¹ˆåƒå¾€å¸¸ä¸€æ ·ï¼Œä½ éœ€è¦çŸ¥é“ `37 ^ 0` æ˜¯ä»€ä¹ˆï¼Œä»¥åŠåœ¨ä»…çŸ¥ "
"`37 ^ d` çš„æƒ…å†µä¸‹ï¼Œ`37 ^ (succ d)` æ˜¯ä»€ä¹ˆã€‚\n"
"\n"
"ä½ å¯èƒ½å·²ç»çŒœåˆ°äº†è¿™äº›ä¸€èˆ¬å®šç†çš„åç§°ï¼š\n"
"\n"
"  * `pow_zero (a : â„•) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : â„•) : a ^ succ b = a ^ b * a`\n"
"\n"
"ä»…ç”¨è¿™äº›å®šç†ï¼Œä½ èƒ½é€šè¿‡æœ€åçš„bosså…³å¡å—ï¼Ÿ\n"
"\n"
"è¿™ä¸ªä¸–ç•Œä¸­çš„å…³å¡ç”±å¸å›½ç†å·¥å­¦é™¢çš„ UROP å­¦ç”Ÿ Sian Carey åœ¨ 2019 å¹´å¤å¤©è®¾è®¡ï¼Œå¥¹çš„é¡¹ç›®å¾—åˆ°äº† Mary Lister "
"McCammon å¥–å­¦é‡‘çš„èµ„åŠ©ã€‚æ„Ÿè°¢ Sianï¼Œä¹Ÿæ„Ÿè°¢å¸å›½ç†å·¥å­¦é™¢å¯¹å¥¹çš„èµ„åŠ©ã€‚"

#: Game.Levels.Implication.L01exact
msgid "The `exact` tactic"
msgstr "`exact` ç­–ç•¥"

#: Game.Levels.Implication.L01exact
msgid ""
"## Summary\n"
"\n"
"If the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x = 37` and you have a hypothesis `h : x = 37`\n"
"then `exact h` will solve the goal.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `x + 0 = x` then `exact add_zero x` will close the goal.\n"
"\n"
"### Exact needs to be exactly right\n"
"\n"
"Note that `exact add_zero` will *not work* in the previous example;\n"
"for `exact h` to work, `h` has to be *exactly* a proof of the goal.\n"
"`add_zero` is a proof of `âˆ€ n, n + 0 = n` or, if you like,\n"
"a proof of `? + 0 = ?` where `?` needs to be supplied by the user.\n"
"This is in contrast to `rw` and `apply`, which will \\\"guess the inputs\\\"\n"
"if necessary. If the goal is `x + 0 = x` then `rw [add_zero]`\n"
"and `rw [add_zero x]` will both change the goal to `x = x`,\n"
"because `rw` guesses the input to the function `add_zero`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœç›®æ ‡æ˜¯ `P`ï¼Œé‚£ä¹ˆå¦‚æœ `h` æ˜¯ `P` çš„è¯æ˜ï¼Œ`exact h` å°†è¯æ˜ç›®æ ‡ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"å¦‚æœç›®æ ‡æ˜¯ `x = 37`ï¼Œå‡è®¾æ˜¯ `h : x = 37`\n"
"åˆ™ `exact h` å°†è§£å†³ç›®æ ‡ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"å¦‚æœç›®æ ‡æ˜¯ `x + 0 = x`ï¼Œé‚£ä¹ˆ `exact add_zero x` å°†è¯æ˜ç›®æ ‡ã€‚\n"
"\n"
"### `exact`å¿…é¡»å®Œå…¨åŒ¹é…\n"
"è¯·æ³¨æ„ï¼Œ`exact add_zero` åœ¨ä¸Šä¾‹ä¸­*ä¸èµ·ä½œç”¨*ï¼›\n"
"è¦è®© `exact h` èµ·ä½œç”¨ï¼Œ`h` å¿…é¡»å’Œç›®æ ‡çš„è¯æ˜*å®Œå…¨*åŒ¹é…ã€‚\n"
"`add_zero` æ˜¯ `âˆ€ n, n + 0 = n` çš„è¯æ˜ï¼Œæˆ–è€…ï¼Œå¦‚æœä½ æƒ³è¦çš„è¯ä¹Ÿå¯ä»¥æ˜¯\n"
"`? + 0 = ?` çš„è¯æ˜ï¼Œå…¶ä¸­ `?` éœ€è¦ç”±ä½ æä¾›ã€‚\n"
"è¿™ä¸ `rw` å’Œ `apply` ä¸åŒï¼Œå®ƒä»¬ä¼šåœ¨å¿…è¦æ—¶â€œçŒœæµ‹è¾“å…¥â€ã€‚å¦‚æœç›®æ ‡æ˜¯ `x + 0 = x`ï¼Œé‚£ä¹ˆ `rw [add_zero]`\n"
"å’Œ `rw [add_zero x]` éƒ½ä¼šå°†ç›®æ ‡æ”¹ä¸º `x = x`ã€\n"
"å› ä¸º `rw` çŒœåˆ°äº†å‡½æ•° `add_zero` çš„è¾“å…¥ã€‚"

#: Game.Levels.Implication.L01exact
msgid ""
"In this world we'll learn how to prove theorems of the form $P\\implies Q$.\n"
"In other words, how to prove theorems of the form \"if $P$ is true, then $Q$ is true.\"\n"
"To do that we need to learn some more tactics.\n"
"\n"
"The `exact` tactic can be used to close a goal which is exactly one of\n"
"the hypotheses."
msgstr ""
"åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è¯æ˜å½¢å¼ä¸º $P\\implies Q$ çš„å®šç†ã€‚\n"
"æ¢å¥è¯è¯´ï¼Œå°±æ˜¯å¦‚ä½•è¯æ˜â€œå¦‚æœ $P$ ä¸ºçœŸï¼Œåˆ™ $Q$ ä¹Ÿä¸ºçœŸâ€çš„å½¢å¼çš„å®šç†ã€‚\n"
"ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å­¦ä¹ ä¸€äº›æ›´å¤šçš„ç­–ç•¥ã€‚\n"
"\n"
"`exact` ç­–ç•¥å¯ä»¥ç”¨æ¥è§£å†³ä¸€ä¸ªå­˜åœ¨äºå‡è®¾ä¸­çš„ç›®æ ‡ã€‚"

#: Game.Levels.Implication.L01exact
msgid "Assuming $x+y=37$ and $3x+z=42$, we have $x+y=37$."
msgstr "å‡è®¾ $x+y=37$ å’Œ $3x+z=42$ï¼Œæˆ‘ä»¬æœ‰ $x+y=37$ã€‚"

#: Game.Levels.Implication.L01exact
msgid "The goal in this level is one of our hypotheses. Solve the goal by executing `exact h1`."
msgstr "è¿™ä¸€å±‚çš„ç›®æ ‡æ˜¯æˆ‘ä»¬çš„ä¸€ä¸ªå‡è®¾ã€‚é€šè¿‡æ‰§è¡Œ `exact h1` æ¥è§£å†³ç›®æ ‡ã€‚"

#: Game.Levels.Implication.L02exact2
msgid "`exact` practice."
msgstr "`exact` ç»ƒä¹ ã€‚"

#: Game.Levels.Implication.L02exact2
msgid ""
"If the goal is not *exactly* a hypothesis, we can sometimes\n"
"use rewrites to fix things up."
msgstr "å¦‚æœç›®æ ‡å¹¶ä¸ *å®Œå…¨* æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œæˆ‘ä»¬æœ‰æ—¶å¯ä»¥ä½¿ç”¨é‡å†™æ¥è°ƒæ•´ã€‚"

#: Game.Levels.Implication.L02exact2
msgid "Assuming $0+x=(0+y)+2$, we have $x=y+2$."
msgstr "å‡è®¾ $0+x=(0+y)+2$ï¼Œæˆ‘ä»¬æœ‰ $x=y+2$ã€‚"

#: Game.Levels.Implication.L02exact2
msgid ""
"You can use `rw [zero_add] at Â«{h}Â»` to rewrite at `Â«{h}Â»` instead\n"
"of at the goal."
msgstr "ä½ å¯ä»¥ä½¿ç”¨ `rw [zero_add] at Â«{h}Â»` æ¥åœ¨ `Â«{h}Â»` å¤„è¿›è¡Œé‡å†™ï¼Œè€Œä¸æ˜¯åœ¨ç›®æ ‡å¤„è¿›è¡Œã€‚"

#: Game.Levels.Implication.L02exact2
msgid ""
"Do that again!\n"
"\n"
"`rw [zero_add] at Â«{h}Â»` tries to fill in\n"
"the arguments to `zero_add` (finding `Â«{x}Â»`) then it replaces all occurences of\n"
"`0 + Â«{x}Â»` it finds. Therefor, it did not rewrite `0 + Â«{y}Â»`, yet."
msgstr ""
"å†åšä¸€æ¬¡ï¼\n"
"\n"
"`rw [zero_add] at Â«{h}Â»` è¯•å›¾å¡«å…… `zero_add` çš„å‚æ•°ï¼ˆæ‰¾åˆ° `Â«{x}Â»`ï¼‰ï¼Œç„¶åæ›¿æ¢å®ƒæ‰¾åˆ°çš„æ‰€æœ‰ `0 + "
"Â«{x}Â»` å‡ºç°çš„åœ°æ–¹ã€‚å› æ­¤ï¼Œ`0 + Â«{y}Â»`è¿˜æ²¡æœ‰è¢«é‡å†™ ã€‚"

#: Game.Levels.Implication.L02exact2
msgid ""
"Now you could finish with `rw [Â«{h}Â»]` then `rfl`, but `exact Â«{h}Â»`\n"
"does it in one line."
msgstr "ç°åœ¨ä½ å¯ä»¥ç”¨ `rw [Â«{h}Â»]` ç„¶å `rfl` æ¥å®Œæˆè¯æ˜ï¼Œä½† `exact Â«{h}Â»` å¯ä»¥åœ¨ä¸€è¡Œä¸­åšåˆ°åŒæ ·çš„äº‹ã€‚"

#: Game.Levels.Implication.L02exact2
msgid ""
"Here's a two-line proof:\n"
"```\n"
"repeat rw [zero_add] at h\n"
"exact h\n"
"```"
msgstr ""
"è¿™æ˜¯ä¸€ä¸ªä¸¤è¡Œè¯æ˜ï¼š\n"
"```\n"
"repeat rw [zero_add] at h\n"
"exact h\n"
"```"

#: Game.Levels.Implication.L03apply
msgid "The `apply` tactic."
msgstr "`apply` ç­–ç•¥ã€‚"

#: Game.Levels.Implication.L03apply
msgid ""
"## Summary\n"
"\n"
"If `t : P â†’ Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\n"
"then `apply t at h` will change `h` to a proof of `Q`. The idea is that if\n"
"you know `P` is true, then you can deduce from `t` that `Q` is true.\n"
"\n"
"If the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\n"
"goal to `P`. The idea here is that if you want to prove `Q`, then by `t`\n"
"it suffices to prove `P`, so you can reduce the goal to proving `P`.\n"
"\n"
"### Example:\n"
"\n"
"`succ_inj x y` is a proof that `succ x = succ y â†’ x = y`.\n"
"\n"
"So if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\n"
"then `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\n"
"You could write `apply succ_inj (a + 37) (b + 42) at h`\n"
"but Lean is smart enough to figure out the inputs to `succ_inj`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `a * b = 7`, then `apply succ_inj` will turn the\n"
"goal into `succ (a * b) = succ 7`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœ `t : P â†’ Q` æ˜¯ä¸€ä¸ª $P\\implies Q$ çš„è¯æ˜ï¼Œè€Œ `h : P` æ˜¯ä¸€ä¸ª `P` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `apply t at h` ä¼š"
"å°† `h` è½¬æ¢ä¸ºè¯æ˜ `Q`ã€‚å…¶åŸç†æ˜¯ï¼Œå¦‚æœæ‚¨çŸ¥é“ `P` ä¸ºçœŸï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥ä» `t` æ¨æ–­å‡º `Q` ä¸ºçœŸã€‚\n"
"\n"
"å¦‚æœ*ç›®æ ‡*æ˜¯ `Q`ï¼Œé‚£ä¹ˆ `apply t` ä¼šâ€œé€†å‘æ¨ç†â€å¹¶å°†ç›®æ ‡è½¬æ¢ä¸º `P`ã€‚åœ¨è¿™é‡Œï¼Œå¦‚æœæ‚¨æƒ³è¯æ˜ `Q`ï¼Œé‚£ä¹ˆæ ¹æ® "
"`t`ï¼Œåªéœ€è¯æ˜ `P` å³å¯ï¼Œå› æ­¤æ‚¨å¯ä»¥å°†ç›®æ ‡ç®€åŒ–ä¸ºè¯æ˜ `P`ã€‚\n"
"\n"
"### ç¤ºä¾‹ï¼š\n"
"\n"
"`succ_inj x y` æ˜¯ä¸€ä¸ª `succ x = succ y â†’ x = y` çš„è¯æ˜ã€‚\n"
"\n"
"å› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªå‡è®¾ `h : succ (a + 37) = succ (b + 42)`ï¼Œé‚£ä¹ˆ `apply succ_inj at h` ä¼šå°† `h` è½¬æ¢"
"ä¸º `a + 37 = b + 42`ã€‚æ‚¨å¯ä»¥å†™ `apply succ_inj (a + 37) (b + 42) at h`ï¼Œä½† Lean è¶³å¤Ÿèªæ˜ï¼Œå¯ä»¥è‡ªè¡Œæ¨"
"æ–­å‡º `succ_inj` çš„è¾“å…¥ã€‚\n"
"\n"
"### ç¤ºä¾‹ï¼š\n"
"\n"
"å¦‚æœç›®æ ‡æ˜¯ `a * b = 7`ï¼Œé‚£ä¹ˆ `apply succ_inj` ä¼šå°†ç›®æ ‡è½¬æ¢ä¸º `succ (a * b) = succ 7`ã€‚"

#: Game.Levels.Implication.L03apply
msgid ""
"In this level one of our hypotheses is an *implication*. We can use this\n"
"hypothesis with the `apply` tactic."
msgstr "åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬çš„ä¸€ä¸ªå‡è®¾æ˜¯ä¸€ä¸ª*è•´å«å¼*ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `apply` ç­–ç•¥æ¥åˆ©ç”¨è¿™ä¸ªå‡è®¾ã€‚"

#: Game.Levels.Implication.L03apply
msgid "If $x=37$ and we know that $x=37\\implies y=42$ then we can deduce $y=42$."
msgstr "å¦‚æœ $x=37$ å¹¶ä¸”æˆ‘ä»¬çŸ¥é“ $x=37 \\implies y=42$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨å¯¼å‡º $y=42$ã€‚"

#: Game.Levels.Implication.L03apply
msgid "Start with `apply h2 at h1`. This will change `h1` to `y = 42`."
msgstr "ä» `apply h2 at h1` å¼€å§‹ã€‚è¿™å°†ä¼šæŠŠ `h1` æ”¹ä¸º `y = 42`ã€‚"

#: Game.Levels.Implication.L03apply
msgid "Now finish using the `exact` tactic."
msgstr "ç°åœ¨ä½¿ç”¨ `exact` ç­–ç•¥å®Œæˆè¯æ˜ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid "succ_inj : the successor function is injective"
msgstr "succ_inj ï¼šåç»§æ•°æ˜¯å•å°„çš„"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"If `a` and `b` are numbers, then `succ_inj a b` is a proof\n"
"that `succ a = succ b` implies `a = b`. Click on this theorem in the *Peano*\n"
"tab for more information.\n"
"\n"
"Peano had this theorem as an axiom, but in Algorithm World\n"
"we will show how to prove it in Lean. Right now let's just assume it,\n"
"and let's prove $x+1=4 \\implies x=3$ using it. Again, we will proceed\n"
"by manipulating our hypothesis until it becomes the goal. I will\n"
"walk you through this level."
msgstr ""
"å¦‚æœ `a` å’Œ `b` æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ `succ_inj a b` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨æ˜ `succ a = succ b` æ„å‘³ç€ `a = b`ã€‚ç‚¹å‡» "
"*Peano* æ ‡ç­¾ä¸­çš„è¿™ä¸ªå®šç†ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚\n"
"\n"
"çš®äºšè¯ºå°†è¿™ä¸ªå®šç†ä½œä¸ºä¸€ä¸ªå…¬ç†ï¼Œä½†åœ¨ç®—æ³•ä¸–ç•Œä¸­æˆ‘ä»¬å°†å±•ç¤ºå¦‚ä½•åœ¨ Lean ä¸­è¯æ˜å®ƒã€‚\n"
"ç°åœ¨è®©æˆ‘ä»¬å…ˆå‡è®¾å®ƒï¼Œç„¶åè®©æˆ‘ä»¬ä½¿ç”¨å®ƒè¯æ˜ $x+1=4 \\implies x=3$ã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†é€šè¿‡æ“çºµæˆ‘ä»¬çš„å‡è®¾ç›´åˆ°"
"å®ƒå˜æˆç›®æ ‡æ¥è¿›è¡Œã€‚æˆ‘å°†å¼•å¯¼ä½ é€šè¿‡è¿™ä¸ªå…³å¡ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"# Statement\n"
"\n"
"If $a$ and $b$ are numbers, then\n"
"`succ_inj a b` is the proof that\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"## More technical details\n"
"\n"
"There are other ways to think about `succ_inj`.\n"
"\n"
"You can think about `succ_inj` itself as a function which takes two\n"
"numbers $$a$$ and $$b$$ as input, and outputs a proof of\n"
"$ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n"
"\n"
"You can think of `succ_inj` itself as a proof; it is the proof\n"
"that `succ` is an injective function. In other words,\n"
"`succ_inj` is a proof of\n"
"$\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b"
"$.\n"
"\n"
"`succ_inj` was postulated as an axiom by Peano, but\n"
"in Lean it can be proved using `pred`, a mathematically\n"
"pathological function."
msgstr ""
"# é™ˆè¿°\n"
"\n"
"å¦‚æœ \\( a \\) å’Œ \\( b \\) æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ\n"
"`succ_inj a b` æ˜¯\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ çš„è¯æ˜ã€‚\n"
"\n"
"## æ›´å¤šæŠ€æœ¯ç»†èŠ‚\n"
"\n"
"ä½ å¯ä»¥ç”¨å…¶ä»–æ–¹å¼æ€è€ƒ `succ_inj`ã€‚\n"
"\n"
"ä½ å¯ä»¥æŠŠ `succ_inj` æœ¬èº«æƒ³è±¡æˆä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªæ•°å­— $$a$$ å’Œ $$b$$ ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¾“å‡º\n"
"$ (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ çš„è¯æ˜ã€‚\n"
"\n"
"ä½ å¯ä»¥æŠŠ `succ_inj` æœ¬èº«çœ‹ä½œæ˜¯ä¸€ä¸ªè¯æ˜ï¼›å®ƒæ˜¯ `succ` æ˜¯ä¸€ä¸ªå•å°„å‡½æ•°çš„è¯æ˜ã€‚æ¢å¥è¯è¯´ï¼Œ\n"
"`succ_inj` æ˜¯\n"
"$ \\forall a, b \\in \\mathbb{N}, (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ "
"çš„è¯æ˜ã€‚\n"
"\n"
"`succ_inj` è¢«çš®äºšè¯ºå‡è®¾ä¸ºä¸€ä¸ªå…¬ç†ï¼Œä½†åœ¨ Lean ä¸­å¯ä»¥ä½¿ç”¨ `pred` æ¥è¯æ˜ï¼Œè¿™æ˜¯ä¸€ä¸ªåœ¨æ•°å­¦ä¸Šæœ‰ç—…æ€çš„å‡½æ•°ã€‚"

#: Game.Levels.Implication.L04succ_inj Game.Levels.Implication.L05succ_inj2
msgid "If $x+1=4$ then $x=3$."
msgstr "å¦‚æœ $x+1=4$ åˆ™ $x=3$ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Let's first get `h` into the form `succ x = succ 3` so we can\n"
"apply `succ_inj`. First execute `rw [four_eq_succ_three] at h`\n"
"to change the 4 on the right hand side."
msgstr ""
"é¦–å…ˆè®© `h` å˜ä¸º `succ x = succ 3` çš„å½¢å¼ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åº”ç”¨ `succ_inj`ã€‚é¦–å…ˆæ‰§è¡Œ `rw "
"[four_eq_succ_three] at h` æ¥æ”¹å˜å³æ‰‹è¾¹çš„4ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Now rewrite `succ_eq_add_one` backwards at `h`\n"
"to get the right hand side."
msgstr "ç°åœ¨åœ¨ `h` å¤„åå‘é‡å†™ `succ_eq_add_one` æ¥å¾—åˆ°å³è¾¹å¼å­ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"You can put a `â†` in front of any theorem provided to `rw` to rewrite\n"
"the other way around. Look at the docs for `rw` for an explanation. Type `â†` with `\\l`."
msgstr ""
"ä½ å¯ä»¥åœ¨æä¾›ç»™ `rw` çš„ä»»ä½•å®šç†å‰é¢æ”¾ä¸€ä¸ª `â†` æ¥è¿›è¡Œåå‘é‡å†™ã€‚æŸ¥çœ‹ `rw` çš„æ–‡æ¡£ä»¥è·å¾—è§£é‡Šã€‚ä½¿ç”¨ `\\l` "
"è¾“å…¥ `â†`ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid "Concretely: `rw [â† succ_eq_add_one] at h`."
msgstr "å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯ï¼š`rw [â† succ_eq_add_one] at h`ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"Now let's `apply` our new theorem. Execute `apply succ_inj at h`\n"
"to change `h` to a proof of `x = 3`."
msgstr ""
"ç°åœ¨è®©æˆ‘ä»¬åº”ç”¨ï¼ˆ `apply` ï¼‰æˆ‘ä»¬çš„æ–°å®šç†ã€‚æ‰§è¡Œ `apply succ_inj at h` æ¥å°† `h` å˜ä¸ºè¯æ˜ `x = 3` çš„è¯"
"æ®ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid "Now finish in one line."
msgstr "ç°åœ¨å†ç”¨ä¸€è¡Œå®Œæˆè¯æ˜ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid ""
"And now we've deduced what we wanted to prove: the goal is one of our assumptions.\n"
"Finish the level with `exact h`."
msgstr ""
"ç°åœ¨æˆ‘ä»¬å·²ç»æ¨å¯¼å‡ºäº†æˆ‘ä»¬æƒ³è¦è¯æ˜çš„äº†ï¼šç›®æ ‡æ˜¯æˆ‘ä»¬çš„å‡è®¾ä¹‹ä¸€ã€‚\n"
"ç”¨ `exact h` å®Œæˆæœ¬å…³ã€‚"

#: Game.Levels.Implication.L04succ_inj
msgid "In the next level, we'll do the same proof but backwards."
msgstr "åœ¨ä¸‹ä¸€çº§åˆ«ä¸­ï¼Œæˆ‘ä»¬å°†è¿›è¡Œç›¸åŒçš„è¯æ˜ï¼Œä½†è¦ä»åå¾€å‰è¯ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid "Arguing backwards"
msgstr "ä»åå‘å‰è¯æ˜"

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"In the last level, we manipulated the hypothesis `x + 1 = 4`\n"
"  until it became the goal `x = 3`. In this level we'll manipulate\n"
"  the goal until it becomes our hypothesis! In other words, we\n"
"  will \"argue backwards\". The `apply` tactic can do this too.\n"
"  Again I will walk you through this one (assuming you're in\n"
"  command line mode)."
msgstr ""
"åœ¨æœ€åä¸€å…³ï¼Œæˆ‘ä»¬æ“çºµäº†å‡è®¾ `x + 1 = 4`\n"
"  ç›´åˆ°æˆä¸ºç›®æ ‡ `x = 3` ã€‚åœ¨è¿™ä¸€å…³æˆ‘ä»¬å°†æ”¹å†™\n"
"  ç›®æ ‡ï¼Œç›´åˆ°å®ƒæˆä¸ºæˆ‘ä»¬çš„å‡è®¾ï¼æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬\n"
"  ä¼šâ€œä»åå‘å‰â€è¯æ˜ã€‚ `apply` ç­–ç•¥ä¹Ÿå¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚\n"
"  æˆ‘å°†å†æ¬¡å¼•å¯¼æ‚¨å®Œæˆè¿™ä¸€è¿‡ç¨‹ï¼ˆå‡è®¾æ‚¨åœ¨\n"
"  å‘½ä»¤è¡Œæ¨¡å¼ï¼‰ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid "Start with `apply succ_inj` to apply `succ_inj` to the *goal*."
msgstr "ä» `apply succ_inj` å¼€å§‹ï¼Œå°† `succ_inj` åº”ç”¨äº *goal* ï¼ˆç›®æ ‡ï¼‰ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Applying a proof of $P\\implies Q$ to the *goal* changes $Q$ to $P$.\n"
"Now try `rw [succ_eq_add_one]` to make the goal more like the hypothesis."
msgstr ""
"åº”ç”¨ä¸€ä¸ª $P\\implies Q$ çš„è¯æ˜åˆ°*ç›®æ ‡*ä¸Šï¼Œä¼šå°† $Q$ å˜ä¸º $P$ã€‚\n"
"ç°åœ¨å°è¯•ä½¿ç”¨ `rw [succ_eq_add_one]` æ¥ä½¿ç›®æ ‡æ›´åƒå‡è®¾ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Now rewrite `four_eq_succ_three` backwards to make the goal\n"
"equal to the hypothesis."
msgstr "ç°åœ¨åæ–¹å‘é‡å†™ `four_eq_succ_three` ä½¿ç›®æ ‡ç­‰äºå‡è®¾ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid "You can now finish with `exact h`."
msgstr "ç°åœ¨æ‚¨å¯ä»¥ä½¿ç”¨ `exact h` æ¥å®Œæˆè¯æ˜ã€‚"

#: Game.Levels.Implication.L05succ_inj2
msgid ""
"Many people find `apply t at h` easy, but some find `apply t` confusing.\n"
"If you find it confusing, then just argue forwards.\n"
"\n"
"You can read more about the `apply` tactic in its documentation, which you can view by\n"
"clicking on the tactic in the list on the right."
msgstr ""
"è®¸å¤šäººè§‰å¾— `apply t at h` å¾ˆå®¹æ˜“ï¼Œä½†æœ‰äº›äººè§‰å¾— `apply t` ä»¤äººå›°æƒ‘ã€‚\n"
"å¦‚æœä½ è§‰å¾—å¾ˆå›°æƒ‘ï¼Œé‚£å°±ç”¨å‰ä¸€ç§å§ã€‚\n"
"\n"
"æ‚¨å¯ä»¥åœ¨å…¶æ–‡æ¡£ä¸­é˜…è¯»æœ‰å…³ `apply` ç­–ç•¥çš„æ›´å¤šä¿¡æ¯ï¼Œæ‚¨å¯ä»¥é€šè¿‡\n"
"å•å‡»å³ä¾§åˆ—è¡¨ä¸­çš„ç­–ç•¥çš„æ–¹å¼æŸ¥çœ‹ã€‚"

#: Game.Levels.Implication.L06intro
msgid "intro"
msgstr "intro"

#: Game.Levels.Implication.L06intro
msgid ""
"## Summary\n"
"\n"
"If the goal is `P â†’ Q`, then `intro h` will introduce `h : P` as a hypothesis,\n"
"and change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\n"
"we can assume $P$ and then prove $Q$.\n"
"\n"
"### Example:\n"
"\n"
"If your goal is `x + 1 = y + 1 â†’ x = y` (the way Lean writes $x+1=y+1 \\implies x=y$)\n"
"then `intro h` will give you a hypothesis $x+1=y+1$ named `h`, and the goal\n"
"will change to $x=y$."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœç›®æ ‡æ˜¯ `P â†’ Q`ï¼Œé‚£ä¹ˆ `intro h` å°†å¼•å…¥ `h : P` ä½œä¸ºå‡è®¾ï¼Œ\n"
"å¹¶å°†ç›®æ ‡æ›´æ”¹ä¸º `Q`ã€‚ä»æ•°å­¦ä¸Šè®²ï¼Œè¦è¯æ˜ $P\\implies Q$ï¼Œ\n"
"æˆ‘ä»¬å¯ä»¥å‡è®¾ $P$ ï¼Œç„¶åè¯æ˜ $Q$ ã€‚\n"
"\n"
"### ä¾‹å­ï¼š\n"
"\n"
"å¦‚æœæ‚¨çš„ç›®æ ‡æ˜¯ `x + 1 = y + 1 â†’ x = y` ï¼ˆåœ¨Leanä¸­è¿™è¡¨ç¤º $x+1=y+1\\implies x=y$ ï¼‰\n"
"é‚£ä¹ˆ `intro h` ä¼šç»™ä½ ä¸€ä¸ªåä¸º `h` çš„å‡è®¾ $x+1=y+1$ ï¼Œç›®æ ‡\n"
"ä¹ŸåŒæ—¶æ›´æ”¹ä¸º $x=y$ã€‚"

#: Game.Levels.Implication.L06intro
msgid ""
"We have seen how to `apply` theorems and assumptions\n"
"of the form `P â†’ Q`. But what if our *goal* is of the form `P â†’ Q`?\n"
"To prove this goal, we need to know how to say \"let's assume `P` and deduce `Q`\"\n"
"in Lean. We do this with the `intro` tactic."
msgstr ""
"æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½• `apply` å½¢å¼ä¸º `P â†’ Q` çš„å®šç†å’Œå‡è®¾ã€‚\n"
"ä½†å¦‚æœæˆ‘ä»¬çš„ *ç›®æ ‡* æ˜¯å½¢å¼ä¸º `P â†’ Q` çš„å‘¢ï¼Ÿ\n"
"è¦è¯æ˜è¿™ä¸ªç›®æ ‡ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å¦‚ä½•åœ¨ Lean ä¸­è¡¨ç¤º â€œå‡è®¾ `P` å¹¶æ¨å¯¼å‡º `Q`â€ã€‚æˆ‘ä»¬ç”¨ `intro` ç­–ç•¥æ¥åšè¿™ä»¶"
"äº‹ã€‚"

#: Game.Levels.Implication.L06intro
msgid "$x=37\\implies x=37$."
msgstr "$x=37\\implies x=37$ ã€‚"

#: Game.Levels.Implication.L06intro
msgid "Start with `intro h` to assume the hypothesis and call its proof `h`."
msgstr "ä½¿ç”¨ `intro h` æ¥è®¾å‡è®¾ä¸º `h`ã€‚"

#: Game.Levels.Implication.L06intro
msgid "Now `exact h` finishes the job."
msgstr "ç°åœ¨ï¼Œç”¨ `exact h ` å®Œæˆè¯æ˜ã€‚"

#: Game.Levels.Implication.L07intro2
msgid "intro practice"
msgstr "ç»ƒä¹  `intro` ç­–ç•¥"

#: Game.Levels.Implication.L07intro2
msgid ""
"Let's see if you can use the tactics we've learnt to prove $x+1=y+1\\implies x=y$.\n"
"Try this one by yourself; if you need help then click on \"Show more help!\"."
msgstr ""
"è®©æˆ‘ä»¬çœ‹çœ‹æ‚¨èƒ½å¦åˆ©ç”¨æˆ‘ä»¬å­¦åˆ°çš„ç­–ç•¥æ¥è¯æ˜ $x+1=y+1\\implies x=y$ã€‚\n"
"å¦‚æœæ‚¨éœ€è¦å¸®åŠ©ï¼Œè¯·ç‚¹å‡» \"æ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼\"ã€‚"

#: Game.Levels.Implication.L07intro2
msgid "$x+1=y+1 \\implies x=y$."
msgstr "$x+1=y+1\\implies x=y$ã€‚"

#: Game.Levels.Implication.L07intro2
msgid "Start with `intro h` to assume the hypothesis."
msgstr "ç”¨ `intro h` å¼€å§‹è®¾å‡è®¾ã€‚"

#: Game.Levels.Implication.L07intro2
msgid ""
"Now `repeat rw [â† succ_eq_add_one] at h` is the quickest way to\n"
"change `succ x = succ y`."
msgstr "ç°åœ¨ `repeat rw [â† succ_eq_add_one] at h` æ˜¯æ”¹å†™ `succ x = succ y` çš„æœ€å¿«æ–¹æ³•ã€‚"

#: Game.Levels.Implication.L07intro2
msgid "Now `apply succ_inj at h` to cancel the `succ`s."
msgstr "ç°åœ¨ä½¿ç”¨ `apply succ_inj at h` æ¥æ¶ˆå» `succ`ã€‚"

#: Game.Levels.Implication.L07intro2
msgid "Now `rw [h]` then `rfl` works, but `exact h` is quicker."
msgstr "ç°åœ¨ `rw [h]` å’Œ `rfl` å¯ä»¥å®Œæˆè¯æ˜ï¼Œä½† `exact h` æ›´å¿«ã€‚"

#: Game.Levels.Implication.L07intro2
msgid ""
"Here's a completely backwards proof:\n"
"```\n"
"intro h\n"
"apply succ_inj\n"
"repeat rw [succ_eq_add_one]\n"
"exact h\n"
"```"
msgstr ""
"è¿™æ˜¯ä¸€ä¸ªå®Œå…¨é€†å‘çš„è¯æ˜è¿‡ç¨‹ï¼š\n"
"```\n"
"intro h\n"
"apply succ_inj\n"
"repeat rw [succ_eq_add_one]\n"
"exact h\n"
"```"

#: Game.Levels.Implication.L08ne
msgid "â‰ "
msgstr "â‰ "

#: Game.Levels.Implication.L08ne
msgid ""
"We still can't prove `2 + 2 â‰  5` because we have not talked about the\n"
"definition of `â‰ `. In Lean, `a â‰  b` is *notation* for `a = b â†’ False`.\n"
"Here `False` is a generic false proposition, and `â†’` is Lean's notation\n"
"for \"implies\". In logic we learn\n"
"that `True â†’ False` is false, but `False â†’ False` is true. Hence\n"
"`X â†’ False` is the logical opposite of `X`.\n"
"\n"
"Even though `a â‰  b` does not look like an implication,\n"
"you should treat it as an implication. The next two levels will show you how.\n"
"\n"
"`False` is a goal which you cannot deduce from a consistent set of assumptions!\n"
"So if your goal is `False` then you had better hope that your hypotheses\n"
"are contradictory, which they are in this level."
msgstr ""
"æˆ‘ä»¬ä»ç„¶ä¸èƒ½è¯æ˜ `2 + 2 â‰  5`ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®º `â‰ ` çš„å®šä¹‰ã€‚åœ¨ Lean ä¸­ï¼Œ`a â‰  b` æ˜¯ `a = b â†’ False` "
"çš„*ç¬¦å·è¡¨ç¤º*ã€‚è¿™é‡Œçš„ `False` æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡å‘½é¢˜ï¼Œ`â†’` æ˜¯ Lean ä¸­è¡¨ç¤ºâ€œè•´å«â€çš„ç¬¦å·\n"
"ã€‚\n"
"åœ¨é€»è¾‘å­¦ä¸­æˆ‘ä»¬å­¦åˆ°ï¼Œ`True â†’ False` æ˜¯å‡çš„ï¼Œä½† `False â†’ False` æ˜¯çœŸçš„ã€‚å› æ­¤ï¼Œ`X â†’ false` æ˜¯ `X` çš„é€»è¾‘"
"å–åã€‚\n"
"\n"
"å°½ç®¡ `a â‰  b` çœ‹èµ·æ¥ä¸åƒè•´å«ï¼Œä½ åº”è¯¥å°†å…¶è§†ä¸ºè•´å«ã€‚æ¥ä¸‹æ¥çš„ä¸¤å…³å°†å‘ä½ å±•ç¤ºæ€æ ·ä½¿ç”¨å®ƒã€‚\n"
"\n"
"`False` æ˜¯ä¸€ä¸ªæ— æ³•ä»ä¸€è‡´çš„å‡è®¾é›†ä¸­æ¨å¯¼å‡ºçš„ç›®æ ‡ï¼æ‰€ä»¥å¦‚æœä½ çš„ç›®æ ‡æ˜¯ `False`ï¼Œé‚£ä¹ˆä½ æœ€å¥½å¸Œæœ›ä½ çš„å‡è®¾æ˜¯"
"çŸ›ç›¾çš„ï¼Œå°±åƒåœ¨æœ¬å…³ä¸­ä¸€æ ·ã€‚"

#: Game.Levels.Implication.L08ne
msgid "If $x=y$ and $x \\neq y$ then we can deduce a contradiction."
msgstr "å¦‚æœ $x=y$ ä¸” $x \\neq y$ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨å‡ºçŸ›ç›¾ã€‚"

#: Game.Levels.Implication.L08ne
msgid ""
"Remember that `h2` is a proof of `x = y â†’ False`. Try\n"
"`apply`ing `h2` either `at h1` or directly to the goal."
msgstr "è®°ä½ï¼Œ`h2` æ˜¯ `x = y â†’ False` çš„è¯æ˜ã€‚å°è¯•å°† `h2` åº”ç”¨ï¼ˆ`apply`ï¼‰äº `h1` æˆ–ç›´æ¥åº”ç”¨äºç›®æ ‡ã€‚"

#: Game.Levels.Implication.L08ne
msgid ""
"`a â‰  b` is *notation* for `(a = b) â†’ False`.\n"
"\n"
"The reason this is mathematically\n"
"valid is that if `P` is a true-false statement then `P â†’ False`\n"
"is the logical opposite of `P`. Indeed `True â†’ False` is false,\n"
"and `False â†’ False` is true!\n"
"\n"
"The upshot of this is that use can treat `a â‰  b` in exactly\n"
"the same way as you treat any implication `P â†’ Q`. For example,\n"
"if your *goal* is of the form `a â‰  b` then you can make progress\n"
"with `intro h`, and if you have a hypothesis `h` of the\n"
"form `a â‰  b` then you can `apply h at h1` if `h1` is a proof\n"
"of `a = b`."
msgstr ""
"`a â‰  b` æ˜¯ç”± `(a = b) â†’ False` å®šä¹‰çš„ ã€‚\n"
"\n"
"  è¿™åœ¨æ•°å­¦ä¸Šåˆæ³•çš„åŸå› æ˜¯ï¼Œå¦‚æœ `P` æ˜¯ä¸€ä¸ªçœŸå‡å‘½é¢˜ï¼Œé‚£ä¹ˆ `P â†’ False`\n"
"  ä¸ `P` çš„é€»è¾‘ç›¸åã€‚ç¡®å® `True â†’ False` æ˜¯å‡çš„ï¼Œ\n"
"  `False â†’ False` æ˜¯çœŸçš„ï¼\n"
"\n"
"  è¿™æ ·åšçš„ç»“æœæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨å¤„ç†ä»»ä½• `P â†’ Q` çš„æ–¹å¼å¤„ç† `a â‰  b`ã€‚ä¾‹å¦‚ï¼Œ\n"
"  å¦‚æœ *ç›®æ ‡* çš„å½¢å¼ä¸º `a â‰  b` é‚£ä¹ˆæ‚¨å¯ä»¥ç”¨ `intro h`å–å¾—è¿›å±•ï¼›\n"
"  å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  b` é‚£ä¹ˆä½ å¯ä»¥ `apply h at h1` å¦‚æœ `h1` æ˜¯\n"
"  `a = b`çš„å‡è®¾ã€‚"

#: Game.Levels.Implication.L08ne
msgid "Remember, `x â‰  y` is *notation* for `x = y â†’ False`."
msgstr "è®°ä½ï¼Œ`x â‰  y` æ˜¯ `x = y â†’ False` çš„ *ç¬¦å·è¡¨ç¤º* ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "zero_ne_succ"
msgstr "zero_ne_succ"

#: Game.Levels.Implication.L09zero_ne_succ
msgid ""
"`zero_ne_succ n` is the proof that `0 â‰  succ n`.\n"
"\n"
"In Lean, `a â‰  b` is *defined to mean* `a = b â†’ False`. Hence\n"
"`zero_ne_succ n` is really a proof of `0 = succ n â†’ False`.\n"
"Here `False` is a generic false statement. This means that\n"
"you can `apply zero_ne_succ at h` if `h` is a proof of `0 = succ n`."
msgstr ""
"`zero_ne_succ n` æ˜¯ `0 â‰  succ n` çš„è¯æ˜ã€‚\n"
"\n"
"åœ¨ Lean ä¸­ï¼Œ`a â‰  b` *è¢«å®šä¹‰ä¸º* `a = b â†’ False`ã€‚\n"
"å› æ­¤ï¼Œ`zero_ne_succ n` å®é™…ä¸Šæ˜¯ `0 = succ n â†’ False` çš„è¯æ˜ã€‚\n"
"è¿™é‡Œçš„ `False` æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡å‘½é¢˜ã€‚è¿™æ„å‘³ç€å¦‚æœ `h` æ˜¯ `0 = succ n` çš„è¯æ˜ï¼Œä½ å¯ä»¥ `apply "
"zero_ne_succ at h`ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid ""
"As warm-up for `2 + 2 â‰  5` let's prove `0 â‰  1`. To do this we need to\n"
"introduce Peano's last axiom `zero_ne_succ n`, a proof that `0 â‰  succ n`.\n"
"To learn about this result, click on it in the list of lemmas on the right."
msgstr ""
"ä½œä¸º `2 + 2 â‰  5` çš„çƒ­èº«ï¼Œæˆ‘ä»¬æ¥è¯æ˜ `0 â‰  1`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦\n"
"ä»‹ç»ä¸€ä¸‹Peanoçš„æœ€åä¸€ä¸ªå…¬ç†`zero_ne_succ n`ï¼Œè¯æ˜`0 â‰  succ n`ã€‚\n"
"è¦äº†è§£æ­¤ç»“è®ºï¼Œè¯·åœ¨å³ä¾§çš„å¼•ç†åˆ—è¡¨ä¸­å•å‡»å®ƒã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "`zero_ne_one` is a proof of `0 â‰  1`."
msgstr "`zero_ne_one` æ˜¯ `0 â‰  1` çš„è¯æ˜ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "$0\\neq1$."
msgstr "$0\\neq1$ ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Start with `intro h`."
msgstr "ä» `intro h` å¼€å§‹ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Now change `1` to `succ 0` in `h`."
msgstr "ç°åœ¨å°† `h` ä¸­çš„ `1` æ”¹å†™ä¸º `succ 0`ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ
msgid "Now you can `apply zero_ne_succ at h`."
msgstr "ç°åœ¨å¯ä»¥ä½¿ç”¨ `apply zero_ne_succ at h`ã€‚"

#: Game.Levels.Implication.L09zero_ne_succ Game.Levels.AdvAddition.L01add_right_cancel
msgid "Nice!"
msgstr "å¥½çš„ï¼"

#: Game.Levels.Implication.L10one_ne_zero
msgid "1 â‰  0"
msgstr "1 â‰  0"

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"We know `zero_ne_succ n` is a proof of `0 = succ n â†’ False` -- but what\n"
"if we have a hypothesis `succ n = 0`? It's the wrong way around!\n"
"\n"
"The `symm` tactic changes a goal `x = y` to `y = x`, and a goal `x â‰  y`\n"
"to `y â‰  x`. And `symm at h`\n"
"does the same for a hypothesis `h`. We've proved $0 \\neq 1$ and called\n"
"the proof `zero_ne_one`; now try proving $1 \\neq 0$."
msgstr ""
"æˆ‘ä»¬çŸ¥é“ `zero_ne_succ n` æ˜¯è¯æ˜ `0 = succ n â†’ False` çš„è¯æ˜ã€‚ä½†æ˜¯å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå‡è®¾ `succ n = 0` "
"å‘¢ï¼Ÿè¿™æ°å¥½æ˜¯åè¿‡æ¥çš„ï¼\n"
"\n"
"`symm` ç­–ç•¥å¯ä»¥å°†ç›®æ ‡ `x = y` æ”¹ä¸º `y = x`ï¼Œå¹¶å°†ç›®æ ‡ `x â‰  y` æ”¹ä¸º `y â‰  x`ã€‚è€Œ `symm at h` å¯¹å‡è®¾ `h` "
"ä¹ŸåšåŒæ ·çš„æ“ä½œã€‚\n"
"æˆ‘ä»¬å·²ç»è¯æ˜äº† $0 \\neq 1$ï¼Œå¹¶å°†è¯æ˜å‘½åä¸º `zero_ne_one`ï¼›ç°åœ¨è¯·å°è¯•è¯æ˜ $1 \\neq 0$ã€‚"

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"## Summary\n"
"\n"
"The `symm` tactic will change a goal or hypothesis of\n"
"the form `X = Y` to `Y = X`. It will also work on `X â‰  Y`\n"
"and on `X â†” Y`.\n"
"\n"
"### Example\n"
"\n"
"If the goal is `2 + 2 = 4` then `symm` will change it to `4 = 2 + 2`.\n"
"\n"
"### Example\n"
"\n"
"If `h : 2 + 2 â‰  5` then `symm at h` will change `h` to `5 â‰  2 + 2`."
msgstr ""
"## å°ç»“\n"
"\n"
"`symm` ç­–ç•¥ä¼šå°†å½¢å¦‚ `X = Y` çš„ç›®æ ‡æˆ–å‡è®¾è½¬æ¢ä¸º `Y = X`ã€‚å®ƒä¹Ÿé€‚ç”¨äº `X â‰  Y` å’Œ `X â†” Y`ã€‚\n"
"\n"
"### ä¾‹å­\n"
"\n"
"å¦‚æœç›®æ ‡æ˜¯ `2 + 2 = 4`ï¼Œé‚£ä¹ˆ `symm` ä¼šå°†å…¶è½¬æ¢ä¸º `4 = 2 + 2`ã€‚\n"
"\n"
"### ä¾‹å­\n"
"\n"
"å¦‚æœ `h : 2 + 2 â‰  5`ï¼Œé‚£ä¹ˆ `symm at h` ä¼šå°† `h` è½¬æ¢ä¸º `5 â‰  2 + 2`ã€‚"

#: Game.Levels.Implication.L10one_ne_zero
msgid "`one_ne_zero` is a proof that `1 â‰  0`."
msgstr "`one_ne_zero` æ˜¯ `1 â‰  0` çš„è¯æ˜ã€‚"

#: Game.Levels.Implication.L10one_ne_zero
msgid "$1\\neq0$."
msgstr "$1\\neq0$ ã€‚"

#: Game.Levels.Implication.L10one_ne_zero
msgid ""
"What do you think of this two-liner:\n"
"```\n"
"symm\n"
"exact zero_ne_one\n"
"```\n"
"\n"
"`exact` doesn't just take hypotheses, it will eat any proof which exists\n"
"in the system."
msgstr ""
"ä½ å¯¹è¿™ä¸¤è¡Œä»£ç æœ‰ä»€ä¹ˆçœ‹æ³•ï¼Ÿ\n"
"\n"
"```\n"
"symm\n"
"exact zero_ne_one\n"
"```\n"
"\n"
"è¯·æ³¨æ„ï¼Œ`exact` ä¸ä»…é™äºä½¿ç”¨å‡è®¾ï¼Œå®ƒå¯ä»¥æ¥å—ç³»ç»Ÿä¸­å­˜åœ¨çš„ä»»ä½•è¯æ˜ã€‚"

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "2 + 2 â‰  5"
msgstr "2 + 2 â‰  5"

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid ""
"2 + 2 â‰  5 is boring to prove in full, given only the tools we have currently.\n"
"To make it a bit less painful, I have unfolded all of the numerals for you.\n"
"See if you can use `zero_ne_succ` and `succ_inj` to prove this."
msgstr ""
"ä»…å‡­æˆ‘ä»¬ç›®å‰æ‹¥æœ‰çš„å·¥å…·ï¼Œå®Œæ•´è¯æ˜ 2 + 2 â‰  5 æ˜¯å¾ˆæ— èŠçš„ã€‚\n"
"ä¸ºäº†å‡è½»æ‚¨çš„ç—›è‹¦ï¼Œæˆ‘ä¸ºæ‚¨å±•å¼€äº†æ‰€æœ‰æ•°å­—ã€‚\n"
"çœ‹çœ‹æ˜¯å¦å¯ä»¥ä½¿ç”¨ `zero_ne_succ` å’Œ `succ_inj` æ¥è¯æ˜å®ƒã€‚"

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid "$2+2â‰ 5$."
msgstr "$2+2â‰ 5$."

#: Game.Levels.Implication.L11two_add_two_ne_five
msgid ""
"Here's my proof:\n"
"```\n"
"intro h\n"
"rw [add_succ, add_succ, add_zero] at h\n"
"repeat apply succ_inj at h\n"
"apply zero_ne_succ at h\n"
"exact h\n"
"```\n"
"\n"
"Even though Lean is a theorem prover, right now it's pretty clear that we have not\n"
"developed enough material to make it an adequate calculator. In Algorithm\n"
"World, a more computer-sciency world, we will develop machinery which makes\n"
"questions like this much easier, and goals like $20 + 20 â‰  41$ feasible.\n"
"Alternatively you can do more mathematics in Advanced Addition World, where we prove\n"
"the lemmas needed to get a working theory of inequalities. Click \"Leave World\" and\n"
"decide your route."
msgstr ""
"è¿™æ˜¯ä¸€ä¸ªè¯æ˜ï¼š\n"
"```\n"
"intro h\n"
"rw [add_succ, add_succ, add_zero] at h\n"
"repeat apply succ_inj at h\n"
"apply zero_ne_succ at h\n"
"exact h\n"
"```\n"
"\n"
"\n"
"å°½ç®¡ Lean æ˜¯ä¸€ä¸ªå®šç†è¯æ˜å™¨ï¼Œä½†å¾ˆæ˜æ˜¾æˆ‘ä»¬è¿˜æ²¡æœ‰å¼€å‘è¶³å¤Ÿçš„ææ–™ä½¿å…¶æˆä¸ºä¸€ä¸ªåˆé€‚çš„è®¡ç®—å™¨ã€‚åœ¨ç®—æ³•ä¸–ç•Œï¼Œä¸€"
"ä¸ªæ›´å…·è®¡ç®—æœºç§‘å­¦è‰²å½©çš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å¼€å‘ä½¿è¿™ç±»é—®é¢˜å˜å¾—æ›´å®¹æ˜“çš„æœºåˆ¶ï¼ˆæ¯”å¦‚å¿«é€Ÿè¯æ˜ $20 + 20 \\neq "
"41$ ï¼‰ã€‚æˆ–è€…ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œä¸­è¿›è¡Œæ›´å¤šæ•°å­¦å­¦ä¹ ï¼Œæˆ‘ä»¬åœ¨é‚£é‡Œè¯æ˜äº†å»ºç«‹ä¸ç­‰å¼ç†è®ºæ‰€éœ€çš„å¼•ç†ã€‚ç‚¹"
"å‡»â€œç¦»å¼€ä¸–ç•Œâ€å¹¶å†³å®šä½ çš„è·¯çº¿ã€‚"

#: Game.Levels.Implication
msgid "Implication World"
msgstr "è•´å«ä¸–ç•Œ"

#: Game.Levels.Implication
msgid ""
"We've proved that $2+2=4$; in Implication World we'll learn\n"
"how to prove $2+2\\neq 5$.\n"
"\n"
"In Addition World we proved *equalities* like $x + y = y + x$.\n"
"In this second tutorial world we'll learn some new tactics,\n"
"enabling us to prove *implications*\n"
"like $x+1=4 \\implies x=3.$\n"
"\n"
"We'll also learn two new fundamental facts about\n"
"natural numbers, which Peano introduced as axioms.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"æˆ‘ä»¬å·²ç»è¯æ˜äº† $2+2=4$ï¼›åœ¨â€œè•´å«ä¸–ç•Œâ€ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è¯æ˜ $2+2\\neq 5$ã€‚\n"
"\n"
"åœ¨åŠ æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†åƒ $x + y = y + x$ è¿™æ ·çš„*ç­‰å¼*ã€‚åœ¨è¿™ç¬¬äºŒä¸ªæ•™ç¨‹ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ ä¸€äº›æ–°çš„ç­–"
"ç•¥ï¼Œä½¿æˆ‘ä»¬èƒ½å¤Ÿè¯æ˜åƒ $x+1=4 \\implies x=3$ è¿™æ ·çš„*è•´å«*ã€‚\n"
"\n"
"æˆ‘ä»¬è¿˜å°†å­¦ä¹ å…³äºè‡ªç„¶æ•°çš„ä¸¤ä¸ªæ–°çš„åŸºæœ¬äº‹å®ï¼Œè¿™äº›æ˜¯çš®äºšè¯ºä½œä¸ºå…¬ç†å¼•å…¥çš„ã€‚\n"
"\n"
"ç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚"

#: Game.Levels.Algorithm.L01add_left_comm
msgid "add_left_comm"
msgstr "add_left_comm"

#: Game.Levels.Algorithm.L01add_left_comm
msgid "`add_left_comm a b c` is a proof that `a + (b + c) = b + (a + c)`."
msgstr "`add_left_comm a b c` æ˜¯ `a + (b + c) = b + (a + c)` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L01add_left_comm
msgid ""
"Having to rearrange variables manually using commutativity and\n"
"associativity is very tedious. We start by reminding you of this. `add_left_comm`\n"
"is a key component in the first algorithm which we'll explain, but we need\n"
"to prove it manually.\n"
"\n"
"Remember that you can do precision commutativity rewriting\n"
"with things like `rw [add_comm b c]`. And remember that\n"
"`a + b + c` means `(a + b) + c`."
msgstr ""
"æˆ‘ä»¬é¦–å…ˆæé†’æ‚¨ä¸€ç‚¹ï¼Œæ‰‹åŠ¨ä½¿ç”¨äº¤æ¢å¾‹å’Œç»“åˆå¾‹æ¥é‡æ–°æ’åˆ—å˜é‡æ˜¯éå¸¸ç¹ççš„ã€‚\n"
"`add_left_comm` æ˜¯æˆ‘ä»¬å°†è¦è§£é‡Šçš„ç¬¬ä¸€ä¸ªç®—æ³•ä¸­çš„å…³é”®ç»„ä»¶ï¼Œä½†æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è¯æ˜å®ƒã€‚\n"
"\n"
"è¯·è®°ä½ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `rw [add_comm b c]` ä¹‹ç±»çš„å‘½ä»¤è¿›è¡Œç²¾ç¡®çš„äº¤æ¢å¾‹é‡å†™ã€‚å¹¶è®°ä½ `a + b + c` è¡¨ç¤º `(a + "
"b) + c`ã€‚"

#: Game.Levels.Algorithm.L01add_left_comm
msgid "If $a, b, c$ are numbers, then $a+(b+c)=b+(a+c)$."
msgstr "å¦‚æœ $a, b, c$ æ˜¯è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ $a+(b+c)=b+(a+c)$ã€‚"

#: Game.Levels.Algorithm.L02add_algo1
msgid "making life easier"
msgstr "è®©ç”Ÿæ´»æ›´è½»æ¾"

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"In some later worlds, we're going to see some much nastier levels,\n"
"like `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`.\n"
"Brackets need to be moved around, and variables need to be swapped.\n"
"\n"
"In this level, `(a + b) + (c + d) = ((a + c) + d) + b`,\n"
"let's forget about the brackets and just think about\n"
"the variable order.\n"
"To turn `a+b+c+d` into `a+c+d+b` we need to swap `b` and `c`,\n"
"and then swap `b` and `d`. But this is easier than you\n"
"think with `add_left_comm`."
msgstr ""
"åœ¨ä¸€äº›åç»­çš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ä¸€äº›æ›´æ£˜æ‰‹çš„å…³å¡ï¼Œæ¯”å¦‚ `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + "
"b + 1)`ã€‚éœ€è¦ç§»åŠ¨æ‹¬å·ï¼Œè¿˜éœ€è¦äº¤æ¢å˜é‡ã€‚\n"
"\n"
"åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œ`(a + b) + (c + d) = ((a + c) + d) + b`ï¼Œè®©æˆ‘ä»¬å¿˜æ‰æ‹¬å·ï¼Œåªè€ƒè™‘å˜é‡çš„é¡ºåºã€‚\n"
"è¦å°† `a+b+c+d` è½¬æ¢æˆ `a+c+d+b`ï¼Œæˆ‘ä»¬éœ€è¦äº¤æ¢ `b` å’Œ `c`ï¼Œç„¶åäº¤æ¢ `b` å’Œ `d`ã€‚ä½†æ˜¯ä½¿ç”¨ "
"`add_left_comm` æ¯”ä½ æƒ³è±¡çš„è¦ç®€å•ã€‚"

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"If $a, b$, $c$ and $d$ are numbers, we have\n"
"$(a + b) + (c + d) = ((a + c) + d) + b.$"
msgstr ""
"å¦‚æœ $a, b$ã€$c$ å’Œ $d$ æ˜¯è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n"
"$(a + b) + (c + d) = ((a + c) + d) + b.$"

#: Game.Levels.Algorithm.L02add_algo1
msgid "Start with `repeat rw [add_assoc]` to push all the brackets to the right."
msgstr "ä» `repeat rw [add_assoc]` å¼€å§‹ï¼Œå°†æ‰€æœ‰çš„æ‹¬å·æ¨åˆ°å³è¾¹ã€‚"

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"Now use `rw [add_left_comm b c]` to switch `b` and `c` on the left\n"
"hand side."
msgstr "ç°åœ¨ä½¿ç”¨ `rw [add_left_comm b c]` å°†å·¦ä¾§çš„ `b` å’Œ `c` äº¤æ¢ã€‚"

#: Game.Levels.Algorithm.L02add_algo1
msgid "Finally use a targetted `add_comm` to switch `b` and `d`"
msgstr "æœ€åï¼Œä½¿ç”¨æœ‰é’ˆå¯¹æ€§çš„ `add_comm` æ¥äº¤æ¢ `b` å’Œ `d"

#: Game.Levels.Algorithm.L02add_algo1
msgid "`rw [add_comm b d]`."
msgstr "`rw [add_comm b d]`ã€‚"

#: Game.Levels.Algorithm.L02add_algo1
msgid ""
"So that's the algorithm: now let's use automation to perform it\n"
"automatically."
msgstr "æ‰€ä»¥è¿™å°±æ˜¯ç®—æ³•ï¼šç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨æœºå™¨æ¥è‡ªåŠ¨æ‰§è¡Œå®ƒã€‚"

#: Game.Levels.Algorithm.L03add_algo2
msgid "making life simple"
msgstr "è®©ç”Ÿæ´»å˜å¾—ç®€å•"

#: Game.Levels.Algorithm.L03add_algo2
msgid ""
"# Overview\n"
"\n"
"Lean's simplifier, `simp`, will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"Furthermore, it will attempt to order variables into an internal order if fed\n"
"lemmas such as `add_comm`, so that it does not go into an infinite loop."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"Lean çš„ç®€åŒ–å™¨ `simp` å°†å®ƒå°†ç”¨æ¯ä¸ªç”¨æˆ·æä¾›ç»™å®ƒçš„å¼•ç†\n"
"ä»¥åŠæ‰€æœ‰æ ‡è®°ä¸º `simp` çš„å¼•ç†é‡å†™ç›®æ ‡ã€‚\n"
"æ­¤å¤–ï¼Œå¦‚æœæä¾›äº†å¦‚`add_comm`è¿™æ ·çš„å¼•ç†ï¼Œå®ƒå°†å°è¯•å°†å¯¹å˜é‡æ’åºï¼Œä»¥é¿å…é™·å…¥æ— é™å¾ªç¯ã€‚"

#: Game.Levels.Algorithm.L03add_algo2
msgid ""
"Lean's simplifier, `simp`, is \"`rw` on steroids\". It will rewrite every lemma\n"
"tagged with `simp` and every lemma fed to it by the user, as much as it can.\n"
"\n"
"This level is not a level which you want to solve by hand.\n"
"Get the simplifier to solve it for you."
msgstr ""
"Lean çš„ç®€åŒ–å™¨ `simp` æ˜¯åŠ å¼ºç‰ˆçš„ `rw` ã€‚å®ƒå°†ç”¨æ¯ä¸ªç”¨æˆ·æä¾›ç»™å®ƒçš„å¼•ç†\n"
"ä»¥åŠæ‰€æœ‰æ ‡è®°ä¸º `simp` çš„å¼•ç†é‡å†™ç›®æ ‡ã€‚\n"
"\n"
"è¿™ä¸ªå…³å¡ä¸æ˜¯èƒ½è½»æ¾æ‰‹åŠ¨è§£å†³çš„å…³å¡ã€‚\n"
"ä½¿ç”¨ç®€åŒ–å™¨æ¥ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ã€‚"

#: Game.Levels.Algorithm.L03add_algo2 Game.Levels.Algorithm.L04add_algo3
msgid ""
"If $a, b,\\ldots h$ are arbitrary natural numbers, we have\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$."
msgstr ""
"å¦‚æœ $a, b,\\ldots h$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n"
"$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$ã€‚"

#: Game.Levels.Algorithm.L03add_algo2
msgid "Solve this level in one line with `simp only [add_assoc, add_left_comm, add_comm]`"
msgstr "ç”¨ `simp only [add_assoc, add_left_comm, add_comm]` åœ¨ä¸€è¡Œä¸­è¯æ˜è¿™ä¸€å…³"

#: Game.Levels.Algorithm.L03add_algo2
msgid "Let's now make our own tactic to do this."
msgstr "ç°åœ¨è®©æˆ‘ä»¬åˆ¶å®šè‡ªå·±çš„ç­–ç•¥æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚"

#: Game.Levels.Algorithm.L04add_algo3
msgid "the simplest approach"
msgstr "æœ€ç®€å•çš„æ–¹æ³•"

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"# Overview\n"
"\n"
"Our home-made tactic `simp_add` will solve arbitrary goals of\n"
"the form `a + (b + c) + (d + e) = e + (d + (c + b)) + a`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"æˆ‘ä»¬è‡ªåˆ¶çš„ç­–ç•¥ `simp_add` å°†è§£å†³ä»¥ä¸‹å½¢å¼çš„ä»»æ„ç›®æ ‡ï¼š\n"
" `a + (b + c) + (d + e) = e + (d + (c + b)) + a`ã€‚"

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"You can make your own tactics in Lean.\n"
"This code here\n"
"```\n"
"macro \"simp_add\" : tactic => `(tactic|(\n"
"  simp only [add_assoc, add_left_comm, add_comm]))\n"
"```\n"
"was used to create a new tactic `simp_add`, which runs\n"
"`simp only [add_assoc, add_left_comm, add_comm]`.\n"
"Try running `simp_add` to solve this level!"
msgstr ""
"ä½ å¯ä»¥åœ¨ Lean ä¸­åˆ›å»ºè‡ªå·±çš„ç­–ç•¥ã€‚\n"
"è¿™é‡Œçš„ä»£ç \n"
"```\n"
"macro \"simp_add\" : tactic => `(tactic|(\n"
"  simp only [add_assoc, add_left_comm, add_comm]))\n"
"```\n"
"è¢«ç”¨æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ç­–ç•¥ `simp_add`ï¼Œå®ƒä¼šæ‰§è¡Œ\n"
"`simp only [add_assoc, add_left_comm, add_comm]`ã€‚\n"
"å°è¯•è¿è¡Œ `simp_add` æ¥è§£å†³è¿™ä¸ªå…³å¡ï¼"

#: Game.Levels.Algorithm.L04add_algo3
msgid ""
"Let's now move on to a more efficient approach to questions\n"
"involving numerals, such as `20 + 20 = 40`."
msgstr ""
"ç°åœ¨è®©æˆ‘ä»¬è½¬å‘æ›´æœ‰æ•ˆçš„\n"
"æ¶‰åŠæ•°å­—é—®é¢˜çš„æ–¹æ³•ï¼Œä¾‹å¦‚è¯æ˜ `20 + 20 = 40`ã€‚"

#: Game.Levels.Algorithm.L05pred
msgid "pred"
msgstr "pred"

#: Game.Levels.Algorithm.L05pred
msgid ""
"We now start work on an algorithm to do addition more efficiently. Recall that\n"
"we defined addition by recursion, saying what it did on `0` and successors.\n"
"It is an axiom of Lean that recursion is a valid\n"
"way to define functions from types such as the naturals.\n"
"\n"
"Let's define a new function `pred` from the naturals to the naturals, which\n"
"attempts to subtract 1 from the input. The definition is this:\n"
"\n"
"```\n"
"pred 0 := 37\n"
"pred (succ n) := n\n"
"```\n"
"\n"
"We cannot subtract one from 0, so we just return a junk value. As well as this\n"
"definition, we also create a new lemma `pred_succ`, which says that `pred (succ n) = n`.\n"
"Let's use this lemma to prove `succ_inj`, the theorem which\n"
"Peano assumed as an axiom and which we have already used extensively without justification."
msgstr ""
"æˆ‘ä»¬ç°åœ¨å¼€å§‹ç ”ç©¶ä¸€ä¸ªæ›´é«˜æ•ˆè¿›è¡ŒåŠ æ³•è®¡ç®—çš„ç®—æ³•ã€‚å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬é€šè¿‡é€’å½’å®šä¹‰äº†åŠ æ³•ï¼Œè¯´æ˜äº†å®ƒå¯¹ `0` å’Œåç»§"
"è€…çš„ä½œç”¨ã€‚Lean çš„ä¸€ä¸ªå…¬ç†æ˜¯é€’å½’æ˜¯ä»åƒè‡ªç„¶æ•°è¿™æ ·çš„ç±»å‹å®šä¹‰å‡½æ•°çš„æœ‰æ•ˆæ–¹å¼ã€‚\n"
"\n"
"è®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªä»è‡ªç„¶æ•°åˆ°è‡ªç„¶æ•°çš„æ–°å‡½æ•° `pred`ï¼Œå®ƒè¯•å›¾ä»è¾“å…¥ä¸­å‡å» 1ã€‚å®šä¹‰å¦‚ä¸‹ï¼š\n"
"\n"
"```\n"
"pred 0 := 37\n"
"pred (succ n) := n\n"
"```\n"
"\n"
"æˆ‘ä»¬ä¸èƒ½ä» 0 ä¸­å‡å» 1ï¼Œæ‰€ä»¥æˆ‘ä»¬åªæ˜¯è¿”å›ä¸€ä¸ªæ— ç”¨çš„å€¼ã€‚é™¤äº†è¿™ä¸ªå®šä¹‰ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¼•ç† "
"`pred_succ`ï¼Œå®ƒè¯´ `pred (succ n) = n`ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå¼•ç†æ¥è¯æ˜ `succ_inj`ï¼Œè¿™æ˜¯çš®äºšè¯ºå‡è®¾ä¸ºå…¬ç†çš„å®š"
"ç†ï¼Œæˆ‘ä»¬åœ¨æ²¡æœ‰è¯æ˜å®ƒçš„æƒ…å†µä¸‹å·²ç»å¹¿æ³›ä½¿ç”¨äº†ã€‚"

#: Game.Levels.Algorithm.L05pred
msgid "`pred_succ n` is a proof of `pred (succ n) = n`."
msgstr "`pred_succ n` æ˜¯ `pred (succ n) = n` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L05pred
msgid "If $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ then $a=b$."
msgstr "å¦‚æœ $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ é‚£ä¹ˆ $a=b$ã€‚"

#: Game.Levels.Algorithm.L05pred
msgid "Start with `rw [â† pred_succ a]` and take it from there."
msgstr "ä» `rw [â† pred_succ a]` å¼€å§‹ï¼Œç„¶åå†ç»§ç»­ã€‚"

#: Game.Levels.Algorithm.L05pred
msgid ""
"Nice! You've proved `succ_inj`!\n"
"Let's now prove Peano's other axiom, that successors can't be $0$."
msgstr ""
"å¥½çš„ï¼æ‚¨å·²ç»è¯æ˜äº† `succ_inj`ï¼\n"
"ç°åœ¨è®©æˆ‘ä»¬è¯æ˜çš®äºšè¯ºçš„å¦ä¸€ä¸ªå…¬ç†ï¼Œåç»§æ•°ä¸å¯èƒ½æ˜¯ $0$ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid "is_zero"
msgstr "is_zero"

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"We define a function `is_zero` thus:\n"
"\n"
"```\n"
"is_zero 0 := True\n"
"is_zero (succ n) := False\n"
"```\n"
"\n"
"We also create two lemmas, `is_zero_zero` and `is_zero_succ n`, saying that `is_zero 0 = True`\n"
"and `is_zero (succ n) = False`. Let's use these lemmas to prove `succ_ne_zero`, Peano's\n"
"Last Axiom. Actually, we have been using `zero_ne_succ` before, but it's handy to have\n"
"this opposite version too, which can be proved in the same way. Note: you can\n"
"cheat here by using `zero_ne_succ` but the point of this world is to show\n"
"you how to *prove* results like that.\n"
"\n"
"If you can turn your goal into `True`, then the `trivial` tactic will solve it."
msgstr ""
"æˆ‘ä»¬è¿™æ ·å®šä¹‰ä¸€ä¸ªå‡½æ•° `is_zero` ï¼š\n"
"\n"
"```\n"
"is_zero 0 := True\n"
"is_zero (succ n) := False\n"
"```\n"
"\n"
"æˆ‘ä»¬è¿˜åˆ›å»ºä¸¤ä¸ªå¼•ç† `is_zero_zero` å’Œ `is_zero_succ n`ï¼Œè¡¨ç¤º `is_zero 0 = True`\n"
"å’Œ `is_zero (succ n) = False`ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¿™äº›å¼•ç†æ¥è¯æ˜ `succ_ne_zero`ï¼ŒPeano çš„\n"
"æœ€åçš„å…¬ç†ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬ä¹‹å‰ä¸€ç›´åœ¨ä½¿ç”¨ `zero_ne_succ`ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé€†å‘çš„ç‰ˆæœ¬ä¼šå¾ˆæ–¹ä¾¿ã€‚\n"
"å®ƒå¯ä»¥ç”¨åŒæ ·çš„æ–¹å¼è¯æ˜ã€‚æ³¨æ„ï¼šä½ å¯ä»¥\n"
"é€šè¿‡ä½¿ç”¨ `zero_ne_succ` åœ¨è¿™é‡Œä½œå¼Šï¼Œä½†è¿™ä¸ªä¸–ç•Œçš„é‡ç‚¹æ˜¯å±•ç¤º\n"
"ä½ å¦‚ä½• *è¯æ˜* è¿™æ ·çš„ç»“æœã€‚\n"
"\n"
"å¦‚æœä½ èƒ½æŠŠä½ çš„ç›®æ ‡å˜æˆ`True`ï¼Œé‚£ä¹ˆ`trivial` ç­–ç•¥ï¼ˆtacticï¼‰å°±èƒ½è§£å†³å®ƒã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid "`is_zero_zero` is a proof of `is_zero 0 = True`."
msgstr "`is_zero_zero` æ˜¯ `is_zero 0 = True` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid "`is_zero_succ a` is a proof of `is_zero (succ a) = False`."
msgstr "`is_zero_succ a` æ˜¯ `is_zero (succ a) = False` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid "`succ_ne_zero a` is a proof of `succ a â‰  0`."
msgstr "`succ_ne_zero a` æ˜¯ `succ a â‰  0` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"# Summary\n"
"\n"
"`trivial` will solve the goal `True`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"`trivial` å°†è§£å†³ç›®æ ‡ `True`ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid "$\\operatorname{succ}(a) \\neq 0$."
msgstr "$\\operatorname{succ}(a) \\neq 0$."

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"Start with `intro h` (remembering that `X â‰  Y` is just notation\n"
"for `X = Y â†’ False`)."
msgstr "ä» `intro h` å¼€å§‹ï¼ˆè®°ä½ `X â‰  Y` åªæ˜¯ `X = Y â†’ False` çš„ç¬¦å·è¡¨ç¤ºï¼‰ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"We're going to change that `False` into `True`. Start by changing it into\n"
"`is_zero (succ a)` by executing `rw [â† is_zero_succ a]`."
msgstr ""
"æˆ‘ä»¬å°†è¦æŠŠé‚£ä¸ª `False` å˜æˆ `True`ã€‚é¦–å…ˆé€šè¿‡æ‰§è¡Œ `rw [â† is_zero_succ a]` æŠŠå®ƒå˜æˆ `is_zero (succ "
"a)`ã€‚"

#: Game.Levels.Algorithm.L06is_zero
msgid ""
"See if you can take it from here. Look at the new lemmas and tactic\n"
"available on the right."
msgstr "çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä»è¿™é‡Œå¼€å§‹ã€‚æŸ¥çœ‹å³ä¾§å¯ç”¨çš„æ–°å¼•ç†å’Œç­–ç•¥ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "An algorithm for equality"
msgstr "ç”¨äºè¯æ˜ç­‰ä»·çš„ç®—æ³•"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Here we begin to\n"
"develop an algorithm which, given two naturals `a` and `b`, returns the answer\n"
"to \"does `a = b`?\"\n"
"\n"
"Here is the algorithm. First note that `a` and `b` are numbers, and hence\n"
"are either `0` or successors.\n"
"\n"
"*) If `a` and `b` are both `0`, return \"yes\".\n"
"\n"
"*) If one is `0` and the other is `succ n`, return \"no\".\n"
"\n"
"*) If `a = succ m` and `b = succ n`, then return the answer to \"does `m = n`?\"\n"
"\n"
"Our job now is to *prove* that this algorithm always gives the correct answer. The proof that\n"
"`0 = 0` is `rfl`. The proof that `0 â‰  succ n` is `zero_ne_succ n`, and the proof\n"
"that `succ m â‰  0` is `succ_ne_zero m`. The proof that if `h : m = n` then\n"
"`succ m = succ n` is `rw [h]` and then `rfl`. This level is a proof of the one\n"
"remaining job we have to do: if `a â‰  b` then `succ a â‰  succ b`."
msgstr ""
"æˆ‘ä»¬å¼€å§‹å¼€å‘ä¸€ä¸ªç®—æ³•ï¼Œç»™å®šä¸¤ä¸ªè‡ªç„¶æ•° `a` å’Œ `b`ï¼Œè¿”å›å¯¹â€œ`a = b`ï¼Ÿâ€çš„å›ç­”ã€‚\n"
"\n"
"è¿™æ˜¯ç®—æ³•ã€‚é¦–å…ˆæ³¨æ„åˆ° `a` å’Œ `b` æ˜¯æ•°å­—ï¼Œå› æ­¤è¦ä¹ˆæ˜¯ `0` è¦ä¹ˆæ˜¯åç»§è€…ã€‚\n"
"\n"
"* å¦‚æœ `a` å’Œ `b` éƒ½æ˜¯ `0`ï¼Œè¿”å›â€œæ˜¯â€ã€‚\n"
"* å¦‚æœä¸€ä¸ªæ˜¯ `0` è€Œå¦ä¸€ä¸ªæ˜¯ `succ n`ï¼Œè¿”å›â€œå¦â€ã€‚\n"
"* å¦‚æœ `a = succ m` ä¸” `b = succ n`ï¼Œé‚£ä¹ˆè¿”å›å¯¹â€œ`m = n`ï¼Ÿâ€çš„ç­”æ¡ˆã€‚\n"
"\n"
"ç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯*è¯æ˜*è¿™ä¸ªç®—æ³•æ€»èƒ½ç»™å‡ºæ­£ç¡®çš„ç­”æ¡ˆã€‚è¯æ˜ `0 = 0` æ˜¯ `rfl`ã€‚è¯æ˜ `0 â‰  succ n` çš„æ˜¯ "
"`zero_ne_succ n`ï¼Œè¯æ˜ `succ m â‰  0` çš„æ˜¯ `succ_ne_zero m`ã€‚å¦‚æœæœ‰å‡è®¾ `h : m = n`ï¼Œé‚£ä¹ˆè¯æ˜ `succ m "
"= succ n` å¯ä»¥ä½¿ç”¨ `rw [h]` ç„¶å `rfl`ã€‚è¿™ä¸€å…³æ˜¯è¯æ˜æˆ‘ä»¬è¦åšçš„å‰©ä½™å·¥ä½œä¹‹ä¸€ï¼šå¦‚æœ `a â‰  b`ï¼Œé‚£ä¹ˆ `succ "
"a â‰  succ b`ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"# Summary\n"
"\n"
"If you have a hypothesis\n"
"\n"
"`h : a â‰  b`\n"
"\n"
"and goal\n"
"\n"
"`c â‰  d`\n"
"\n"
"then `contrapose! h` replaces the set-up with its so-called \\\"contrapositive\\\":\n"
"a hypothesis\n"
"\n"
"`h : c = d`\n"
"\n"
"and goal\n"
"\n"
"`a = b`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾\n"
"\n"
"`h : a â‰  b`\n"
"\n"
"å’Œç›®æ ‡\n"
"\n"
"`c â‰  d`\n"
"\n"
"é‚£ä¹ˆ `contrapose! h` å°†è¿™ä¸ªå‘½é¢˜æ›¿æ¢ä¸ºæ‰€è°“çš„â€œé€†å¦å‘½é¢˜â€ï¼š\n"
"ä¸€ä¸ªå‡è®¾\n"
"\n"
"`h : c = d`\n"
"\n"
"å’Œç›®æ ‡\n"
"\n"
"`a = b`ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "`succ_ne_succ m n` is the proof that `m â‰  n â†’ succ m â‰  succ n`."
msgstr "`succ_ne_succ m n` æ˜¯ `m â‰  n â†’ succ m â‰  succ n` çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid "If $a \\neq b$ then $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$."
msgstr "å¦‚æœ $a \\neq b$ï¼Œé‚£ä¹ˆ $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Start with `contrapose! h`, to change the goal into its\n"
"contrapositive, namely a hypothesis of `succ m = succ m` and a goal of `m = n`."
msgstr "ä» `contrapose! h` å¼€å§‹ï¼Œå°†ç›®æ ‡è½¬å˜ä¸ºå…¶é€†å¦å‘½é¢˜ï¼Œå³å‡è®¾ä¸º `succ m = succ m`ï¼Œç›®æ ‡ä¸º `m = n`ã€‚"

#: Game.Levels.Algorithm.L07succ_ne_succ
msgid ""
"Can you take it from here? (note: if you try `contrapose! h` again, it will\n"
"take you back to where you started!)"
msgstr "ä½ èƒ½å¤„ç†æ¥ä¸‹æ¥çš„è¯æ˜å—ï¼Ÿï¼ˆæ³¨æ„ï¼šå¦‚æœä½ å†æ¬¡å°è¯• `contrapose! h`ï¼Œå®ƒä¼šæŠŠä½ å¸¦å›åˆ°å¼€å§‹çš„åœ°æ–¹ï¼ï¼‰"

#: Game.Levels.Algorithm.L08decide
msgid "decide"
msgstr "decide"

#: Game.Levels.Algorithm.L08decide
msgid ""
"# Summary\n"
"\n"
"`decide` will attempt to solve a goal if it can find an algorithm which it\n"
"can run to solve it.\n"
"\n"
"## Example\n"
"\n"
"A term of type `DecidableEq â„•` is an algorithm to decide whether two naturals\n"
"are equal or different. Hence, once this term is made and made into an `instance`,\n"
"the `decide` tactic can use it to solve goals of the form `a = b` or `a â‰  b`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœ `decide` å¯ä»¥æ‰¾åˆ°ä¸€ç§ç®—æ³•æ¥è§£å†³ç›®æ ‡ï¼Œå®ƒå°†å°è¯•è§£å†³è¯¥ç›®æ ‡ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"ç±»å‹ä¸º `DecidableEq â„•` çš„é¡¹æ˜¯ç”¨äºåˆ¤æ–­ä¸¤ä¸ªè‡ªç„¶æ•°æ˜¯å¦ç›¸ç­‰æˆ–ä¸åŒçš„ç®—æ³•ï¼ˆçš„å®ç°å‡½æ•°ï¼‰ã€‚\n"
"å› æ­¤ï¼Œä¸€æ—¦è¿™ä¸ªé¡¹è¢«åˆ›å»ºå¹¶æˆä¸ºä¸€ä¸ª `instance`ï¼Œ`decide` ç­–ç•¥å°±å¯ä»¥ä½¿ç”¨å®ƒæ¥è§£å†³å½¢å¼ä¸º `a = b` æˆ– `a â‰  "
"b` çš„ç›®æ ‡ã€‚"

#: Game.Levels.Algorithm.L08decide
msgid ""
"Implementing the algorithm for equality of naturals, and the proof that it is correct,\n"
"looks like this:\n"
"\n"
"```\n"
"instance instDecidableEq : DecidableEq â„•\n"
"| 0, 0 => isTrue <| by\n"
"  show 0 = 0\n"
"  rfl\n"
"| succ m, 0 => isFalse <| by\n"
"  show succ m â‰  0\n"
"  exact succ_ne_zero m\n"
"| 0, succ n => isFalse <| by\n"
"  show 0 â‰  succ n\n"
"  exact zero_ne_succ n\n"
"| succ m, succ n =>\n"
"  match instDecidableEq m n with\n"
"  | isTrue (h : m = n) => isTrue <| by\n"
"    show succ m = succ n\n"
"    rw [h]\n"
"    rfl\n"
"  | isFalse (h : m â‰  n) => isFalse <| by\n"
"    show succ m â‰  succ n\n"
"    exact succ_ne_succ m n h\n"
"```\n"
"\n"
"This Lean code is a formally verified algorithm for deciding equality\n"
"between two naturals. I've typed it in already, behind the scenes.\n"
"Because the algorithm is formally verified to be correct, we can\n"
"use it in Lean proofs. You can run the algorithm with the `decide` tactic."
msgstr ""
"å®ç°è‡ªç„¶æ•°ç­‰å¼çš„ç®—æ³•ï¼Œä»¥åŠè¯æ˜å®ƒæ˜¯æ­£ç¡®çš„ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š\n"
"\n"
"```\n"
"instance instDecidableEq : DecidableEq â„•\n"
"| 0, 0 => isTrue <| by\n"
"  show 0 = 0\n"
"  rfl\n"
"| succ m, 0 => isFalse <| by\n"
"  show succ m â‰  0\n"
"  exact succ_ne_zero m\n"
"| 0, succ n => isFalse <| by\n"
"  show 0 â‰  succ n\n"
"  exact zero_ne_succ n\n"
"| succ m, succ n =>\n"
"  match instDecidableEq m n with\n"
"  | isTrue (h : m = n) => isTrue <| by\n"
"    show succ m = succ n\n"
"    rw [h]\n"
"    rfl\n"
"  | isFalse (h : m â‰  n) => isFalse <| by\n"
"    show succ m â‰  succ n\n"
"    exact succ_ne_succ m n h\n"
"```\n"
"\n"
"è¿™æ®µ Lean ä»£ç æ˜¯ä¸€ä¸ªç”¨äºåˆ¤æ–­ä¸¤ä¸ªè‡ªç„¶æ•°ä¹‹é—´ç­‰å¼çš„æ­£å¼éªŒè¯ç®—æ³•ã€‚\n"
"æˆ‘å·²ç»åœ¨æ¸¸æˆå¹•åè¾“å…¥äº†å®ƒã€‚å› ä¸ºè¿™ä¸ªç®—æ³•å·²ç»æ­£å¼éªŒè¯ä¸ºæ­£ç¡®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ Lean è¯æ˜ä¸­ä½¿ç”¨å®ƒã€‚\n"
"ä½ å¯ä»¥ç”¨ `decide` ç­–ç•¥è¿è¡Œè¿™ä¸ªç®—æ³•ã€‚"

#: Game.Levels.Algorithm.L08decide
msgid "$20+20=40$."
msgstr "$20+20=40$."

#: Game.Levels.Algorithm.L08decide
msgid ""
"You can read more about the `decide` tactic by clicking\n"
"on it in the top right."
msgstr "ä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å³ä¸Šè§’çš„ `decide` æ¥äº†è§£æ›´å¤šå…³äº `decide` ç­–ç•¥çš„ä¿¡æ¯ã€‚"

#: Game.Levels.Algorithm.L09decide2
msgid "decide again"
msgstr "è¿˜æ˜¯`decide`"

#: Game.Levels.Algorithm.L09decide2
msgid "We gave a pretty unsatisfactory proof of `2 + 2 â‰  5` earlier on; now give a nicer one."
msgstr "æˆ‘ä»¬å‰é¢ç»™å‡ºçš„ `2 + 2 â‰  5` è¯æ˜å¹¶ä¸ä»¤äººæ»¡æ„ï¼Œç°åœ¨ç»™å‡ºä¸€ä¸ªæ›´å¥½çš„è¯æ˜ã€‚"

#: Game.Levels.Algorithm.L09decide2
msgid "$2+2 \\neq 5.$"
msgstr "$2+2 \\neq 5.$"

#: Game.Levels.Algorithm.L09decide2
msgid ""
"Congratulations! You've finished Algorithm World. These algorithms\n"
"will be helpful for you in Even-Odd World."
msgstr ""
"æ­å–œï¼æ‚¨å·²ç»å®Œæˆäº†ã€Šç®—æ³•ä¸–ç•Œã€‹ã€‚è¿™äº›ç®—æ³•\n"
"å°†å¯¹æ‚¨åœ¨å¥‡å¶ä¸–ç•Œä¸­æœ‰æ‰€å¸®åŠ©ã€‚"

#: Game.Levels.Algorithm
msgid "Algorithm World"
msgstr "ç®—æ³•ä¸–ç•Œ"

#: Game.Levels.Algorithm
msgid ""
"Proofs like $2+2=4$ and $a+b+c+d+e=e+d+c+b+a$ are very tedious to do by hand.\n"
"In Algorithm World we learn how to get the computer to do them for us.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"åƒ $2+2=4$ å’Œ $a+b+c+d+e=e+d+c+b+a$ è¿™æ ·çš„è¯æ˜å¦‚æœæ‰‹å·¥å®Œæˆä¼šéå¸¸ç¹çã€‚åœ¨ç®—æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è®©"
"è®¡ç®—æœºå¸®æˆ‘ä»¬å®Œæˆå®ƒä»¬ã€‚\n"
"\n"
"ç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "add_right_cancel"
msgstr "add_right_cancel"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "`add_right_cancel a b n` is the theorem that $a+n=b+n \\implies a=b.$"
msgstr "`add_right_cancel a b n` æ˜¯ $a+n=b+n \\implies a=b$ çš„å®šç†ã€‚"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid ""
"In this world I will mostly leave you on your own.\n"
"\n"
"`add_right_cancel a b n` is the theorem that $a+n=b+n\\implies a=b$."
msgstr ""
"åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæ¢é™©å°†ä¸»è¦ç”±æ‚¨ç‹¬è‡ªå®Œæˆã€‚\n"
"\n"
"`add_right_cancel a b n` æ˜¯å®šç† $a+n=b+n\\implies a=b$ã€‚"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "$a+n=b+n\\implies a=b$."
msgstr "$a+n=b+n\\implies a=b$ã€‚"

#: Game.Levels.AdvAddition.L01add_right_cancel
msgid "Start with induction on `n`."
msgstr "ä»å¯¹ `n` çš„å½’çº³å¼€å§‹ã€‚"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "add_left_cancel"
msgstr "add_left_cancel"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "`add_left_cancel a b n` is the theorem that $n+a=n+b \\implies a=b.$"
msgstr "`add_left_cancel a b n` æ˜¯ $n+a=n+b \\implies a=b$ çš„å®šç†åå­—ã€‚"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid ""
"`add_left_cancel a b n` is the theorem that $n+a=n+b\\implies a=b$.\n"
"You can prove it by induction on `n` or you can deduce it from `add_right_cancel`."
msgstr ""
"`add_left_cancel a b n` æ˜¯å®šç† $n+a=n+b\\implies a=b$ã€‚ä½ å¯ä»¥é€šè¿‡å¯¹ `n` è¿›è¡Œå½’çº³æ¥è¯æ˜å®ƒï¼Œæˆ–è€…ä½ å¯ä»¥"
"ä» `add_right_cancel` æ¨å¯¼å‡ºå®ƒã€‚"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid "$n+a=n+b\\implies a=b$."
msgstr "$n+a=n+b\\implies a=b$ ã€‚"

#: Game.Levels.AdvAddition.L02add_left_cancel
msgid ""
"How about this for a proof:\n"
"```\n"
"repeat rw [add_comm n]\n"
"exact add_right_cancel a b n\n"
"```"
msgstr ""
"ä¸‹é¢è¿™ä¸ªè¯æ˜æ€ä¹ˆæ ·ï¼š\n"
"```\n"
"repeat rw [add_comm n]\n"
"exact add_right_cancel a b n\n"
"```"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "add_left_eq_self"
msgstr "add_left_eq_self"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "`add_left_eq_self x y` is the theorem that $x + y = y \\implies x=0.$"
msgstr "`add_left_eq_self x y` æ˜¯ $x + y = y\\implies x=0$ çš„å®šç†åå­—ã€‚"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "`add_left_eq_self x y` is the theorem that $x + y = y\\implies x=0.$"
msgstr "`add_left_eq_self x y` æ˜¯ $x + y = y\\implies x=0$ çš„å®šç†åå­—ã€‚"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid "$x + y = y\\implies x=0.$"
msgstr "$x + y = y\\implies x=0$ ã€‚"

#: Game.Levels.AdvAddition.L03add_left_eq_self
msgid ""
"Did you use induction on `y`?\n"
"Here's a two-line proof of `add_left_eq_self` which uses `add_right_cancel`.\n"
"If you want to inspect it, you can go into editor mode by clicking `</>` in the top right\n"
"and then just cut and paste the proof and move your cursor around it\n"
"to see the hypotheses and goal at any given point\n"
"(although you'll lose your own proof this way). Click `>_` to get\n"
"back to command line mode.\n"
"```\n"
"nth_rewrite 2 [â† zero_add y]\n"
"exact add_right_cancel x 0 y\n"
"```"
msgstr ""
"ä½ æ˜¯å¦å¯¹ `y` ä½¿ç”¨äº†å½’çº³æ³•ï¼Ÿ\n"
"è¿™é‡Œæœ‰ä¸€ä¸ªä½¿ç”¨ `add_right_cancel` è¯æ˜ `add_left_eq_self`çš„ä¸¤è¡Œè¯æ˜ã€‚å¦‚æœä½ æƒ³æŸ¥çœ‹å®ƒï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å³"
"ä¸Šè§’çš„ `</>` è¿›å…¥ç¼–è¾‘å™¨æ¨¡å¼ï¼Œç„¶ååªéœ€å‰ªåˆ‡å’Œç²˜è´´è¯æ˜ï¼Œå¹¶åœ¨å…¶å‘¨å›´ç§»åŠ¨ä½ çš„å…‰æ ‡ï¼Œä»¥æŸ¥çœ‹åœ¨ä»»ä½•ç»™å®šç‚¹çš„å‡è®¾"
"å’Œç›®æ ‡ï¼ˆå°½ç®¡è¿™æ ·åšä½ ä¼šå¤±å»è‡ªå·±çš„è¯æ˜ï¼‰ã€‚ç‚¹å‡» `>_` è¿”å›å‘½ä»¤è¡Œæ¨¡å¼ã€‚\n"
"```\n"
"nth_rewrite 2 [â† zero_add y]\n"
"exact add_right_cancel x 0 y\n"
"```"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "add_right_eq_self"
msgstr "add_right_eq_self"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "`add_right_eq_self x y` is the theorem that $x + y = x \\implies y=0.$"
msgstr "`add_right_eq_self x y` æ˜¯è¡¨ç¤º $x + y = x\\implies y=0$ çš„å®šç†ã€‚"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid ""
"`add_right_eq_self x y` is the theorem that $x + y = x\\implies y=0.$\n"
"Two ways to do it spring to mind; I'll mention them when you've solved it."
msgstr ""
"`add_right_eq_self x y` æ˜¯ $x + y = x\\implies y=0$ çš„å®šç†ã€‚æˆ‘æƒ³åˆ°äº†ä¸¤ç§æ–¹æ³•ï¼Œç­‰ä½ è§£å‡ºæ¥äº†æˆ‘å†æã€‚"

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid "$x+y=x\\implies y=0$."
msgstr "$x+y=x\\implies y=0$."

#: Game.Levels.AdvAddition.L04add_right_eq_self
msgid ""
"Here's a proof using `add_left_eq_self`:\n"
"```\n"
"rw [add_comm]\n"
"intro h\n"
"apply add_left_eq_self at h\n"
"exact h\n"
"```\n"
"\n"
"and here's an even shorter one using the same idea:\n"
"```\n"
"rw [add_comm]\n"
"exact add_left_eq_self y x\n"
"```\n"
"\n"
"Alternatively you can just prove it by induction on `x`\n"
"(the dots in the proof just indicate the two goals and\n"
"can be omitted):\n"
"\n"
"```\n"
"  induction x with d hd\n"
"  Â· intro h\n"
"    rw [zero_add] at h\n"
"    assumption\n"
"  Â· intro h\n"
"    rw [succ_add] at h\n"
"    apply succ_inj at h\n"
"    apply hd at h\n"
"    assumption\n"
"```"
msgstr ""
"è¿™é‡Œæ˜¯ä½¿ç”¨ `add_left_eq_self` çš„ä¸€ä¸ªè¯æ˜ï¼š\n"
"```\n"
"rw [add_comm]\n"
"intro h\n"
"apply add_left_eq_self at h\n"
"exact h\n"
"```\n"
"\n"
"è¿™é‡Œæ˜¯ä¸€ä¸ªä½¿ç”¨ç›¸åŒæ€è·¯çš„æ›´çŸ­çš„è¯æ˜ï¼š\n"
"```\n"
"rw [add_comm]\n"
"exact add_left_eq_self y x\n"
"```\n"
"\n"
"æˆ–è€…ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡å¯¹ `x` è¿›è¡Œå½’çº³æ¥è¯æ˜å®ƒ\n"
"ï¼ˆè¯æ˜ä¸­çš„ `.` åªæ˜¯è¡¨ç¤ºä¸¤ä¸ªç›®æ ‡ï¼Œ\n"
"å¯ä»¥çœç•¥ï¼‰ï¼š\n"
"\n"
"```\n"
"  induction x with d hd\n"
"  Â· intro h\n"
"    rw [zero_add] at h\n"
"    assumption\n"
"  Â· intro h\n"
"    rw [succ_add] at h\n"
"    apply succ_inj at h\n"
"    apply hd at h\n"
"    assumption\n"
"```"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "add_right_eq_zero"
msgstr "add_right_eq_zero"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid ""
"The next result we'll need in `â‰¤` World is that if `a + b = 0` then `a = 0` and `b = 0`.\n"
"Let's prove one of these facts in this level, and the other in the next.\n"
"\n"
"## A new tactic: `cases`\n"
"\n"
"The `cases` tactic will split an object or hypothesis up into the possible ways\n"
"that it could have been created.\n"
"\n"
"For example, sometimes you want to deal with the two cases `b = 0` and `b = succ d` separately,\n"
"but don't need the inductive hypothesis `hd` that comes with `induction b with d hd`.\n"
"In this situation you can use `cases b with d` instead. There are two ways to make\n"
"a number: it's either zero or a successor. So you will end up with two goals, one\n"
"with `b = 0` and one with `b = succ d`.\n"
"\n"
"Another example: if you have a hypothesis `h : False` then you are done, because a false statement "
"implies\n"
"any statement. Here `cases h` will close the goal, because there are *no* ways to\n"
"make a proof of `False`! So you will end up with no goals, meaning you have proved everything."
msgstr ""
"åœ¨è¿™ä¸€å…³ä¸­ï¼Œè®©æˆ‘ä»¬è¯æ˜å…¶ä¸­ä¸€ä¸ªäº‹å®ï¼Œè€Œåœ¨ä¸‹ä¸€å…³è¯æ˜å¦ä¸€ä¸ªã€‚\n"
"\n"
"## ä¸€ç§æ–°çš„ç­–ç•¥ï¼š`cases`\n"
"\n"
"`cases` ç­–ç•¥ä¼šå°†ä¸€ä¸ªå¯¹è±¡æˆ–å‡è®¾åˆ†è§£ä¸ºå¯èƒ½çš„åˆ›å»ºæ–¹å¼ã€‚\n"
"\n"
"ä¾‹å¦‚ï¼Œæœ‰æ—¶ä½ æƒ³åˆ†åˆ«å¤„ç† `b = 0` å’Œ `b = succ d` è¿™ä¸¤ç§æƒ…å†µï¼Œä½†ä¸éœ€è¦ä¸ `induction b with d hd` ä¸€èµ·æ¥"
"çš„å½’çº³å‡è®¾ `hd`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ `cases b with d`ã€‚åˆ¶é€ ä¸€ä¸ªæ•°å­—æœ‰ä¸¤ç§æ–¹å¼ï¼šå®ƒè¦ä¹ˆæ˜¯é›¶ï¼Œè¦ä¹ˆ"
"æ˜¯åç»§è€…ã€‚æ‰€ä»¥ä½ æœ€ç»ˆä¼šå¾—åˆ°ä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `b = 0`ï¼Œå¦ä¸€ä¸ªæ˜¯ `b = succ d`ã€‚\n"
"\n"
"å¦ä¸€ä¸ªä¾‹å­ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : False`ï¼Œé‚£ä¹ˆä½ å°±å®Œæˆè¯æ˜äº†ï¼Œå› ä¸ºä» `False` å¯ä»¥æ¨å‡ºä»»ä½•è¯æ˜ã€‚è¿™é‡Œ "
"`cases h` å°†è¯æ˜ç›®æ ‡ï¼Œå› ä¸ºæ²¡æœ‰ *ä»»ä½•* æ–¹æ³•å¯ä»¥è¯æ˜ `False`ï¼æ‰€ä»¥ä½ æœ€ç»ˆä¼šæ²¡æœ‰ç›®æ ‡ï¼Œæ„å‘³ç€ä½ å·²ç»è¯æ˜äº†"
"ä¸€åˆ‡ã€‚"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid ""
"## Summary\n"
"\n"
"If `n` is a number, then `cases n with d` will break the goal into two goals,\n"
"one with `n = 0` and the other with `n = succ d`.\n"
"\n"
"If `h` is a proof (for example a hypothesis), then `cases h with...` will break the\n"
"proof up into the pieces used to prove it.\n"
"\n"
"## Example\n"
"\n"
"If `n : â„•` is a number, then `cases n with d` will break the goal into two goals,\n"
"one with `n` replaced by 0 and the other with `n` replaced by `succ d`. This\n"
"corresponds to the mathematical idea that every natural number is either `0`\n"
"or a successor.\n"
"\n"
"## Example\n"
"\n"
"If `h : P âˆ¨ Q` is a hypothesis, then `cases h with hp hq` will turn one goal\n"
"into two goals, one with a hypothesis `hp : P` and the other with a\n"
"hypothesis `hq : Q`.\n"
"\n"
"## Example\n"
"\n"
"If `h : False` is a hypothesis, then `cases h` will turn one goal into no goals,\n"
"because there are no ways to make a proof of `False`! And if you have no goals left,\n"
"you have finished the level.\n"
"\n"
"## Example\n"
"\n"
"If `h : a â‰¤ b` is a hypothesis, then `cases h with c hc` will create a new number `c`\n"
"and a proof `hc : b = a + c`. This is because the *definition* of `a â‰¤ b` is\n"
"`âˆƒ c, b = a + c`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"å¦‚æœ `n` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases n with d` ä¼šå°†ç›®æ ‡åˆ†è§£æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `n = 0`ï¼Œå¦ä¸€ä¸ªæ˜¯ `n = "
"succ d`ã€‚\n"
"\n"
"å¦‚æœ `h` æ˜¯ä¸€ä¸ªè¯æ˜ï¼ˆä¾‹å¦‚ä¸€ä¸ªå‡è®¾ï¼‰ï¼Œé‚£ä¹ˆ `cases h with...` ä¼šå°†è¯æ˜åˆ†è§£æˆç”¨æ¥è¯æ˜å®ƒçš„å„ä¸ªéƒ¨åˆ†ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœ `n : â„•` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases n with d` ä¼šå°†ç›®æ ‡åˆ†è§£æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `n` è¢«æ›¿æ¢ä¸º 0ï¼Œå¦ä¸€ä¸ª"
"æ˜¯ `n` è¢«æ›¿æ¢ä¸º `succ d`ã€‚è¿™å¯¹åº”äºæ•°å­¦ä¸Šçš„è§‚ç‚¹ï¼Œå³æ¯ä¸ªè‡ªç„¶æ•°è¦ä¹ˆæ˜¯ `0`ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªåç»§æ•°ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœ `h : P âˆ¨ Q` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h with hp hq` ä¼šå°†ä¸€ä¸ªç›®æ ‡å˜æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæœ‰å‡è®¾ `hp : "
"P`ï¼Œå¦ä¸€ä¸ªæœ‰å‡è®¾ `hq : Q`ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœ `h : False` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h` ä¼šå°†ä¸€ä¸ªç›®æ ‡å˜æˆæ²¡æœ‰ç›®æ ‡ï¼Œå› ä¸ºæ²¡æœ‰æ–¹æ³•å¯ä»¥è¯æ˜ `False`ï¼"
"å¦‚æœä½ æ²¡æœ‰å‰©ä½™çš„ç›®æ ‡ï¼Œä½ å°±å®Œæˆäº†è¿™ä¸ªå…³å¡ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœ `h : a â‰¤ b` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h with c hc` ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ•°å­— `c` å’Œä¸€ä¸ªè¯æ˜ `hc : b = a "
"+ c`ã€‚è¿™æ˜¯å› ä¸º `a â‰¤ b` çš„*å®šä¹‰*æ˜¯ `âˆƒ c, b = a + c`ã€‚"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "A proof that $a+b=0 \\implies a=0$."
msgstr "ä¸€ä¸ª $a+b=0 \\implies a=0$ çš„è¯æ˜ã€‚"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "If $a+b=0$ then $a=0$."
msgstr "å¦‚æœ $a+b=0$ é‚£ä¹ˆ $a=0$ã€‚"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid ""
"Here we want to deal with the cases `b = 0` and `b â‰  0` separately,\n"
"so start with `cases b with d`."
msgstr ""
"åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æƒ³è¦åˆ†åˆ«å¤„ç† `b = 0` å’Œ `b â‰  0` çš„æƒ…å†µï¼Œ\n"
"æ‰€ä»¥ä» `cases b with d` å¼€å§‹ã€‚"

#: Game.Levels.AdvAddition.L05add_right_eq_zero
msgid "Well done!"
msgstr "åšå¾—å¥½ï¼"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "add_left_eq_zero"
msgstr "add_left_eq_zero"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid ""
"You can just mimic the previous proof to do this one -- or you can figure out a way\n"
"of using it."
msgstr ""
"ä½ å¯ä»¥æ¨¡ä»¿ä¹‹å‰çš„è¯æ˜æ¥å®Œæˆè¿™ä¸ªâ€”â€”æˆ–è€…ä½ å¯ä»¥æƒ³å‡ºä¸€ç§æ–¹æ³•\n"
"ä½¿ç”¨ä¹‹å‰çš„è¯æ˜ã€‚"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "A proof that $a+b=0 \\implies b=0$."
msgstr "ä¸€ä¸ª$a+b=0 \\implies b=0$çš„è¯æ˜ã€‚"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid "If $a+b=0$ then $b=0$."
msgstr "å¦‚æœ $a+b=0$ é‚£ä¹ˆ $b=0$ã€‚"

#: Game.Levels.AdvAddition.L06add_left_eq_zero
msgid ""
"How about this for a proof:\n"
"\n"
"```\n"
"rw [add_comm]\n"
"exact add_right_eq_zero b a\n"
"```\n"
"\n"
"That's the end of Advanced Addition World! You'll need these theorems\n"
"for the next world, `â‰¤` World. Click on \"Leave World\" to access it."
msgstr ""
"è¿™ä¸ªè¯æ˜æ€ä¹ˆæ ·ï¼š\n"
"\n"
"```\n"
"rw [add_comm]\n"
"exact add_right_eq_zero b a\n"
"```\n"
"\n"
"è¿™é‡Œå°±æ˜¯é«˜çº§åŠ æ³•ä¸–ç•Œçš„ç»“å°¾äº†ï¼ä½ å°†å¸¦ç€è¿™äº›å®šç†\n"
"è¿›å…¥ä¸‹ä¸€ä¸ªä¸–ç•Œï¼Œ`â‰¤` ä¸–ç•Œã€‚ç‚¹å‡»â€œç¦»å¼€ä¸–ç•Œâ€æ¥è®¿é—®å®ƒã€‚"

#: Game.Levels.AdvAddition
msgid "Advanced Addition World"
msgstr "é«˜çº§åŠ æ³•ä¸–ç•Œ"

#: Game.Levels.AdvAddition
msgid ""
"In Advanced Addition World we will prove some basic\n"
"addition facts such as $x+y=x\\implies y=0$. The theorems\n"
"proved in this world will be used to build\n"
"a theory of inequalities in `â‰¤` World.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ä¸€äº›åŸºæœ¬çš„åŠ æ³•äº‹å®ï¼Œå¦‚ $x+y=x\\implies y=0$ã€‚åœ¨è¿™ä¸ªä¸–ç•Œä¸­è¯æ˜çš„å®šç†å°†è¢«ç”¨"
"æ¥åœ¨ `â‰¤` ä¸–ç•Œä¸­æ„å»ºä¸ç­‰å¼ç†è®ºã€‚\n"
"\n"
"ç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid "The `use` tactic"
msgstr "`use` ç­–ç•¥"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"## Summary\n"
"\n"
"The `use` tactic makes progress with goals which claim something *exists*.\n"
"If the goal claims that some `x` exists with some property, and you know\n"
"that `x = 37` will work, then `use 37` will make progress.\n"
"\n"
"Because `a â‰¤ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\n"
"you can make progress on goals of the form `a â‰¤ b` by `use`ing the\n"
"number which is morally `b - a`."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"`use` ç­–ç•¥èƒ½ç”¨åœ¨å£°ç§°æŸäº›ä¸œè¥¿ *å­˜åœ¨* çš„ç›®æ ‡ä¸Šã€‚\n"
"å¦‚æœç›®æ ‡å£°ç§°æŸäº› `x` å­˜åœ¨å¹¶å…·æœ‰æŸäº›å±æ€§ï¼Œå¹¶ä¸”æ‚¨çŸ¥é“\n"
"`x = 37` å°†èµ·ä½œç”¨ï¼Œé‚£ä¹ˆä½¿ç”¨ `use 37` æ¥æ”¹å†™ç›®æ ‡ã€‚\n"
"\n"
"å› ä¸º `a â‰¤ b` æ˜¯ç”¨ â€œå­˜åœ¨ `c` ä½¿å¾— `b = a + c`â€ å®šä¹‰çš„ï¼Œ\n"
"æ‰€ä»¥å¯ä»¥é€šè¿‡`use (b - a)` åœ¨ `a â‰¤ b` å½¢å¼çš„ç›®æ ‡ä¸Šå–å¾—è¿›å±•ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`a â‰¤ b` is *notation* for `âˆƒ c, b = a + c`.\n"
"\n"
"Because this game doesn't have negative numbers, this definition\n"
"is mathematically valid.\n"
"\n"
"This means that if you have a goal of the form `a â‰¤ b` you can\n"
"make progress with the `use` tactic, and if you have a hypothesis\n"
"`h : a â‰¤ b`, you can make progress with `cases h with c hc`."
msgstr ""
"`a â‰¤ b` æ˜¯ `âˆƒ c, b = a + c` çš„*ç¬¦å·è¡¨ç¤º*ã€‚\n"
"\n"
"å› ä¸ºè¿™ä¸ªæ¸¸æˆæ²¡æœ‰è´Ÿæ•°ï¼Œè¿™ä¸ªå®šä¹‰åœ¨æ•°å­¦ä¸Šæ˜¯æœ‰æ•ˆçš„ã€‚\n"
"\n"
"è¿™æ„å‘³ç€å¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a â‰¤ b` çš„ç›®æ ‡ï¼Œä½ å¯ä»¥ç”¨ `use` ç­–ç•¥æ¥å–å¾—è¿›å±•ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰¤ "
"b`ï¼Œä½ å¯ä»¥ç”¨ `cases h with c hc` æ¥å–å¾—è¿›å±•ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`a â‰¤ b` is *notation* for `âˆƒ c, b = a + c`. This \"backwards E\"\n"
"means \"there exists\". So `a â‰¤ b` means that there exists\n"
"a number `c` such that `b = a + c`. This definition works\n"
"because there are no negative numbers in this game.\n"
"\n"
"To *prove* an \"exists\" statement, use the `use` tactic.\n"
"Let's see an example."
msgstr ""
"`a â‰¤ b` æ˜¯ `âˆƒ c, b = a + c` çš„*ç¬¦å·è¡¨ç¤º*ã€‚è¿™ä¸ªâ€œå€’ Eâ€ä»£è¡¨â€œå­˜åœ¨â€ã€‚æ‰€ä»¥ `a â‰¤ b` æ„å‘³ç€å­˜åœ¨ä¸€ä¸ªæ•°å­— `c` "
"ä½¿å¾— `b = a + c`ã€‚è¿™ä¸ªå®šä¹‰æœ‰æ•ˆæ˜¯å› ä¸ºåœ¨è¿™ä¸ªæ¸¸æˆä¸­æ²¡æœ‰è´Ÿæ•°ã€‚\n"
"\n"
"è¦*è¯æ˜*ä¸€ä¸ªâ€œå­˜åœ¨æ€§â€å®šç†ï¼Œå¯ä»¥ä½¿ç”¨ `use` ç­–ç•¥ã€‚\n"
"è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"`le_refl x` is a proof of `x â‰¤ x`.\n"
"\n"
"The reason for the name is that this lemma is \"reflexivity of $\\le$\""
msgstr ""
"`le_refl x` æ˜¯ `x â‰¤ x` çš„è¯æ˜ã€‚\n"
"\n"
"è¿™ä¸ªå¼•ç†æ˜¯ â€œ$\\le$ çš„è‡ªåæ€§â€ å› æ­¤è¿™ä¹ˆå‘½å ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid "If $x$ is a number, then $x \\le x$."
msgstr "å¦‚æœ $x$ æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ $x \\le x$ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid ""
"The reason `Â«{x}Â» â‰¤ Â«{x}Â»` is because `Â«{x}Â» = Â«{x}Â» + 0`.\n"
"So you should start this proof with `use 0`."
msgstr ""
"å› ä¸º `Â«{x}Â» = Â«{x}Â» + 0`ï¼Œæ‰€ä»¥`Â«{x}Â» â‰¤ Â«{x}Â»` ã€‚\n"
"æ‰€ä»¥ä½ åº”è¯¥ç”¨ `use 0` å¼€å§‹è¿™ä¸ªè¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L01le_refl
msgid "You can probably take it from here."
msgstr "ä½ å¯ä»¥ä»è¿™é‡Œå¼€å§‹ã€‚"

#: Game.Levels.LessOrEqual.L02zero_le
msgid "0 â‰¤ x"
msgstr "0 â‰¤ x"

#: Game.Levels.LessOrEqual.L02zero_le
msgid "To solve this level, you need to `use` a number `c` such that `x = 0 + c`."
msgstr "è¦é€šè¿‡æœ¬å…³å¡ï¼Œæ‚¨éœ€è¦ `use` ä¸€ä¸ªæ•°å­— `c` ä½¿å¾— `x = 0 + c`ã€‚"

#: Game.Levels.LessOrEqual.L02zero_le
msgid "`zero_le x` is a proof that `0 â‰¤ x`."
msgstr "`zero_le x` æ˜¯ `0 â‰¤ x` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L02zero_le
msgid "If $x$ is a number, then $0 \\le x$."
msgstr "å¦‚æœ $x$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $0 \\le x$ã€‚"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "x â‰¤ succ x"
msgstr "x â‰¤ succ x"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "`le_succ_self x` is a proof that `x â‰¤ succ x`."
msgstr "`le_succ_self x` æ˜¯ `x â‰¤ succ x` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid ""
"If you `use` the wrong number, you get stuck with a goal you can't prove.\n"
"What number will you `use` here?"
msgstr ""
"å¦‚æœä½ ä½¿ç”¨é”™è¯¯çš„æ•°å­—ï¼Œä½ å°†å¡åœ¨ä¸€ä¸ªæ— æ³•è¯æ˜çš„ç›®æ ‡ä¸­ã€‚\n"
"ä½ å°†åœ¨è¿™é‡Œä½¿ç”¨å“ªä¸ªæ•°å­—ï¼Ÿ"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid "If $x$ is a number, then $x \\le \\operatorname{succ}(x)$."
msgstr "å¦‚æœ $x$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $x \\le \\operatorname{succ}(x)$ã€‚"

#: Game.Levels.LessOrEqual.L03le_succ_self
msgid ""
"Here's a two-liner:\n"
"```\n"
"use 1\n"
"exact succ_eq_add_one x\n"
"```\n"
"\n"
"This works because `succ_eq_add_one x` is a proof of `succ x = x + 1`."
msgstr ""
"è¿™æ˜¯ä¸¤è¡Œçš„è¯æ˜ï¼š\n"
"```\n"
"use 1\n"
"exact succ_eq_add_one x\n"
"```\n"
"\n"
"è¿™æ˜¯æœ‰æ•ˆçš„ï¼Œå› ä¸º `succ_eq_add_one x` æ˜¯ `succ x = x + 1` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid "x â‰¤ y and y â‰¤ z implies x â‰¤ z"
msgstr "x â‰¤ y ä¸” y â‰¤ z æ„å‘³ç€ x â‰¤ z"

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"`le_trans x y z` is a proof that if `x â‰¤ y` and `y â‰¤ z` then `x â‰¤ z`.\n"
"More precisely, it is a proof that `x â‰¤ y â†’ (y â‰¤ z â†’ x â‰¤ z)`. In words,\n"
"If $x \\le y$ then (pause) if $y \\le z$ then $x \\le z$.\n"
"\n"
"## A note on associativity\n"
"\n"
"In Lean, `a + b + c` means `(a + b) + c`, because `+` is left associative. However\n"
"`â†’` is right associative. This means that `x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z` in Lean means\n"
"exactly that `â‰¤` is transitive. This is different to how mathematicians use\n"
"$P \\implies Q \\implies R$; for them, this usually means that $P \\implies Q$\n"
"and $Q \\implies R$."
msgstr ""
"`le_trans x y z` è¯æ˜äº†å¦‚æœ `x â‰¤ y` å’Œ `y â‰¤ z` é‚£ä¹ˆ `x â‰¤ z`ã€‚\n"
"æ›´ç¡®åˆ‡åœ°è¯´ï¼Œå®ƒæ˜¯ `x â‰¤ y â†’ (y â‰¤ z â†’ x â‰¤ z)` çš„è¯æ˜ã€‚æ¢å¥è¯è¯´\n"
"If $x \\le y$ then (pause) if $y \\le z$ then $x \\le z$.\n"
"\n"
"## å…³äºå…³è”æ€§çš„è¯´æ˜\n"
"\n"
"åœ¨ Lean ä¸­ï¼Œ`a + b + c` è¡¨ç¤º `(a + b) + c`ï¼Œå› ä¸º `+` æ˜¯å·¦å…³è”ã€‚ä½†æ˜¯\n"
"`â†’` æ˜¯å³å…³è”å¼ã€‚è¿™æ„å‘³ç€Leanä¸­çš„ `x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z` è¡¨ç¤º\n"
"`â‰¤` æ˜¯ä¼ é€’å¼çš„ã€‚è¿™ä¸æ•°å­¦å®¶ä½¿ç”¨\n"
"$P\\implies Q\\implies R$ çš„ç”¨æ³•ä¸åŒï¼›å¯¹ä»–ä»¬æ¥è¯´ï¼Œè¿™é€šå¸¸æ„å‘³ç€ $P\\implies Q$\n"
"å’Œ $Q\\implies R$ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"In this level, we see inequalities as *hypotheses*. We have not seen this before.\n"
"The `cases` tactic can be used to take `hxy` apart."
msgstr ""
"åœ¨æœ¬å…³ï¼Œæˆ‘ä»¬å°†ä¸ç­‰è§†ä¸º *å‡è®¾* ã€‚æˆ‘ä»¬ä»¥å‰æ²¡æœ‰è§è¿‡è¿™ä¸ªã€‚\n"
"`cases` ç­–ç•¥å¯ç”¨äºæ‹†è§£ `hxy` å‡è®¾ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid "If $x \\leq y$ and $y \\leq z$, then $x \\leq z$."
msgstr "å¦‚æœ $x \\leq y$ ä¸” $y \\leq z$ï¼Œé‚£ä¹ˆ $x \\leq z$ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid "Start with `cases Â«{hxy}Â» with a ha`."
msgstr "ä» `cases Â«{hxy}Â» with a ha` å¼€å§‹ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"Now `Â«{ha}Â»` is a proof that `Â«{y}Â» = Â«{x}Â» + Â«{a}Â»`, and `hxy` has vanished. Similarly, you can "
"destruct\n"
"`Â«{hyz}Â»` into its parts with `cases Â«{hyz}Â» with b hb`."
msgstr ""
"ç°åœ¨ `Â«{ha}Â»` æ˜¯ `Â«{y}Â» = Â«{x}Â» + Â«{a}Â»`, çš„è¯æ˜ï¼Œè€Œ `hxy` å·²ç»æ¶ˆå¤±äº†ã€‚åŒæ ·ï¼Œä½ å¯ä»¥é€šè¿‡ `cases "
"Â«{hyz}Â» with b hb` å°† `Â«{hyz}Â»` åˆ†è§£ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid "Now you need to figure out which number to `use`. See if you can take it from here."
msgstr "ç°åœ¨ä½ éœ€è¦å¼„æ¸…æ¥šä½¿ç”¨ï¼ˆ `use` ï¼‰å“ªä¸ªæ•°å­—ã€‚çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä»è¿™é‡Œç»§ç»­ã€‚"

#: Game.Levels.LessOrEqual.L04le_trans
msgid ""
"A passing mathematician remarks that with reflexivity and transitivity out of the way,\n"
"you have proved that `â‰¤` is a *preorder* on `â„•`."
msgstr "ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶æŒ‡å‡ºï¼Œéšç€è‡ªåæ€§å’Œä¼ é€’æ€§çš„è§£å†³ï¼Œä½ å·²ç»è¯æ˜äº† `â‰¤` æ˜¯ `â„•` ä¸Šçš„ä¸€ä¸ª*é¢„åº*ã€‚"

#: Game.Levels.LessOrEqual.L05le_zero
msgid "x â‰¤ 0 â†’ x = 0"
msgstr "x â‰¤ 0 â†’ x = 0"

#: Game.Levels.LessOrEqual.L05le_zero
msgid "`le_zero x` is a proof of `x â‰¤ 0 â†’ x = 0`."
msgstr "`le_zero x` æ˜¯ `x â‰¤ 0 â†’ x = 0` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L05le_zero
msgid ""
"It's \"intuitively obvious\" that there are no numbers less than zero,\n"
"but to prove it you will need a result which you showed in advanced\n"
"addition world."
msgstr ""
"æ²¡æœ‰å°äºé›¶çš„æ•°ï¼Œè¿™æ˜¯ \"ç›´è§‰ä¸Šæ˜¾è€Œæ˜“è§çš„\"ã€\n"
"ä½†æ˜¯åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œè¦ä½ éœ€è¦è¯æ˜è¿™ä¸€ç‚¹ã€‚"

#: Game.Levels.LessOrEqual.L05le_zero
msgid "`le_zero x` is a proof of the implication `x â‰¤ 0 â†’ x = 0`."
msgstr "`le_zero x` æ˜¯ä¸€ä¸ªè•´å«å¼ `x â‰¤ 0 â†’ x = 0` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L05le_zero
msgid "If $x \\leq 0$, then $x=0$."
msgstr "å¦‚æœæ˜¯ $x \\leq 0$ï¼Œé‚£ä¹ˆ $x=0$ã€‚"

#: Game.Levels.LessOrEqual.L05le_zero
msgid ""
"You want to use `add_right_eq_zero`, which you already\n"
"proved, but you'll have to start with `symm at` your hypothesis."
msgstr "ä½ æƒ³ä½¿ç”¨ `add_right_eq_zero`ï¼Œè¿™æ˜¯ä½ å·²ç»è¯æ˜è¿‡çš„ï¼Œä½†ä½ éœ€è¦ä»å¯¹ä½ çš„å‡è®¾ä½¿ç”¨ `symm at` å¼€å§‹ã€‚"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "x â‰¤ y and y â‰¤ x implies x = y"
msgstr "x â‰¤ y ä¸” y â‰¤ x æ„å‘³ç€ x = y"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "`le_antisymm x y` is a proof that if `x â‰¤ y` and `y â‰¤ x` then `x = y`."
msgstr "`le_antisymm x y` æ˜¯å¦‚æœ `x â‰¤ y` å’Œ `y â‰¤ x` åˆ™ `x = y` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid ""
"This level asks you to prove *antisymmetry* of $\\leq$.\n"
"In other words, if $x \\leq y$ and $y \\leq x$ then $x = y$.\n"
"It's the trickiest one so far. Good luck!"
msgstr ""
"è¿™ä¸€å…³å¡è¦æ±‚ä½ è¯æ˜ $\\leq$ çš„ *åå¯¹ç§°æ€§* ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœ $x \\leq y$ ä¸” $y \\leq x$ï¼Œé‚£ä¹ˆ $x = y"
"$ã€‚\n"
"è¿™æ˜¯æœ¬æ¸¸æˆåˆ°ç›®å‰æœ€æ£˜æ‰‹çš„è¯æ˜ä¹‹ä¸€ã€‚ç¥ä½ å¥½è¿ï¼"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid "If $x \\leq y$ and $y \\leq x$, then $x = y$."
msgstr "å¦‚æœ $x \\leq y$ ä¸” $y \\leq x$ï¼Œåˆ™ $x = y$ã€‚"

#: Game.Levels.LessOrEqual.L06le_antisymm
msgid ""
"Here's my proof:\n"
"```\n"
"cases hxy with a ha\n"
"cases hyx with b hb\n"
"rw [ha]\n"
"rw [ha, add_assoc] at hb\n"
"symm at hb\n"
"apply add_right_eq_self at hb\n"
"apply add_right_eq_zero at hb\n"
"rw [hb, add_zero]\n"
"rfl\n"
"```\n"
"\n"
"A passing mathematician remarks that with antisymmetry as well,\n"
"you have proved that `â‰¤` is a *partial order* on `â„•`.\n"
"\n"
"The boss level of this world is to prove\n"
"that `â‰¤` is a total order. Let's learn two more easy tactics\n"
"first."
msgstr ""
"è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n"
"```\n"
"cases hxy with a ha\n"
"cases hyx with b hb\n"
"rw [ha]\n"
"rw [ha, add_assoc] at hb\n"
"symm at hb\n"
"apply add_right_eq_self at hb\n"
"apply add_right_eq_zero at hb\n"
"rw [hb, add_zero]\n"
"rfl\n"
"```\n"
"\n"
"\n"
"ä¸€ä½è·¯è¿‡çš„æ•°å­¦å®¶è¯„è®ºè¯´ï¼Œä½ å·²ç»è¿ç”¨â€œåå¯¹ç§°æ€§â€è¯æ˜äº† `â‰¤` åœ¨ `â„•` ä¸Šæ˜¯ä¸€ä¸ª*ååº*ã€‚\n"
"\n"
"è¿™ä¸ªä¸–ç•Œä¸­çš„ Boss å…³å¡æ˜¯è¯æ˜ `â‰¤` æ˜¯ä¸€ä¸ªå…¨åºã€‚æˆ‘ä»¬å…ˆå­¦ä¹ ä¸¤ä¸ªæ›´ç®€å•çš„ç­–ç•¥ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid "Dealing with `or`"
msgstr "å¤„ç† `or`"

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"# Summary\n"
"The `left` tactic changes a goal of `P âˆ¨ Q` into a goal of `P`.\n"
"Use it when your hypotheses guarantee that the reason that `P âˆ¨ Q`\n"
"is true is because in fact `P` is true.\n"
"\n"
"Internally this tactic is just `apply`ing a theorem\n"
"saying that $P \\implies P \\lor Q.$\n"
"\n"
"Note that this tactic can turn a solvable goal into an unsolvable\n"
"one."
msgstr ""
"## æ¦‚è¿°\n"
"`left` ç­–ç•¥å°†ç›®æ ‡ `P âˆ¨ Q` è½¬æ¢ä¸ºç›®æ ‡ `P`ã€‚å½“æ‚¨çš„å‡è®¾ä¿è¯ `P âˆ¨ Q` ä¸ºçœŸçš„åŸå› æ˜¯ç”±äº `P` ä¸ºçœŸæ—¶ï¼Œè¯·ä½¿ç”¨"
"å®ƒã€‚\n"
"\n"
"åœ¨å†…éƒ¨ï¼Œè¿™ä¸ªç­–ç•¥åªæ˜¯åº”ç”¨äº†ä¸€ä¸ªå®šç†ï¼Œè¯¥å®šç†æ˜¯ $P\\implies P\\lor Q$ ã€‚\n"
"\n"
"è¯·æ³¨æ„ï¼Œæ­¤ç­–ç•¥å¯èƒ½ä¼šå°†ä¸€ä¸ªå¯è§£å†³çš„ç›®æ ‡è½¬æ¢ä¸ºä¸å¯è§£å†³çš„ç›®æ ‡ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"# Summary\n"
"The `right` tactic changes a goal of `P âˆ¨ Q` into a goal of `Q`.\n"
"Use it when your hypotheses guarantee that the reason that `P âˆ¨ Q`\n"
"is true is because in fact `Q` is true.\n"
"\n"
"Internally this tactic is just `apply`ing a theorem\n"
"saying that $Q \\implies P \\lor Q.$\n"
"\n"
"Note that this tactic can turn a solvable goal into an unsolvable\n"
"one."
msgstr ""
"## æ¦‚è¿°\n"
"`right` ç­–ç•¥å°† `P âˆ¨ Q` çš„ç›®æ ‡æ›´æ”¹ä¸º `Q` çš„ç›®æ ‡ã€‚\n"
"å½“æ‚¨çš„å‡è®¾`Q` ä¸ºçœŸæ˜¯ `P âˆ¨ Q`ä¸ºçœŸçš„åŸå› æ—¶ä½¿ç”¨å®ƒã€‚\n"
"\n"
"åœ¨ç­–ç•¥å†…éƒ¨ï¼Œå®ƒåªæ˜¯ `apply` ï¼ˆåº”ç”¨ï¼‰ äº† $Q \\implies P \\lor Q$ è¿™ä¸ªå®šç†\n"
"\n"
"è¯·æ³¨æ„ï¼Œè¿™ç§ç­–ç•¥å¯ä»¥å°†å¯è§£å†³çš„ç›®æ ‡å˜æˆæ— æ³•è§£å†³çš„ç›®æ ‡ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"Totality of `â‰¤` is the boss level of this world, and it's coming up next. It says that\n"
"if `a` and `b` are naturals then either `a â‰¤ b` or `b â‰¤ a`.\n"
"But we haven't talked about `or` at all. Here's a run-through.\n"
"\n"
"1) The notation for \"or\" is `âˆ¨`. You won't need to type it, but you can\n"
"type it with `\\or`.\n"
"\n"
"2) If you have an \"or\" statement in the *goal*, then two tactics made\n"
"progress: `left` and `right`. But don't choose a direction unless your\n"
"hypotheses guarantee that it's the correct one.\n"
"\n"
"3) If you have an \"or\" statement as a *hypothesis* `h`, then\n"
"`cases h with h1 h2` will create two goals, one where you went left,\n"
"and the other where you went right."
msgstr ""
"`â‰¤`çš„å®Œå…¨æ€§æ˜¯è¿™ä¸ªä¸–ç•Œçš„Bosså…³å¡äº†ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å®ƒäº†ã€‚å®ƒè¡¨æ˜å¦‚æœ`a`å’Œ`b`æ˜¯è‡ªç„¶æ•°ï¼Œ\n"
"é‚£ä¹ˆ`a â‰¤ b`æˆ–`b â‰¤ a`ã€‚ä½†æˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰è®¨è®ºè¿‡â€œæˆ–â€ï¼ˆ`or`ï¼‰ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç®€è¦è¯´æ˜ã€‚\n"
"\n"
"1. â€œæˆ–â€çš„ç¬¦å·æ˜¯`âˆ¨`ï¼Œä½ å¯ä»¥ç”¨`\\or`æ¥è¾“å…¥å®ƒã€‚\n"
"2. å¦‚æœä½ çš„ *ç›®æ ‡* æ˜¯ä¸€ä¸ªâ€œæˆ–â€å‘½é¢˜ï¼Œé‚£ä¹ˆæœ‰ä¸¤ä¸ªç­–ç•¥å¯ä»¥å–å¾—è¿›å±•ï¼š`left`å’Œ`right`ã€‚\n"
"ä½†é™¤éä½ çš„çŸ¥é“å“ªè¾¹æ˜¯çœŸçš„ï¼Œå¦åˆ™ä¸è¦é€‰æ‹©ä¸€ä¸ªæ–¹å‘ã€‚\n"
"3. å¦‚æœä½ åœ¨ *å‡è®¾* ä¸­æœ‰ä¸€ä¸ªâ€œæˆ–â€å‘½é¢˜`h`ï¼Œé‚£ä¹ˆ`cases h with h1 h2`ä¼šåˆ›å»ºä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªå‡è®¾å·¦è¾¹æ˜¯çœŸçš„ï¼Œ"
"å¦ä¸€ä¸ªå‡è®¾å³è¾¹æ˜¯çœŸçš„ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid "If $x=37$ or $y=42$, then $y=42$ or $x=37$."
msgstr "å¦‚æœ $x=37$ æˆ– $y=42$ï¼Œé‚£ä¹ˆ $y=42$ æˆ– $x=37$ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid "We don't know whether to go left or right yet. So start with `cases Â«{h}Â» with hx hy`."
msgstr "æˆ‘ä»¬è¿˜ä¸ç¡®å®šæ˜¯å‘å·¦è¿˜æ˜¯å‘å³ã€‚æ‰€ä»¥ä» `cases Â«{h}Â» with hx hy` å¼€å§‹ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid ""
"Now we can prove the `or` statement by proving the statement on the right,\n"
"so use the `right` tactic."
msgstr ""
"ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡è¯æ˜å³è¾¹çš„å£°æ˜æ¥è¯æ˜ `or` å‘½é¢˜ï¼Œ\n"
"æ‰€ä»¥ä½¿ç”¨ `right` ç­–ç•¥ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid "This time, use the `left` tactic."
msgstr "è¿™ä¸€æ¬¡ï¼Œä½¿ç”¨ `left` ç­–ç•¥ã€‚"

#: Game.Levels.LessOrEqual.L07or_symm
msgid "Ready for the boss level of this world?"
msgstr "å‡†å¤‡å¥½è¿æ¥è¿™ä¸ªä¸–ç•Œçš„Bosså…³äº†å—ï¼Ÿ"

#: Game.Levels.LessOrEqual.L08le_total
msgid "x â‰¤ y or y â‰¤ x"
msgstr "x â‰¤ y æˆ– y â‰¤ x"

#: Game.Levels.LessOrEqual.L08le_total
msgid "`le_total x y` is a proof that `x â‰¤ y` or `y â‰¤ x`."
msgstr "`le_total x y` æ˜¯ `x â‰¤ y` æˆ– `y â‰¤ x` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid ""
"This is I think the toughest level yet. Tips: if `a` is a number\n"
"then `cases a with b` will split into cases `a = 0` and `a = succ b`.\n"
"And don't go left or right until your hypotheses guarantee that\n"
"you can prove the resulting goal!\n"
"\n"
"I've left hidden hints; if you need them, retry from the beginning\n"
"and click on \"Show more help!\""
msgstr ""
"æˆ‘è®¤ä¸ºè¿™æ˜¯è¿„ä»Šä¸ºæ­¢æœ€éš¾çš„å…³å¡ã€‚æç¤ºï¼šå¦‚æœ `a` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases a with b` ä¼šåˆ†è§£ä¸º `a = 0` å’Œ "
"`a = succ b` ä¸¤ç§æƒ…å†µã€‚ä¸è¦åœ¨ä½ çš„å‡è®¾ä¸èƒ½ä¿è¯ä½ èƒ½è¯æ˜æœ€ç»ˆç›®æ ‡ä¹‹å‰é€‰æ‹©è¯æ˜å·¦è¾¹æˆ–å³è¾¹ï¼\n"
"\n"
"æˆ‘ç•™ä¸‹äº†ä¸€äº›éšè—çš„æç¤ºï¼›å¦‚æœä½ éœ€è¦ï¼Œè¯·ä»å¤´å¼€å§‹é‡è¯•å¹¶ç‚¹å‡»â€œæ˜¾ç¤ºæ›´å¤šå¸®åŠ©â€ï¼"

#: Game.Levels.LessOrEqual.L08le_total
msgid "If $x$ and $y$ are numbers, then either $x \\leq y$ or $y \\leq x$."
msgstr "å¦‚æœ $x$ å’Œ $y$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $x \\leq y$ æˆ– $y \\leq x$ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid "Start with `induction Â«{y}Â» with d hd`."
msgstr "ä»`induction Â«{y}Â» with d hd`å¼€å§‹ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid "Try `cases Â«{hd}Â» with h1 h2`."
msgstr "å°è¯• `cases Â«{hd}Â» with h1 h2`ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid "Now `cases Â«{h2}Â» with e he`."
msgstr "ç°åœ¨ä½¿ç”¨ `cases Â«{h2}Â» with e he`ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid "You still don't know which way to go, so do `cases Â«{e}Â» with a`."
msgstr "ä½ ä»ç„¶ä¸çŸ¥é“è¯¥èµ°å“ªä¸ªåˆ†æ”¯ï¼Œæ‰€ä»¥è¦åš `cases Â«{e}Â» with a`ã€‚"

#: Game.Levels.LessOrEqual.L08le_total
msgid ""
"Very well done.\n"
"\n"
"A passing mathematician remarks that with you've just proved that `â„•` is totally\n"
"ordered.\n"
"\n"
"The final few levels in this world are much easier."
msgstr ""
"å¤ªæ£’äº†ï¼\n"
"\n"
"ä¸€ä½è·¯è¿‡çš„æ•°å­¦å®¶è¯„è®ºè¯´ï¼Œæ‚¨åˆšåˆšè¯æ˜äº†è‡ªç„¶æ•°é›† `â„•` æ˜¯å…¨åºçš„ã€‚\n"
"\n"
"å‰©ä¸‹çš„å…³å¡ä¼šæ›´å®¹æ˜“ä¸€äº›ã€‚"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "succ x â‰¤ succ y â†’ x â‰¤ y"
msgstr "succ x â‰¤ succ y â†’ x â‰¤ y"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "`succ_le_succ x y` is a proof that if `succ x â‰¤ succ y` then `x â‰¤ y`."
msgstr "`succ_le_succ x y` æ˜¯å¦‚æœ `succ x â‰¤ succ y` é‚£ä¹ˆ `x â‰¤ y` çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid ""
"We've proved that `x â‰¤ 0` implies `x = 0`. The last two levels\n"
"in this world will prove which numbers are `â‰¤ 1` and `â‰¤ 2`.\n"
"This lemma will be helpful for them."
msgstr ""
"æˆ‘ä»¬å·²ç»è¯æ˜ `x â‰¤ 0` è•´æ¶µ `x = 0`ã€‚\n"
"åœ¨è¿™ä¸ªä¸–ç•Œçš„æœ€åä¸¤å…³å°†è¯æ˜å“ªäº›æ•°å­—æ˜¯ `â‰¤ 1` å’Œ `â‰¤ 2` çš„ã€‚\n"
"è¿™ä¸ªå¼•ç†å¯¹è¯æ˜å®ƒä»¬å°†æ˜¯æœ‰å¸®åŠ©çš„ã€‚"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid "If $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ then $x \\leq y$."
msgstr "å¦‚æœ $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ é‚£ä¹ˆ $x \\leq y$ã€‚"

#: Game.Levels.LessOrEqual.L09succ_le_succ
msgid ""
"Here's my proof:\n"
"```\n"
"cases hx with d hd\n"
"use d\n"
"rw [succ_add] at hd\n"
"apply succ_inj at hd\n"
"exact hd\n"
"```"
msgstr ""
"è¿™æ˜¯ä¸€ä¸ªè¯æ˜ï¼ˆä¸å”¯ä¸€ï¼‰ï¼š\n"
"```\n"
"cases hx with d hd\n"
"use d\n"
"rw [succ_add] at hd\n"
"apply succ_inj at hd\n"
"exact hd\n"
"```"

#: Game.Levels.LessOrEqual.L10le_one
msgid "x â‰¤ 1"
msgstr "xâ‰¤1"

#: Game.Levels.LessOrEqual.L10le_one
msgid "`le_one x` is a proof that if `x â‰¤ 1` then `x = 0` or `x = 1`."
msgstr "`le_one x` æ˜¯â€œå¦‚æœ `x â‰¤ 1` é‚£ä¹ˆ `x = 0` æˆ– `x = 1` â€çš„è¯æ˜ã€‚"

#: Game.Levels.LessOrEqual.L10le_one
msgid ""
"We've seen `le_zero`, the proof that if `x â‰¤ 0` then `x = 0`.\n"
"Now we'll prove that if `x â‰¤ 1` then `x = 0` or `x = 1`."
msgstr ""
"æˆ‘ä»¬å·²ç»çœ‹åˆ°äº† `le_zero`ï¼Œè¿™æ˜¯å¦‚æœ `x â‰¤ 0` é‚£ä¹ˆ `x = 0` çš„è¯æ˜ã€‚\n"
"ç°åœ¨æˆ‘ä»¬å°†è¯æ˜å¦‚æœ `x â‰¤ 1` é‚£ä¹ˆ `x = 0` æˆ– `x = 1`ã€‚"

#: Game.Levels.LessOrEqual.L10le_one
msgid "If $x \\leq 1$ then either $x = 0$ or $x = 1$."
msgstr "å¦‚æœ $x \\leq 1$ é‚£ä¹ˆ $x = 0$ æˆ– $x = 1$ã€‚"

#: Game.Levels.LessOrEqual.L10le_one
msgid ""
"Here's my proof:\n"
"```\n"
"cases x with y\n"
"left\n"
"rfl\n"
"rw [one_eq_succ_zero] at hx âŠ¢\n"
"apply succ_le_succ at hx\n"
"apply le_zero at hx\n"
"rw [hx]\n"
"right\n"
"rfl\n"
"```\n"
"\n"
"If you solved this level then you should be fine with the next level!"
msgstr ""
"è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n"
"```\n"
"cases x with y\n"
"left\n"
"rfl\n"
"rw [one_eq_succ_zero] at hx âŠ¢\n"
"apply succ_le_succ at hx\n"
"apply le_zero at hx\n"
"rw [hx]\n"
"right\n"
"rfl\n"
"```\n"
"\n"
"å¦‚æœä½ è§£å†³äº†è¿™ä¸ªå…³å¡ï¼Œé‚£ä¹ˆä½ åº”è¯¥å¯ä»¥é¡ºåˆ©è¿›å…¥ä¸‹ä¸€ä¸ªå…³å¡ï¼"

#: Game.Levels.LessOrEqual.L11le_two
msgid "le_two"
msgstr "le_two"

#: Game.Levels.LessOrEqual.L11le_two
msgid "`le_two x` is a proof that if `x â‰¤ 2` then `x = 0` or `x = 1` or `x = 2`."
msgstr "`le_two x` è¯æ˜äº†å¦‚æœ `x â‰¤ 2` åˆ™ `x = 0` æˆ– `x = 1` æˆ– `x = 2`ã€‚"

#: Game.Levels.LessOrEqual.L11le_two
msgid ""
"We'll need this lemma to prove that two is prime!\n"
"\n"
"You'll need to know that `âˆ¨` is right associative. This means that\n"
"`x = 0 âˆ¨ x = 1 âˆ¨ x = 2` actually means `x = 0 âˆ¨ (x = 1 âˆ¨ x = 2)`.\n"
"This affects how `left` and `right` work."
msgstr ""
"æˆ‘ä»¬éœ€è¦è¿™ä¸ªå¼•ç†æ¥è¯æ˜äºŒæ˜¯è´¨æ•°ï¼\n"
"\n"
"ä½ éœ€è¦çŸ¥é“ `âˆ¨` æ˜¯å³ç»“åˆçš„ã€‚è¿™æ„å‘³ç€ `x = 0 âˆ¨ x = 1 âˆ¨ x = 2` å®é™…ä¸Šæ„å‘³ç€ `x = 0 âˆ¨ (x = 1 âˆ¨ x = 2)`ã€‚"
"è¿™ä¼šå½±å“ `left` å’Œ `right` çš„å·¥ä½œæ–¹å¼ã€‚"

#: Game.Levels.LessOrEqual.L11le_two
msgid "If $x \\leq 2$ then $x = 0$ or $1$ or $2$."
msgstr "å¦‚æœæ˜¯ $x \\leq 2$ï¼Œé‚£ä¹ˆ $x = 0$ æˆ– $1$ æˆ– $2$ã€‚"

#: Game.Levels.LessOrEqual.L11le_two
msgid ""
"Nice!\n"
"\n"
"The next step in the development of order theory is to develop\n"
"the theory of the interplay between `â‰¤` and multiplication.\n"
"If you've already done Multiplication World, you're now ready for\n"
"Advanced Multiplication World. Click on \"Leave World\" to access it."
msgstr ""
"å¾ˆæ£’ï¼\n"
"\n"
"å‘å±•åºç†è®ºçš„ä¸‹ä¸€æ­¥æ˜¯å‘å±• `â‰¤` ä¸ä¹˜æ³•ä¹‹é—´ç›¸äº’ä½œç”¨çš„ç†è®ºã€‚\n"
"å¦‚æœä½ å·²ç»å®Œæˆäº†ä¹˜æ³•ä¸–ç•Œï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›å…¥é«˜çº§ä¹˜æ³•ä¸–ç•Œã€‚ç‚¹å‡» \"ç¦»å¼€ä¸–ç•Œ \"è¿›å…¥ã€‚"

#: Game.Levels.LessOrEqual
msgid "â‰¤ World"
msgstr "â‰¤ ä¸–ç•Œ"

#: Game.Levels.LessOrEqual
msgid ""
"In this world we define `a â‰¤ b` and prove standard facts\n"
"about it, such as \"if `a â‰¤ b` and `b â‰¤ c` then `a â‰¤ c`.\"\n"
"\n"
"The definition of `a â‰¤ b` is \"there exists a number `c`\n"
"such that `b = a + c`. \" So we're going to have to learn\n"
"a tactic to prove \"exists\" theorems, and another one\n"
"to use \"exists\" hypotheses.\n"
"\n"
"Click on \"Start\" to proceed."
msgstr ""
"åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å®šä¹‰ `a â‰¤ b` å¹¶è¯æ˜å…³äºå®ƒçš„ä¸€äº›äº‹å®ï¼Œä¾‹å¦‚â€œå¦‚æœ `a â‰¤ b` ä¸” `b â‰¤ c` é‚£ä¹ˆ `a â‰¤ c`ã€‚â€\n"
"\n"
"`a â‰¤ b` çš„å®šä¹‰æ˜¯â€œå­˜åœ¨ä¸€ä¸ªæ•°å­— `c` ä½¿å¾— `b = a + c`ã€‚â€æ‰€ä»¥æˆ‘ä»¬å°†ä¸å¾—ä¸å­¦ä¹ ä¸€ç§ç­–ç•¥æ¥è¯æ˜â€œå­˜åœ¨â€å®šç†ï¼Œä»¥"
"åŠå¦ä¸€ç§ç­–ç•¥æ¥ä½¿ç”¨â€œå­˜åœ¨â€å‡è®¾ã€‚\n"
"\n"
"ç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚"

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "mul_le_mul_right"
msgstr "mul_le_mul_right"

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "`mul_le_mul_right a b t` is a proof that `a â‰¤ b â†’ a * t â‰¤ b * t`."
msgstr "`mul_le_mul_right a b t` æ˜¯ `a â‰¤ b â†’ a * t â‰¤ b * t` çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid "Let's warm up with an easy one, which works even if `t = 0`."
msgstr "è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„é—®é¢˜æ¥çƒ­çƒ­èº«ï¼Œå³ä½¿ `t = 0` ä¹Ÿå¯ä»¥ã€‚"

#: Game.Levels.AdvMultiplication.L01mul_le_mul_right
msgid ""
"My proof:\n"
"```\n"
"cases h with d hd\n"
"use d * t\n"
"rw [hd, add_mul]\n"
"rfl\n"
"```"
msgstr ""
"æˆ‘çš„è¯æ˜ï¼š\n"
"```\n"
"cases h with d hd\n"
"use d * t\n"
"rw [hd, add_mul]\n"
"rfl\n"
"```"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "mul_left_ne_zero"
msgstr "mul_left_ne_zero"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "`mul_left_ne_zero a b` is a proof that `a * b â‰  0 â†’ b â‰  0`."
msgstr "`mul_left_ne_zero a b` æ˜¯`a * b â‰  0 â†’ b â‰  0` çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid ""
"If you have completed Algorithm World then you can use the `contrapose!` tactic\n"
"here. If not then I'll talk you through a manual approach."
msgstr ""
"å¦‚æœä½ å·²ç»å®Œæˆäº†ç®—æ³•ä¸–ç•Œï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ `contrapose!` ç­–ç•¥ã€‚\n"
"å¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä¼šæŒ‡å¯¼ä½ ä½¿ç”¨ä¸€ç§æ‰‹åŠ¨æ–¹æ³•ã€‚"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid ""
"We want to reduce this to a hypothesis `b = 0` and a goal `a * b = 0`,\n"
"which is logically equivalent but much easier to prove. Remember that `X â‰  0`\n"
"is notation for `X = 0 â†’ False`. Click on `Show more help!` if you need hints."
msgstr ""
"æˆ‘ä»¬æƒ³å°†è¿™ä¸ªé—®é¢˜ç®€åŒ–ä¸ºå‡è®¾ `b = 0` å’Œç›®æ ‡ `a * b = 0`ï¼Œè¿™åœ¨é€»è¾‘ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œä½†æ›´å®¹æ˜“è¯æ˜ã€‚\n"
"è®°ä½ï¼Œ`x â‰  0` æ˜¯ `x = 0 â†’ False` çš„ç¬¦å·è¡¨ç¤ºã€‚å¦‚æœä½ éœ€è¦æç¤ºï¼Œè¯·ç‚¹å‡»`æ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼`ã€‚"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "Start with `intro hb`."
msgstr "ä» `intro hb` å¼€å§‹ã€‚"

#: Game.Levels.AdvMultiplication.L02mul_left_ne_zero
msgid "Now `apply h` and you can probably take it from here."
msgstr "ç°åœ¨ä½¿ç”¨ `apply h`ï¼Œä½ ä¹Ÿè®¸å¯ä»¥ä»è¿™é‡Œå¼€å§‹è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "eq_succ_of_ne_zero"
msgstr "eq_succ_of_ne_zero"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"# Summary\n"
"\n"
"The `tauto` tactic will solve any goal which can be solved purely by logic (that is, by\n"
"truth tables).\n"
"\n"
"## Example\n"
"\n"
"If you have `False` as a hypothesis, then `tauto` will solve\n"
"the goal. This is because a false hypothesis implies any hypothesis.\n"
"\n"
"## Example\n"
"\n"
"If your goal is `True`, then `tauto` will solve the goal.\n"
"\n"
"## Example\n"
"\n"
"If you have two hypotheses `h1 : a = 37` and `h2 : a â‰  37` then `tauto` will\n"
"solve the goal because it can prove `False` from your hypotheses, and thus\n"
"prove the goal (as `False` implies anything).\n"
"\n"
"## Example\n"
"\n"
"If you have one hypothesis `h : a â‰  a` then `tauto` will solve the goal because\n"
"`tauto` is smart enough to know that `a = a` is true, which gives the contradiction we seek.\n"
"\n"
"## Example\n"
"\n"
"If you have a hypothesis of the form `a = 0 â†’ a * b = 0` and your goal is `a * b â‰  0 â†’ a â‰  0`, then\n"
"`tauto` will solve the goal, because the goal is logically equivalent to the hypothesis.\n"
"If you switch the goal and hypothesis in this example, `tauto` would solve it too."
msgstr ""
"## æ¦‚è¿°\n"
"\n"
"`tauto` ç­–ç•¥å°†è§£å†³ä»»ä½•åªé å‘½é¢˜é€»è¾‘å°±å¯ä»¥è§£å†³çš„ç›®æ ‡ï¼ˆå³ï¼Œé€šè¿‡çœŸå€¼è¡¨ï¼‰ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ä¸º `False`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ã€‚è¿™æ˜¯å› ä¸ºä¸€ä¸ªå‡çš„å‡è®¾æ„å‘³ç€ä»»ä½•å‡è®¾ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ çš„ç›®æ ‡æ˜¯ `True`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾ `h1 : a = 37` å’Œ `h2 : a â‰  37`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ï¼Œå› ä¸ºå®ƒå¯ä»¥ä»ä½ çš„å‡è®¾ä¸­è¯æ˜ "
"`False`ï¼Œä»è€Œè¯æ˜ç›®æ ‡ï¼ˆå› ä¸º `False` æ„å‘³ç€ä»»ä½•äº‹æƒ…ï¼‰ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  a`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ï¼Œå› ä¸º `tauto` è¶³å¤Ÿèªæ˜ä»¥çŸ¥é“ `a = a` æ˜¯çœŸçš„ï¼Œè¿™"
"æä¾›äº†æˆ‘ä»¬å¯»æ±‚çš„çŸ›ç›¾ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a = 0 â†’ a * b = 0` çš„å‡è®¾ï¼Œè€Œä½ çš„ç›®æ ‡æ˜¯ `a * b â‰  0 â†’ a â‰  0`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³"
"ç›®æ ‡ï¼Œå› ä¸ºç›®æ ‡åœ¨é€»è¾‘ä¸Šç­‰åŒäºå‡è®¾ã€‚\n"
"å¦‚æœä½ åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­äº¤æ¢ç›®æ ‡å’Œå‡è®¾ï¼Œ`tauto` ä¹Ÿä¼šè§£å†³å®ƒã€‚\n"
"å¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾ `h1 : a = 37` å’Œ `h2 : a â‰  37` é‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡\n"
"å°±èƒ½è§£å†³è¿™ä¸ªç›®æ ‡ï¼Œå› ä¸ºå®ƒèƒ½ä»ä½ çš„å‡è®¾ä¸­è¯æ˜ `False`ï¼Œä»è€Œ\n"
"è¯æ˜ç›®æ ‡ï¼ˆå› ä¸º `False` æ„å‘³ç€ä»»ä½•äº‹æƒ…ï¼‰ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  a` é‚£ä¹ˆ `tauto` å°±èƒ½è¯æ˜è¿™ä¸ªç›®æ ‡ï¼Œå› ä¸º\n"
"`tauto` è¶³å¤Ÿèªæ˜ï¼ŒçŸ¥é“ `a = a` ä¸ºçœŸï¼Œè¿™å°±ç»™å‡ºäº†æˆ‘ä»¬æ‰€å¯»æ±‚çš„çŸ›ç›¾ã€‚\n"
"\n"
"### ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a = 0 â†’ a * b = 0` çš„å‡è®¾ï¼Œè€Œä½ çš„ç›®æ ‡æ˜¯ `a * b â‰  0 â†’ a â‰  0`ï¼Œé‚£ä¹ˆ\n"
"`tauto` å°†è¯æ˜ç›®æ ‡ï¼Œå› ä¸ºç›®æ ‡åœ¨é€»è¾‘ä¸Šç­‰åŒäºå‡è®¾ã€‚\n"
"å¦‚æœæŠŠè¿™ä¸ªä¾‹å­ä¸­çš„ç›®æ ‡å’Œå‡è®¾æ¢ä¸€ä¸‹ï¼Œ`tauto` ä¹Ÿä¼šè§£å†³å®ƒã€‚"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "`eq_succ_of_ne_zero a` is a proof that `a â‰  0 â†’ âˆƒ n, a = succ n`."
msgstr "`eq_succ_of_ne_zero a` æ˜¯ `aâ‰ 0 â†’ âˆƒ n, a = succ n` çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"Multiplication usually makes a number bigger, but multiplication by zero can make\n"
"it smaller. Thus many lemmas about inequalities and multiplication need the\n"
"hypothesis `a â‰  0`. Here is a key lemma enables us to use this hypothesis.\n"
"To help us with the proof, we can use the `tauto` tactic. Click on the tactic's name\n"
"on the right to see what it does."
msgstr ""
"ä¹˜æ³•é€šå¸¸ä¼šä½¿ä¸€ä¸ªæ•°å­—å˜å¤§ï¼Œä½†æ˜¯ä¹˜ä»¥é›¶å¯ä»¥ä½¿å®ƒå˜å°ã€‚å› æ­¤ï¼Œå…³äºä¸ç­‰å¼å’Œä¹˜æ³•çš„è®¸å¤šå¼•ç†éœ€è¦å‡è®¾ `a â‰  "
"0`ã€‚\n"
"è¿™é‡Œæœ‰ä¸€ä¸ªå…³é”®çš„å¼•ç†ä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨è¿™ä¸ªå‡è®¾ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `tauto` ç­–ç•¥å¸®åŠ©æˆ‘ä»¬è¿›è¡Œè¯æ˜ã€‚ç‚¹å‡»å³ä¾§çš„ç­–ç•¥"
"åç§°æŸ¥çœ‹å®ƒçš„ä½œç”¨ã€‚"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid "Start with `cases a with d` to do a case split on `a = 0` and `a = succ d`."
msgstr "ä»ç”¨ `cases a with d` å¼€å§‹ï¼Œå¯¹ `a = 0` å’Œ `a = succ d` è¿›è¡Œç±»è®¨è®ºã€‚"

#: Game.Levels.AdvMultiplication.L03eq_succ_of_ne_zero
msgid ""
"In the \"base case\" we have a hypothesis `ha : 0 â‰  0`, and you can deduce anything\n"
"from a false statement. The `tauto` tactic will close this goal."
msgstr ""
"åœ¨â€œåŸºç¡€æƒ…å½¢â€ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå‡è®¾ `ha : 0 â‰  0`ï¼Œä½ å¯ä»¥ä»ä¸€ä¸ªå‡å‘½é¢˜ä¸­æ¨å¯¼å‡ºä»»ä½•ä¸œè¥¿ã€‚`tauto` ç­–ç•¥å°†è¯æ˜è¿™"
"ä¸ªç›®æ ‡ã€‚"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "one_le_of_ne_zero"
msgstr "one_le_of_ne_zero"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "`one_le_of_ne_zero a` is a proof that `a â‰  0 â†’ 1 â‰¤ a`."
msgstr "`one_le_of_ne_zero a` æ˜¯ `aâ‰ 0 â†’ 1â‰¤a` çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "The previous lemma can be used to prove this one."
msgstr "å…ˆå‰çš„å¼•ç†å¯ä»¥ç”¨æ¥è¯æ˜è¿™ä¸ªå¼•ç†ã€‚"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Use the previous lemma with `apply eq_succ_of_ne_zero at ha`."
msgstr "é€šè¿‡`apply eq_succ_of_ne_zero at ha`æ¥ä½¿ç”¨å‰é¢çš„å¼•ç†ã€‚"

#: Game.Levels.AdvMultiplication.L04one_le_of_ne_zero
msgid "Now take apart the existence statement with `cases ha with n hn`."
msgstr "ç°åœ¨ç”¨ `cases ha with n hn` åˆ†ç±»è®¨è®ºå­˜åœ¨æ€§å®šç†ã€‚"

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid "le_mul_right"
msgstr "le_mul_right"

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"`le_mul_right a b` is a proof that `a * b â‰  0 â†’ a â‰¤ a * b`.\n"
"\n"
"It's one way of saying that a divisor of a positive number\n"
"has to be at most that number."
msgstr ""
"`le_mul_right a b` æ˜¯ `a * b â‰  0 â†’ a â‰¤ a * b` çš„è¯æ˜ã€‚\n"
"\n"
"è¿™æ˜¯è¡¨è¾¾ä¸€ä¸ªæ­£æ•°çš„é™¤æ•°ä¸ä¼šå¤§äºè¿™ä¸ªæ•°çš„ä¸€ç§æ–¹å¼ã€‚"

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"In Prime Number World we will be proving that $2$ is prime.\n"
"To do this, we will have to rule out things like $2 â‰  37 Ã— 42.$\n"
"We will do this by proving that any factor of $2$ is at most $2$,\n"
"which we will do using this lemma. The proof I have in mind manipulates the hypothesis\n"
"until it becomes the goal, using pretty much everything which we've proved in this world so far."
msgstr ""
"åœ¨è´¨æ•°ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ $2$ æ˜¯è´¨æ•°ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ’é™¤åƒ $2 â‰  37 Ã— 42$ è¿™æ ·çš„æƒ…å†µã€‚\n"
"æˆ‘ä»¬å°†é€šè¿‡è¯æ˜ $2$ çš„ä»»ä½•å› æ•°æœ€å¤šæ˜¯ $2$ æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªå¼•ç†æ¥å®ç°ã€‚\n"
"æˆ‘è„‘æµ·ä¸­çš„è¯æ˜ä¼šæ“ä½œå‡è®¾ï¼Œç›´åˆ°å®ƒå˜æˆç›®æ ‡ï¼Œå‡ ä¹ä½¿ç”¨æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢åœ¨è¿™ä¸ªä¸–ç•Œä¸­å·²ç»è¯æ˜çš„æ‰€æœ‰å†…å®¹ã€‚"

#: Game.Levels.AdvMultiplication.L05le_mul_right
msgid ""
"Here's what I was thinking of:\n"
"```\n"
"apply mul_left_ne_zero at h\n"
"apply one_le_of_ne_zero at h\n"
"apply mul_le_mul_right 1 b a at h\n"
"rw [one_mul, mul_comm] at h\n"
"exact h\n"
"```"
msgstr ""
"æˆ‘æ˜¯è¿™ä¹ˆæƒ³çš„ï¼š\n"
"```\n"
"apply mul_left_ne_zero at h\n"
"apply one_le_of_ne_zero at h\n"
"apply mul_le_mul_right 1 b a at h\n"
"rw [one_mul, mul_comm] at h\n"
"exact h\n"
"```"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "mul_right_eq_one"
msgstr "mul_right_eq_one"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"# Summary\n"
"\n"
"The `have` tactic can be used to add new hypotheses to a level, but of course\n"
"you have to prove them.\n"
"\n"
"\n"
"## Example\n"
"\n"
"The simplest usage is like this. If you have `a` in your context and you execute\n"
"\n"
"`have ha : a = 0`\n"
"\n"
"then you will get a new goal `a = 0` to prove, and after you've proved\n"
"it you will have a new hypothesis `ha : a = 0` in your original goal.\n"
"\n"
"## Example\n"
"\n"
"If you already have a proof of what you want to `have`, you\n"
"can just create it immediately. For example, if you have `a` and `b`\n"
"number objects, then\n"
"\n"
"`have h2 : succ a = succ b â†’ a = b := succ_inj a b`\n"
"\n"
"will directly add a new hypothesis `h2 : succ a = succ b â†’ a = b`\n"
"to the context, because you just supplied the proof of it (`succ_inj a b`).\n"
"\n"
"## Example\n"
"\n"
"If you have a proof to hand, then you don't even need to state what you\n"
"are proving. example\n"
"\n"
"`have h2 := succ_inj a b`\n"
"\n"
"will add `h2 : succ a = succ b â†’ a = b` as a hypothesis."
msgstr ""
"# å°ç»“\n"
"\n"
"`have` ç­–ç•¥å¯ä»¥ç”¨æ¥å‘ä¸€ä¸ªå…³å¡æ·»åŠ æ–°çš„å‡è®¾ï¼Œä½†å½“ç„¶ï¼Œä½ å¿…é¡»è¯æ˜å®ƒä»¬ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"æœ€ç®€å•çš„ä½¿ç”¨æ–¹å¼æ˜¯è¿™æ ·çš„ã€‚å¦‚æœä½ åœ¨ä½ çš„ä¸Šä¸‹æ–‡ä¸­æœ‰ `a` å¹¶ä¸”ä½ æ‰§è¡Œäº†\n"
"\n"
"`have ha : a = 0`\n"
"\n"
"é‚£ä¹ˆä½ å°†å¾—åˆ°ä¸€ä¸ªæ–°çš„ç›®æ ‡ `a = 0` æ¥è¯æ˜ï¼Œä¸€æ—¦ä½ è¯æ˜äº†å®ƒï¼Œä½ å°†åœ¨ä½ åŸå§‹çš„ç›®æ ‡ä¸­æœ‰ä¸€ä¸ªæ–°çš„å‡è®¾ `ha : a "
"= 0`ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ å·²ç»æœ‰äº†ä½ æƒ³è¦ `have` çš„è¯æ˜ï¼Œä½ å¯ä»¥ç«‹å³åˆ›å»ºå®ƒã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ `a` å’Œ `b` è¿™ä¸¤ä¸ªæ•°å­—å¯¹è±¡ï¼Œé‚£"
"ä¹ˆ\n"
"\n"
"`have h2 : succ a = succ b â†’ a = b := succ_inj a b`\n"
"\n"
"å°†ç›´æ¥å‘ä¸Šä¸‹æ–‡ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„å‡è®¾ `h2 : succ a = succ b â†’ a = b`ï¼Œå› ä¸ºä½ åˆšåˆšæä¾›äº†å®ƒçš„è¯æ˜ï¼ˆ`succ_inj "
"a b`ï¼‰ã€‚\n"
"\n"
"## ç¤ºä¾‹\n"
"\n"
"å¦‚æœä½ æ‰‹å¤´æœ‰è¯æ˜ï¼Œé‚£ä¹ˆä½ ç”šè‡³ä¸éœ€è¦å£°æ˜ä½ åœ¨è¯æ˜ä»€ä¹ˆã€‚ä¾‹å¦‚\n"
"\n"
"`have h2 := succ_inj a b`\n"
"\n"
"å°†ä¼šæ·»åŠ å‡è®¾ `h2 : succ a = succ b â†’ a = b`ã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "`mul_right_eq_one a b` is a proof that `a * b = 1 â†’ a = 1`."
msgstr "`mul_right_eq_one a b`è¯æ˜äº†`a * b = 1 â†’ a = 1`ã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"This level proves `x * y = 1 â†’ x = 1`, the multiplicative analogue of Advanced Addition\n"
"World's `x + y = 0 â†’ x = 0`. The strategy is to prove that `x â‰¤ 1` and then use the\n"
"lemma `le_one` from `â‰¤` world.\n"
"\n"
"We'll prove it using a new and very useful tactic called `have`."
msgstr ""
"åœ¨è¿™ä¸ªå…³å¡ï¼Œæˆ‘ä»¬è¯æ˜äº† `x * y = 1 â†’ x = 1`ï¼Œè¿™æ˜¯é«˜çº§åŠ æ³•ä¸–ç•Œä¸­ `x + y = 0 â†’ x = 0` çš„ä¹˜æ³•ç±»æ¯”ã€‚ç­–ç•¥æ˜¯"
"è¯æ˜ `x â‰¤ 1`ï¼Œç„¶åä½¿ç”¨æ¥è‡ª `â‰¤` ä¸–ç•Œçš„å¼•ç† `le_one`ã€‚\n"
"\n"
"æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªæ–°çš„éå¸¸æœ‰ç”¨çš„ç­–ç•¥å«åš `have` æ¥è¯æ˜å®ƒã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"We want to use `le_mul_right`, but we need a hypothesis `x * y â‰  0`\n"
"which we don't have. Yet. Execute `have h2 : x * y â‰  0` (you can type `â‰ ` with `\\ne`).\n"
"You'll be asked to\n"
"prove it, and then you'll have a new hypothesis which you can apply\n"
"`le_mul_right` to."
msgstr ""
"æˆ‘ä»¬æƒ³ä½¿ç”¨ `le_mul_right`ï¼Œä½†æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæˆ‘ä»¬è¿˜æ²¡æœ‰çš„å‡è®¾ `x * y â‰  0`ã€‚\n"
"ç°åœ¨æ‰§è¡Œ `have h2 : x * y â‰  0`ï¼ˆä½ å¯ä»¥ç”¨ `\\ne` è¾“å…¥ `â‰ `ï¼‰ã€‚\n"
"ä½ å°†è¢«è¦æ±‚è¯æ˜å®ƒï¼Œç„¶åä½ å°†æœ‰ä¸€ä¸ªæ–°çš„å‡è®¾ï¼Œä½ å¯ä»¥åº”ç”¨ `le_mul_right` åˆ°è¿™ä¸ªå‡è®¾ä¸Šã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now you can `apply le_mul_right at h2`."
msgstr "ç°åœ¨ï¼Œæ‚¨å¯ä»¥`apply le_mul_right at h2`ã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "Now `rw [h] at h2` so you can `apply le_one at hx`."
msgstr "ç°åœ¨`rw [h] at h2`ï¼Œè¿™æ ·å°±å¯ä»¥`apply le_one at hx`ã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid ""
"Now `cases h2 with h0 h1` and deal with the two\n"
"cases separately."
msgstr "ç°åœ¨ä½¿ç”¨ `cases h2 with h0 h1` aï¼Œå¹¶åˆ†ç±»è®¨è®ºè¿™ä¸¤ç§æƒ…å†µã€‚"

#: Game.Levels.AdvMultiplication.L06mul_right_eq_one
msgid "`tauto` is good enough to solve this goal."
msgstr "`tauto` è¶³ä»¥è¯æ˜è¿™ä¸€ç›®æ ‡ã€‚"

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "mul_ne_zero"
msgstr "mul_ne_zero"

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "`mul_ne_zero a b` is a proof that if `a â‰  0` and `b â‰  0` then `a * b â‰  0`."
msgstr "`mul_ne_zero a b` æ˜¯å¦‚æœ `a â‰  0` ä¸” `b â‰  0`ï¼Œé‚£ä¹ˆ `a * b â‰  0`è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid ""
"This level proves that if `a â‰  0` and `b â‰  0` then `a * b â‰  0`. One strategy\n"
"is to write both `a` and `b` as `succ` of something, deduce that `a * b` is\n"
"also `succ` of something, and then `apply zero_ne_succ`."
msgstr ""
"è¿™ä¸ªå…³å¡è¦è¯æ˜å¦‚æœ `a â‰  0` ä¸” `b â‰  0`ï¼Œé‚£ä¹ˆ `a * b â‰  0`ã€‚\n"
"ä¸€ç§ç­–ç•¥æ˜¯å°† `a` å’Œ `b` éƒ½å†™æˆæŸç‰©çš„ `succ`ï¼ˆåç»§ï¼‰ï¼Œæ¨æ–­å‡º `a * b` ä¹Ÿæ˜¯æŸç‰©çš„ `succ`ï¼Œç„¶ååº”ç”¨ "
"`zero_ne_succ`ã€‚"

#: Game.Levels.AdvMultiplication.L07mul_ne_zero
msgid "Start with `apply eq_succ_of_ne_zero at ha` and `... at hb`"
msgstr "ä»¥`åœ¨ ha å¤„åº”ç”¨ eq_succ_of_ne_zero` å’Œ`......åœ¨ hb` å¼€å¤´"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "mul_eq_zero"
msgstr "mul_eq_zero"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "`mul_eq_zero a b` is a proof that if `a * b = 0` then `a = 0` or `b = 0`."
msgstr "`mul_eq_zero a b` è¯æ˜å¦‚æœ `a * b = 0` åˆ™ `a = 0` æˆ– `b = 0`ã€‚"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid ""
"This level proves that if `a * b = 0` then `a = 0` or `b = 0`. It is\n"
"logically equivalent to the last level, so there is a very short proof."
msgstr ""
"è¿™ä¸ªå…³å¡è¦è¯æ˜å¦‚æœ `a * b = 0` é‚£ä¹ˆ `a = 0` æˆ–è€… `b = 0`ã€‚è¿™åœ¨é€»è¾‘ä¸Šç­‰åŒä¸Šä¸€ä¸ªå…³å¡ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ªéå¸¸ç®€"
"çŸ­çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid "Start with `have h2 := mul_ne_zero a b`."
msgstr "ä» `have h2 := mul_ne_zero a b` å¼€å§‹ã€‚"

#: Game.Levels.AdvMultiplication.L08mul_eq_zero
msgid ""
"Now the goal can be deduced from `h2` by pure logic, so use the `tauto`\n"
"tactic."
msgstr "ç°åœ¨ï¼Œç›®æ ‡å¯ä»¥é€šè¿‡çº¯ç²¹çš„é€»è¾‘ä» `h2` æ¨å¯¼å‡ºæ¥ï¼Œæ‰€ä»¥ä½¿ç”¨ `tauto` ç­–ç•¥ã€‚"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "mul_left_cancel"
msgstr "mul_left_cancel"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "`mul_left_cancel a b c` is a proof that if `a â‰  0` and `a * b = a * c` then `b = c`."
msgstr "`mul_left_cancel a b c` è¯æ˜äº†å¦‚æœ `a â‰  0` ä¸” `a * b = a * c` åˆ™ `b = c` ã€‚"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid ""
"In this level we prove that if `a * b = a * c` and `a â‰  0` then `b = c`. It is tricky, for\n"
"several reasons. One of these is that\n"
"we need to introduce a new idea: we will need to understand the concept of\n"
"mathematical induction a little better.\n"
"\n"
"Starting with `induction b with d hd` is too naive, because in the inductive step\n"
"the hypothesis is `a * d = a * c â†’ d = c` but what we know is `a * succ d = a * c`,\n"
"so the induction hypothesis does not apply!\n"
"\n"
"Assume `a â‰  0` is fixed. The actual statement we want to prove by induction on `b` is\n"
"\"for all `c`, if `a * b = a * c` then `b = c`. This *can* be proved by induction,\n"
"because we now have the flexibility to change `c`.\""
msgstr ""
"åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†å¦‚æœ `a * b = a * c` ä¸” `a â‰  0` é‚£ä¹ˆ `b = c`ã€‚è¿™æ˜¯æœ‰äº›éš¾çš„ï¼Œå› ä¸ºå‡ ä¸ªåŸå› ã€‚å…¶"
"ä¸­ä¹‹ä¸€æ˜¯æˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªæ–°çš„æƒ³æ³•ï¼šæˆ‘ä»¬éœ€è¦æ›´å¥½åœ°ç†è§£æ•°å­¦å½’çº³æ³•çš„æ¦‚å¿µã€‚\n"
"\n"
"ä» `induction b with d hd` å¼€å§‹å¤ªå¤©çœŸäº†ï¼Œå› ä¸ºåœ¨å½’çº³æ­¥éª¤ä¸­ï¼Œå‡è®¾æ˜¯ `a * d = a * c â†’ d = c`ï¼Œä½†æˆ‘ä»¬æ‰€çŸ¥"
"çš„æ˜¯ `a * succ d = a * c`ï¼Œæ‰€ä»¥å½’çº³å‡è®¾ä¸é€‚ç”¨ï¼\n"
"\n"
"ç°åœ¨å‡è®¾ `a â‰  0` æ˜¯å›ºå®šçš„ã€‚æˆ‘ä»¬æƒ³è¦é€šè¿‡å¯¹ `b` è¿›è¡Œå½’çº³æ¥è¯æ˜â€œå¯¹äºæ‰€æœ‰çš„ `c`ï¼Œå¦‚æœ `a * b = a * c` é‚£"
"ä¹ˆ `b = c`ã€‚è¿™*å¯ä»¥*é€šè¿‡å½’çº³æ¥è¯æ˜ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨æœ‰äº†æ”¹å˜ `c` çš„çµæ´»æ€§ã€‚â€"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "The way to start this proof is `induction b with d hd generalizing c`."
msgstr "å¼€å§‹è¯æ˜çš„æ–¹æ³•æ˜¯ `induction b with d hd generalizing c`ã€‚"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid ""
"Use `mul_eq_zero` and remember that `tauto` will solve a goal\n"
"if there are hypotheses `a = 0` and `a â‰  0`."
msgstr "ä½¿ç”¨ `mul_eq_zero` å¹¶è®°ä½ï¼Œå¦‚æœå­˜åœ¨å‡è®¾ `a = 0` å’Œ `a â‰  0`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ä¸€ä¸ªç›®æ ‡ã€‚"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid ""
"The inductive hypothesis `hd` is \"For all natural numbers `c`, `a * d = a * c â†’ d = c`\".\n"
"You can `apply` it `at` any hypothesis of the form `a * d = a * ?`."
msgstr ""
"å½’çº³å‡è®¾ `hd` æ˜¯â€œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° `c`ï¼Œ`a * d = a * c â†’ d = c`â€çš„è¯æ˜ã€‚ä½ å¯ä»¥åœ¨ä»»ä½•å½¢å¼ä¸º `a * d = a "
"* ?` çš„å‡è®¾ä¸Šåº”ç”¨ï¼ˆ`apply`ï¼‰å®ƒã€‚"

#: Game.Levels.AdvMultiplication.L09mul_left_cancel
msgid "Split into cases `c = 0` and `c = succ e` with `cases c with e`."
msgstr "ç”¨ `c cases c with e` åˆ†æˆ `c = 0` å’Œ `c = succ e` ä¸¤ç§æƒ…å†µè®¨è®ºã€‚"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "mul_right_eq_self"
msgstr "mul_right_eq_self"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "`mul_right_eq_self a b` is a proof that if `a â‰  0` and `a * b = a` then `b = 1`."
msgstr "`mul_right_eq_self a b` æ˜¯å‘½é¢˜å¦‚æœ `a â‰  0` ä¸” `a * b = a` é‚£ä¹ˆ `b = 1` çš„è¯æ˜ã€‚"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid ""
"The lemma proved in the final level of this world will be helpful\n"
"in Divisibility World."
msgstr "åœ¨è¿™ä¸ªä¸–ç•Œçš„æœ€åä¸€ä¸ªå…³å¡è¯æ˜çš„å¼•ç†å°†åœ¨å¯é™¤æ€§ä¸–ç•Œä¸­å¾ˆæœ‰å¸®åŠ©ã€‚"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "Reduce to the previous lemma with `nth_rewrite 2 [â† mul_one a] at h`"
msgstr "ä½¿ç”¨ `nth_rewrite 2 [â† mul_one a] at h` å°†é—®é¢˜ç®€åŒ–ä¸ºä¹‹å‰çš„å¼•ç†ã€‚"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid "You can now `apply mul_left_cancel at h`"
msgstr "ç°åœ¨æ‚¨å¯ä»¥ `apply mul_left_cancel at h` ã€‚"

#: Game.Levels.AdvMultiplication.L10mul_right_eq_self
msgid ""
"A two-line proof is\n"
"\n"
"```\n"
"nth_rewrite 2 [â† mul_one a] at h\n"
"exact mul_left_cancel a b 1 ha h\n"
"```\n"
"\n"
"We now have all the tools necessary to set up the basic theory of divisibility of naturals."
msgstr ""
"è¿™é‡Œæœ‰ä¸ªä¸¤è¡Œçš„è¯æ˜\n"
"\n"
"```\n"
"nth_rewrite 2 [â† mul_one a] at h\n"
"exact mul_left_cancel a b 1 ha h\n"
"```\n"
"\n"
"ç°åœ¨æˆ‘ä»¬æ‹¥æœ‰äº†å»ºç«‹è‡ªç„¶æ•°å¯é™¤æ€§åŸºæœ¬ç†è®ºæ‰€éœ€çš„æ‰€æœ‰å·¥å…·ã€‚"

#: Game.Levels.AdvMultiplication
msgid "Advanced Multiplication World"
msgstr "é«˜çº§ä¹˜æ³•ä¸–ç•Œ"

#: Game.Levels.AdvMultiplication
msgid ""
"Advanced *Addition* World proved various implications\n"
"involving addition, such as `x + y = 0 â†’ x = 0` and `x + y = x â†’ y = 0`.\n"
"These lemmas were used to prove basic facts about â‰¤ in â‰¤ World.\n"
"\n"
"In Advanced Multiplication World we prove analogous\n"
"facts about multiplication, such as `x * y = 1 â†’ x = 1`, and\n"
"`x * y = x â†’ y = 1` (assuming `x â‰  0` in the latter result). This will prepare\n"
"us for Divisibility World.\n"
"\n"
"Multiplication World is more complex than Addition World. In the same\n"
"way, Advanced Multiplication world is more complex than Advanced Addition\n"
"World. One reason for this is that certain intermediate results are only\n"
"true under the additional hypothesis that one of the variables is non-zero.\n"
"This causes some unexpected extra twists."
msgstr ""
"é«˜çº§ *åŠ æ³•* ä¸–ç•Œè¯æ˜äº†æ¶‰åŠåŠ æ³•çš„å„ç§å¼•ç†ï¼Œä¾‹å¦‚ `x + y = 0 â†’ x = 0` å’Œ `x + y = x â†’ y = 0`ã€‚è¿™äº›å¼•ç†è¢«"
"ç”¨æ¥è¯æ˜ â‰¤ ä¸–ç•Œä¸­å…³äº â‰¤ çš„åŸºæœ¬äº‹å®ã€‚\n"
"\n"
"åœ¨é«˜çº§ä¹˜æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†å…³äºä¹˜æ³•çš„ç±»ä¼¼äº‹å®ï¼Œä¾‹å¦‚ `x * y = 1 â†’ x = 1`ï¼Œä»¥åŠ `x * y = x â†’ y = "
"1`ï¼ˆåœ¨åä¸€ä¸ªç»“æœä¸­å‡è®¾ `x â‰  0`ï¼‰ã€‚è¿™å°†ä¸ºæˆ‘ä»¬è¿›å…¥å¯é™¤æ€§ä¸–ç•Œåšå‡†å¤‡ã€‚\n"
"\n"
"ä¹˜æ³•ä¸–ç•Œæ¯”åŠ æ³•ä¸–ç•Œæ›´ä¸ºå¤æ‚ã€‚åŒæ ·ï¼Œé«˜çº§ä¹˜æ³•ä¸–ç•Œæ¯”é«˜çº§åŠ æ³•ä¸–ç•Œæ›´ä¸ºå¤æ‚ã€‚å…¶ä¸­ä¸€ä¸ªåŸå› æ˜¯æŸäº›ä¸­é—´ç»“æœåªåœ¨"
"é¢å¤–å‡è®¾ä¸‹ä¸ºçœŸï¼Œå³å˜é‡ä¹‹ä¸€éé›¶ã€‚è¿™å¯¼è‡´äº†ä¸€äº›æ„æƒ³ä¸åˆ°çš„è½¬æŠ˜ã€‚"

#: Game
msgid "Natural Number Game"
msgstr "è‡ªç„¶æ•°æ¸¸æˆ"

#: Game
msgid ""
"# Welcome to the Natural Number Game\n"
"#### An introduction to mathematical proof.\n"
"\n"
"In this game, we will build the basic theory of the natural\n"
"numbers `{0,1,2,3,4,...}` from scratch. Our first goal is to prove\n"
"that `2 + 2 = 4`. Next we'll prove that `x + y = y + x`.\n"
"And at the end we'll see if we can prove Fermat's Last Theorem.\n"
"We'll do this by solving levels of a computer puzzle game called Lean.\n"
"\n"
"# Read this.\n"
"\n"
"Learning how to use an interactive theorem prover takes time.\n"
"Tests show that the people who get the most out of this game are\n"
"those who read the help texts like this one.\n"
"\n"
"To start, click on \"Tutorial World\".\n"
"\n"
"Note: this is a new Lean 4 version of the game containing several\n"
"worlds which were not present in the old Lean 3 version. A new version\n"
"of Advanced Multiplication World is in preparation, and worlds\n"
"such as Prime Number World and more will be appearing during October and\n"
"November 2023.\n"
"\n"
"## More\n"
"\n"
"Click on the three lines in the top right and select \"Game Info\" for resources,\n"
"links, and ways to interact with the Lean community."
msgstr ""
"# æ¬¢è¿è¿›å…¥è‡ªç„¶æ•°æ¸¸æˆ\n"
"### æ•°å­¦è¯æ˜çš„å¯è’™ã€‚\n"
"\n"
"æœ¬æ¸¸æˆå°†å¸¦é¢†æˆ‘ä»¬ä»å¤´å¼€å§‹æ„å»ºè‡ªç„¶æ•° `{0,1,2,3,4,...}` çš„åŸºç¡€ç†è®ºä½“ç³»ã€‚æˆ‘ä»¬é¦–å…ˆè¦è¯æ˜çš„æ˜¯ `2 + 2 = 4`ã€‚"
"ç´§æ¥ç€ï¼Œæˆ‘ä»¬ä¼šè¯æ˜ `x + y = y + x`ã€‚\n"
"æœ€ç»ˆï¼Œæˆ‘ä»¬å°†å°è¯•è¯æ˜è´¹é©¬å¤§å®šç†ã€‚\n"
"è¯·é€šè¿‡å®Œæˆæœ¬æ¸¸æˆä¸­çš„å…³å¡æ¥å®Œæˆè¿™äº›æŒ‘æˆ˜ã€‚\n"
"\n"
"## é˜…è¯»æç¤º\n"
"\n"
"æŒæ¡äº¤äº’å¼å®šç†è¯æ˜å·¥å…·éœ€è¦èŠ±è´¹æ—¶é—´ã€‚\n"
"ç»è¿‡æµ‹è¯•å‘ç°ï¼Œé‚£äº›é˜…è¯»äº†æœ¬å¸®åŠ©æŒ‡å—çš„ç©å®¶èƒ½å¤Ÿæ›´å¥½åœ°äº«å—æœ¬æ¸¸æˆå¹¶ä»ä¸­å—ç›Šã€‚\n"
"\n"
"å¼€å§‹æ¸¸æˆï¼Œè¯·ç‚¹å‡»â€œæ•™ç¨‹ä¸–ç•Œâ€ã€‚\n"
"\n"
"è¯·æ³¨æ„ï¼šè¿™æ˜¯åŸºäºå…¨æ–° Lean 4 å¼€å‘çš„æ¸¸æˆç‰ˆæœ¬ï¼Œæ–°å¢äº†è®¸å¤šæ—§ç‰ˆ Lean 3 ä¸­æœªåŒ…å«çš„ä¸–ç•Œã€‚é«˜çº§ä¹˜æ³•ä¸–ç•Œçš„æ–°ç‰ˆ"
"æœ¬æ­£åœ¨å¼€å‘ä¸­ï¼Œå…¶ä»–æ–°ä¸–ç•Œå¦‚ç´ æ•°ä¸–ç•Œç­‰å°†äº2023å¹´10æœˆè‡³11æœˆé™†ç»­æ¨å‡ºã€‚\n"
"\n"
"## æ›´å¤šä¿¡æ¯\n"
"\n"
"è¯·ç‚¹å‡»å±å¹•å³ä¸Šè§’çš„â€œâ˜°â€ï¼Œé€‰æ‹©â€œæ¸¸æˆä¿¡æ¯â€ï¼Œè¿™é‡Œæä¾›äº†èµ„æºé“¾æ¥ä»¥åŠå¦‚ä½•ä¸ Lean ç¤¾åŒºäº’åŠ¨çš„æ–¹æ³•ã€‚"

#: Game
msgid ""
"*Game version: 4.2*\n"
"\n"
"*Recent additions: Inequality world, algorithm world*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Creators:** Kevin Buzzard, Jon Eugster\n"
"* **Original Lean3-version:** Kevin Buzzard, Mohammad Pedramfar\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **Additional levels:** Sian Carey, Ivan Farabella, Archie Browne.\n"
"* **Additional thanks:** All the student beta testers, all the schools\n"
"who invited Kevin to speak, and all the schoolkids who asked him questions\n"
"about the material.\n"
"\n"
"## Resources\n"
"\n"
"* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n"
"* [Original Lean3 version](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/) (no "
"longer maintained)\n"
"\n"
"## Problems?\n"
"\n"
"Please ask any questions about this game in the\n"
"[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\n"
"the stream \"New Members\". The community will happily help. Note that\n"
"the Lean Zulip chat is a professional research forum.\n"
"Please use your full real name there, stay on topic, and be nice. If you're\n"
"looking for somewhere less formal (e.g. you want to post natural number\n"
"game memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternatively, if you experience issues / bugs you can also open github issues:\n"
"\n"
"* For issues with the game engine, please open an\n"
"[issue at the lean4game](https://github.com/leanprover-community/lean4game/issues) repo.\n"
"* For issues about the game's content, please open an\n"
"[issue at the NNG](https://github.com/hhu-adam/NNG4/issues) repo."
msgstr ""
"*æ¸¸æˆç‰ˆæœ¬ï¼š4.2*\n"
"\n"
"*æœ€è¿‘æ–°å¢ï¼šä¸ç­‰å¼ä¸–ç•Œï¼Œç®—æ³•ä¸–ç•Œ*\n"
"\n"
"## è¿›åº¦ä¿å­˜\n"
"\n"
"æ¸¸æˆä¼šå°†ä½ çš„è¿›åº¦å­˜å‚¨åœ¨æœ¬åœ°æµè§ˆå™¨å­˜å‚¨ä¸­ã€‚\n"
"å¦‚æœä½ åˆ é™¤å®ƒï¼Œä½ çš„è¿›åº¦å°†ä¼šä¸¢å¤±ï¼\n"
"\n"
"è­¦å‘Šï¼šåœ¨å¤§å¤šæ•°æµè§ˆå™¨ä¸­ï¼Œåˆ é™¤ cookie ä¹Ÿä¼šæ¸…é™¤æœ¬åœ°å­˜å‚¨ï¼ˆæˆ–â€œæœ¬åœ°ç½‘ç«™æ•°æ®â€ï¼‰ã€‚ç¡®ä¿é¦–å…ˆä¸‹è½½ä½ çš„æ¸¸æˆè¿›"
"åº¦ï¼\n"
"\n"
"## è‡´è°¢\n"
"\n"
"* **åˆ›å»ºè€…ï¼š** Kevin Buzzard, Jon Eugster\n"
"* **åŸå§‹ Lean3 ç‰ˆæœ¬ï¼š** Kevin Buzzard, Mohammad Pedramfar\n"
"* **æ¸¸æˆå¼•æ“ï¼š** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"* **é¢å¤–å…³å¡ï¼š** Sian Carey, Ivan Farabella, Archie Browne.\n"
"* **ç‰¹åˆ«æ„Ÿè°¢ï¼š** æ‰€æœ‰å­¦ç”Ÿæµ‹è¯•è€…ï¼Œæ‰€æœ‰é‚€è¯· Kevin å‘è¡¨æ¼”è®²çš„å­¦æ ¡ï¼Œä»¥åŠå‘ä»–æå‡ºå…³äºææ–™é—®é¢˜çš„æ‰€æœ‰å­¦"
"ç”Ÿã€‚\n"
"\n"
"## èµ„æº\n"
"\n"
"* [Lean Zulip èŠå¤©](https://leanprover.zulipchat.com/) è®ºå›\n"
"* [åŸå§‹ Lean3 ç‰ˆæœ¬](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/)ï¼ˆä¸å†ç»´æŠ¤ï¼‰\n"
"\n"
"## æœ‰é—®é¢˜å—ï¼Ÿ\n"
"\n"
"è¯·åœ¨ [Lean Zulip èŠå¤©](https://leanprover.zulipchat.com/) è®ºå›æå‡ºå…³äºè¿™ä¸ªæ¸¸æˆçš„ä»»ä½•é—®é¢˜ï¼Œä¾‹å¦‚åœ¨ â€œæ–°"
"æˆå‘˜â€ æµä¸­ã€‚ç¤¾åŒºä¼šä¹æ„å¸®å¿™ã€‚è¯·æ³¨æ„ï¼ŒLean Zulip èŠå¤©æ˜¯ä¸€ä¸ªä¸“ä¸šç ”ç©¶è®ºå›ã€‚è¯·ä½¿ç”¨æ‚¨çš„å…¨åï¼Œä¿æŒè¯é¢˜ç›¸å…³ï¼Œ"
"ä¸”å‹å¥½ã€‚å¦‚æœä½ æ­£åœ¨å¯»æ‰¾ä¸€ä¸ªä¸é‚£ä¹ˆæ­£å¼çš„åœ°æ–¹ï¼ˆä¾‹å¦‚ï¼Œä½ æƒ³å‘å¸ƒè‡ªç„¶æ•°æ¸¸æˆçš„è¡¨æƒ…åŒ…ï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥å‰å¾€ [Lean "
"Discord](https://discord.gg/WZ9bs9UCvx)ã€‚\n"
"\n"
"å¦å¤–ï¼Œå¦‚æœä½ é‡åˆ°é—®é¢˜/æ¼æ´ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨ github ä¸Šæå‡ºé—®é¢˜ï¼š\n"
"\n"
"* å¯¹äºæ¸¸æˆå¼•æ“çš„é—®é¢˜ï¼Œè¯·åœ¨ [lean4game](https://github.com/leanprover-community/lean4game/issues) ä»“åº“"
"æå‡ºé—®é¢˜ã€‚\n"
"* å¯¹äºæ¸¸æˆå†…å®¹çš„é—®é¢˜ï¼Œè¯·åœ¨ [NNG](https://github.com/hhu-adam/NNG4/issues) ä»“åº“æå‡ºé—®é¢˜ã€‚"

#: Game
msgid "The classical introduction game for Lean."
msgstr "ç»å…¸çš„Leanå…¥é—¨æ¸¸æˆã€‚"

#: Game
msgid ""
"In this game you recreate the natural numbers $\\mathbb{N}$ from the Peano axioms,\n"
"learning the basics about theorem proving in Lean.\n"
"\n"
"This is a good first introduction to Lean!"
msgstr ""
"åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œä½ å°†æ ¹æ®çš®äºšè¯ºå…¬ç†é‡æ–°æ„å»ºè‡ªç„¶æ•°é›† $\\mathbb{N}$ï¼Œå­¦ä¹ åœ¨ Lean ä¸­è¯æ˜å®šç†çš„åŸºç¡€çŸ¥è¯†ã€‚\n"
"\n"
"è¿™æ˜¯å¯¹ Lean çš„ä¸€ä¸ªå¾ˆå¥½çš„åˆæ­¥ä»‹ç»ï¼"
