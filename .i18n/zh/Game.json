{"â‰¤ World": "â‰¤ ä¸–ç•Œ",
 "â‰ ": "â‰ ",
 "zero_pow_zero": "zero_pow_zero",
 "zero_pow_succ": "zero_pow_succ",
 "zero_ne_succ": "zero_ne_succ",
 "zero_mul": "zero_mul",
 "zero_add": "zero_add",
 "x â‰¤ y or y â‰¤ x": "x â‰¤ y æˆ– y â‰¤ x",
 "x â‰¤ y and y â‰¤ z implies x â‰¤ z": "x â‰¤ y ä¸” y â‰¤ z æ„å‘³ç€ x â‰¤ z",
 "x â‰¤ y and y â‰¤ x implies x = y": "x â‰¤ y ä¸” y â‰¤ x æ„å‘³ç€ x = y",
 "x â‰¤ succ x": "x â‰¤ succ x",
 "x â‰¤ 1": "xâ‰¤1",
 "x â‰¤ 0 â†’ x = 0": "x â‰¤ 0 â†’ x = 0",
 "two_mul": "two_mul",
 "try rewriting `add_zero`.": "å°è¯•é‡å†™ `add_zero`ã€‚",
 "the simplest approach": "æœ€ç®€å•çš„æ–¹æ³•",
 "the rw tactic": "rw ç­–ç•¥",
 "succ_mul": "succ_mul",
 "succ_inj : the successor function is injective": "succ_inj ï¼šåç»§æ•°æ˜¯å•å°„çš„",
 "succ_add": "succ_add",
 "succ x â‰¤ succ y â†’ x â‰¤ y": "succ x â‰¤ succ y â†’ x â‰¤ y",
 "rewriting backwards": "é€†å‘é‡å†™",
 "pred": "pred",
 "pow_two": "pow_two",
 "pow_pow": "pow_pow",
 "pow_one": "pow_one",
 "pow_add": "pow_add",
 "one_pow": "one_pow",
 "one_mul": "one_mul",
 "one_le_of_ne_zero": "one_le_of_ne_zero",
 "mul_right_eq_self": "mul_right_eq_self",
 "mul_right_eq_one": "mul_right_eq_one",
 "mul_pow": "mul_pow",
 "mul_one": "mul_one",
 "mul_ne_zero": "mul_ne_zero",
 "mul_left_ne_zero": "mul_left_ne_zero",
 "mul_left_cancel": "mul_left_cancel",
 "mul_le_mul_right": "mul_le_mul_right",
 "mul_eq_zero": "mul_eq_zero",
 "mul_comm": "mul_comm",
 "mul_assoc": "mul_assoc",
 "mul_add": "mul_add",
 "making life simple": "è®©ç”Ÿæ´»å˜å¾—ç®€å•",
 "making life easier": "è®©ç”Ÿæ´»æ›´è½»æ¾",
 "level completed! ğŸ‰": "å®Œæˆå…³å¡ï¼ğŸ‰",
 "level completed with warningsâ€¦ ğŸ­": "å®Œæˆå…³å¡ï¼ğŸ‰ï¼ˆæœ‰è­¦å‘Šï¼‰",
 "le_two": "le_two",
 "le_mul_right": "le_mul_right",
 "is_zero": "is_zero",
 "intro practice": "ç»ƒä¹  `intro` ç­–ç•¥",
 "intro": "intro",
 "intermediate goal solved! ğŸ‰": "ä¸­é—´ç›®æ ‡è¯æ˜ï¼ğŸ‰",
 "eq_succ_of_ne_zero": "eq_succ_of_ne_zero",
 "decide again": "è¿˜æ˜¯`decide`",
 "decide": "decide",
 "add_succ": "add_succ",
 "add_sq": "add_sq",
 "add_right_eq_zero": "add_right_eq_zero",
 "add_right_eq_self": "add_right_eq_self",
 "add_right_comm": "add_right_comm",
 "add_right_cancel": "add_right_cancel",
 "add_mul": "add_mul",
 "add_left_eq_zero": "add_left_eq_zero",
 "add_left_eq_self": "add_left_eq_self",
 "add_left_comm": "add_left_comm",
 "add_left_cancel": "add_left_cancel",
 "add_comm (level boss)": "add_commï¼ˆå…³å¡Bossï¼‰",
 "add_assoc (associativity of addition)": "add_assocï¼ˆåŠ æ³•ç»“åˆå¾‹ï¼‰",
 "`â„•` is the natural numbers, just called \\\"numbers\\\" in this game. It's\ndefined via two rules:\n\n* `0 : â„•` (zero is a number)\n* `succ (n : â„•) : â„•` (the successor of a number is a number)\n\n## Game Implementation\n\n*The game uses its own copy of the natural numbers, called `MyNat` with notation `â„•`.\nIt is distinct from the Lean natural numbers `Nat`, which should hopefully\nnever leak into the natural number game.*":
 "`â„•` æ˜¯è‡ªç„¶æ•°ï¼Œåœ¨è¿™ä¸ªæ¸¸æˆä¸­ç®€ç§°ä¸ºâ€œæ•°å­—â€ã€‚å®ƒé€šè¿‡ä¸¤æ¡è§„åˆ™å®šä¹‰ï¼š\n\n* `0 : â„•`ï¼ˆé›¶æ˜¯è‡ªç„¶æ•°ï¼‰\n* `succ (n : â„•) : â„•`ï¼ˆè‡ªç„¶æ•°çš„åç»§æ•°æ˜¯è‡ªç„¶æ•°ï¼‰\n\n## æ¸¸æˆå®ç°\n\n*æ¸¸æˆä½¿ç”¨è‡ªå·±é‡æ–°å®šä¹‰çš„è‡ªç„¶æ•°ï¼Œç§°ä¸º `MyNat`ï¼Œæ ‡è®°ä¸º `â„•`ã€‚å®ƒä¸åŒäº Lean è‡ªç„¶æ•° `Nat`ï¼Œåè€…ä¸åº”æ³„éœ²åˆ°è‡ªç„¶æ•°æ¸¸æˆä¸­ã€‚*",
 "`zero_ne_succ n` is the proof that `0 â‰  succ n`.\n\nIn Lean, `a â‰  b` is *defined to mean* `a = b â†’ False`. Hence\n`zero_ne_succ n` is really a proof of `0 = succ n â†’ False`.\nHere `False` is a generic false statement. This means that\nyou can `apply zero_ne_succ at h` if `h` is a proof of `0 = succ n`.":
 "`zero_ne_succ n` æ˜¯ `0 â‰  succ n` çš„è¯æ˜ã€‚\n\nåœ¨ Lean ä¸­ï¼Œ`a â‰  b` *è¢«å®šä¹‰ä¸º* `a = b â†’ False`ã€‚\nå› æ­¤ï¼Œ`zero_ne_succ n` å®é™…ä¸Šæ˜¯ `0 = succ n â†’ False` çš„è¯æ˜ã€‚\nè¿™é‡Œçš„ `False` æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡å‘½é¢˜ã€‚è¿™æ„å‘³ç€å¦‚æœ `h` æ˜¯ `0 = succ n` çš„è¯æ˜ï¼Œä½ å¯ä»¥ `apply zero_ne_succ at h`ã€‚",
 "`zero_ne_one` is a proof of `0 â‰  1`.": "`zero_ne_one` æ˜¯ `0 â‰  1` çš„è¯æ˜ã€‚",
 "`zero_mul x` is the proof that `0 * x = 0`.\n\nNote: `zero_mul` is a `simp` lemma.":
 "`zero_mul x` æ˜¯ `0 * x = 0` çš„è¯æ˜ã€‚\n\næ³¨æ„ï¼š`zero_mul` æ˜¯ä¸€ä¸ª `simp` å¼•ç†ã€‚",
 "`zero_le x` is a proof that `0 â‰¤ x`.": "`zero_le x` æ˜¯ `0 â‰¤ x` çš„è¯æ˜ã€‚",
 "`zero_add x` is the proof of `0 + x = x`.\n\n`zero_add` is a `simp` lemma, because replacing `0 + x` by `x`\nis almost always what you want to do if you're simplifying an expression.":
 "`zero_add x` æ˜¯ `0 + x = x` çš„è¯æ˜ã€‚\n\n`zero_add` æ˜¯ä¸€ä¸ªæœ‰ `simp` æ ‡è®°çš„å¼•ç†ï¼Œå› ä¸ºå¦‚æœä½ æ­£åœ¨ç®€åŒ–ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå‡ ä¹æ€»æ˜¯æƒ³è¦å°† `0 + x` æ›¿æ¢ä¸º `x`ã€‚",
 "`xyzzy` is an ancient magic spell, believed to be the origin of the\nmodern word `sorry`. The game won't complain - or notice - if you\nprove anything with `xyzzy`.":
 "`xyzzy` æ˜¯ä¸€ä¸ªå¤è€çš„é­”æ³•å’’è¯­ï¼Œè¢«è®¤ä¸ºæ˜¯ç°ä»£è¯æ±‡ `sorry` çš„èµ·æºã€‚æ¸¸æˆä¸ä¼šå‘ç°â€”â€”æˆ–è€…æ³¨æ„åˆ°ä½ ç”¨ `xyzzy` è¯æ˜ä»»ä½•ä¸œè¥¿ã€‚",
 "`two_mul m` is the proof that `2 * m = m + m`.":
 "`two_mul m` æ˜¯ `2 * m = m + m` çš„è¯æ˜ã€‚",
 "`two_eq_succ_one` is a proof of `2 = succ 1`.":
 "`two_eq_succ_one` æ˜¯ `2 = succ 1` çš„è¯æ˜ã€‚",
 "`three_eq_succ_two` is a proof of `3 = succ 2`.":
 "`three_eq_succ_two` æ˜¯ `3 = succ 2` çš„è¯æ˜ã€‚",
 "`tauto` is good enough to solve this goal.": "`tauto` è¶³ä»¥è¯æ˜è¿™ä¸€ç›®æ ‡ã€‚",
 "`succ_ne_zero a` is a proof of `succ a â‰  0`.":
 "`succ_ne_zero a` æ˜¯ `succ a â‰  0` çš„è¯æ˜ã€‚",
 "`succ_ne_succ m n` is the proof that `m â‰  n â†’ succ m â‰  succ n`.":
 "`succ_ne_succ m n` æ˜¯ `m â‰  n â†’ succ m â‰  succ n` çš„è¯æ˜ã€‚",
 "`succ_mul a b` is the proof that `succ a * b = a * b + b`.\n\nIt could be deduced from `mul_succ` and `mul_comm`, however this argument\nwould be circular because the proof of `mul_comm` uses `mul_succ`.":
 "`succ_mul a b` æ˜¯ `succ a * b = a * b + b` çš„è¯æ˜ã€‚\n\nå¯ä»¥ä» `mul_succ` å’Œ `mul_comm` æ¨å¯¼å‡ºæ¥ï¼Œä½†æ˜¯è¿™ä¸ªæ˜¯å¾ªç¯è®ºè¯ï¼Œ\nå› ä¸º `mul_comm` çš„è¯æ˜ä½¿ç”¨äº† `mul_succ`ã€‚",
 "`succ_le_succ x y` is a proof that if `succ x â‰¤ succ y` then `x â‰¤ y`.":
 "`succ_le_succ x y` æ˜¯å¦‚æœ `succ x â‰¤ succ y` é‚£ä¹ˆ `x â‰¤ y` çš„è¯æ˜ã€‚",
 "`succ_eq_add_one n` is the proof that `succ n = n + 1`.":
 "`succ_eq_add_one n` æ˜¯ `succ n = n + 1` çš„è¯æ˜ã€‚",
 "`succ_add a b` is a proof that `succ a + b = succ (a + b)`.":
 "`succ_add a b` æ˜¯ `succ a + b = succ (a + b)` çš„è¯æ˜ã€‚",
 "`rw [one_eq_succ_zero]` will do this.": "`rw [one_eq_succ_zero]` èƒ½è¿™æ ·åšã€‚",
 "`rw [add_zero]` will change `b + 0` into `b`.":
 "`rw [add_zero]` ä¼šæŠŠ `b + 0` æ”¹ä¸º `b`ã€‚",
 "`rw [add_comm b d]`.": "`rw [add_comm b d]`ã€‚",
 "`pred_succ n` is a proof of `pred (succ n) = n`.":
 "`pred_succ n` æ˜¯ `pred (succ n) = n` çš„è¯æ˜ã€‚",
 "`pow_zero a : a ^ 0 = 1` is one of the two axioms\ndefining exponentiation in this game.":
 "`pow_zero a : a ^ 0 = 1` æ˜¯ä¸¤ä¸ªå…¬ç†ä¹‹ä¸€\nåœ¨è¿™ä¸ªæ¸¸æˆä¸­å®šä¹‰æŒ‡æ•°ã€‚",
 "`pow_two a` says that `a ^ 2 = a * a`.": "`pow_two a` ä»£è¡¨äº† `a ^ 2 = a * a`ã€‚",
 "`pow_succ a b : a ^ (succ b) = a ^ b * a` is one of the\ntwo axioms defining exponentiation in this game.":
 "`pow_succ a b : a ^ (succ b) = a ^ b * a` æ˜¯å®šä¹‰è¿™ä¸ªæ¸¸æˆä¸­å¹‚çš„ä¸¤ä¸ªå…¬ç†ä¸­çš„ä¸€ä¸ªã€‚",
 "`pow_pow a m n` is a proof that $(a^m)^n=a^{mn}.$":
 "`pow_pow a m n` æ˜¯ $(a^m)^n=a^{mn}$ çš„è¯æ˜ã€‚",
 "`pow_one a` says that `a ^ 1 = a`.\n\nNote that this is not quite true by definition: `a ^ 1` is\ndefined to be `a ^ 0 * a` so it's `1 * a`, and to prove\nthat this is equal to `a` you need to use induction somewhere.":
 "`pow_one a` è¡¨ç¤º `a ^ 1 = a`ã€‚\n\nè¯·æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯å®Œå…¨æ ¹æ®å®šä¹‰æ¥çš„ï¼š`a ^ 1` è¢«å®šä¹‰ä¸º `a ^ 0 * a`ï¼Œæ‰€ä»¥å®ƒæ˜¯ `1 * a`ï¼Œè¦è¯æ˜è¿™ç­‰äº `a`ï¼Œä½ éœ€è¦åœ¨æŸå¤„ä½¿ç”¨æ•°å­¦å½’çº³ã€‚",
 "`pow_add a m n` is a proof that $a^{m+n}=a^ma^n.$":
 "`pow_add a m n` æ˜¯ $a^{m+n}=a^ma^n$ çš„è¯æ˜ã€‚",
 "`one_pow n` is a proof that $1^n=1$.": "`one_pow n` æ˜¯ $1^n=1$ çš„è¯æ˜ã€‚",
 "`one_ne_zero` is a proof that `1 â‰  0`.": "`one_ne_zero` æ˜¯ `1 â‰  0` çš„è¯æ˜ã€‚",
 "`one_mul m` is the proof `1 * m = m`.": "`one_mul m` æ˜¯è¯æ˜ `1 * m = m`ã€‚",
 "`one_le_of_ne_zero a` is a proof that `a â‰  0 â†’ 1 â‰¤ a`.":
 "`one_le_of_ne_zero a` æ˜¯ `aâ‰ 0 â†’ 1â‰¤a` çš„è¯æ˜ã€‚",
 "`one_eq_succ_zero` is a proof of `1 = succ 0`.\"":
 "`one_eq_succ_zero` æ˜¯ `1 = succ 0`çš„è¯æ˜ã€‚",
 "`nth_rewrite 2 [two_eq_succ_one]` is I think quicker than `rw [two_eq_succ_one]`.":
 "æˆ‘è®¤ä¸º `nth_rewrite 2 [two_eq_succ_one]` æ¯” `rw [two_eq_succ_one]` æ›´å¿«ã€‚",
 "`mul_zero m` is the proof that `m * 0 = 0`.":
 "`mul_zero m` æ˜¯ `m * 0 = 0` çš„è¯æ˜ã€‚",
 "`mul_succ a b` is the proof that `a * succ b = a * b + a`.":
 "`mul_succ a b` æ˜¯ `a * succ b = a * b + a` çš„è¯æ˜ã€‚",
 "`mul_right_eq_self a b` is a proof that if `a â‰  0` and `a * b = a` then `b = 1`.":
 "`mul_right_eq_self a b` æ˜¯å‘½é¢˜å¦‚æœ `a â‰  0` ä¸” `a * b = a` é‚£ä¹ˆ `b = 1` çš„è¯æ˜ã€‚",
 "`mul_right_eq_one a b` is a proof that `a * b = 1 â†’ a = 1`.":
 "`mul_right_eq_one a b`è¯æ˜äº†`a * b = 1 â†’ a = 1`ã€‚",
 "`mul_pow a b n` is a proof that $(ab)^n=a^nb^n.$":
 "`mul_pow a b n` æ˜¯ $(ab)^n=a^nb^n.$ çš„è¯æ˜",
 "`mul_one m` is the proof that `m * 1 = m`.": "`mul_one m` æ˜¯ `m * 1 = m` çš„è¯æ˜ã€‚",
 "`mul_ne_zero a b` is a proof that if `a â‰  0` and `b â‰  0` then `a * b â‰  0`.":
 "`mul_ne_zero a b` æ˜¯å¦‚æœ `a â‰  0` ä¸” `b â‰  0`ï¼Œé‚£ä¹ˆ `a * b â‰  0`è¯æ˜ã€‚",
 "`mul_left_ne_zero a b` is a proof that `a * b â‰  0 â†’ b â‰  0`.":
 "`mul_left_ne_zero a b` æ˜¯`a * b â‰  0 â†’ b â‰  0` çš„è¯æ˜ã€‚",
 "`mul_left_cancel a b c` is a proof that if `a â‰  0` and `a * b = a * c` then `b = c`.":
 "`mul_left_cancel a b c` è¯æ˜äº†å¦‚æœ `a â‰  0` ä¸” `a * b = a * c` åˆ™ `b = c` ã€‚",
 "`mul_le_mul_right a b t` is a proof that `a â‰¤ b â†’ a * t â‰¤ b * t`.":
 "`mul_le_mul_right a b t` æ˜¯ `a â‰¤ b â†’ a * t â‰¤ b * t` çš„è¯æ˜ã€‚",
 "`mul_eq_zero a b` is a proof that if `a * b = 0` then `a = 0` or `b = 0`.":
 "`mul_eq_zero a b` è¯æ˜å¦‚æœ `a * b = 0` åˆ™ `a = 0` æˆ– `b = 0`ã€‚",
 "`mul_comm` is the proof that multiplication is commutative. More precisely,\n`mul_comm a b` is the proof that `a * b = b * a`.":
 "`mul_comm` æ˜¯ä¹˜æ³•å¯äº¤æ¢çš„è¯æ˜ã€‚æ›´ç¡®åˆ‡åœ°è¯´ï¼Œ\n`mul_comm a b` æ˜¯ `a * b = b * a` çš„è¯æ˜ã€‚",
 "`mul_assoc a b c` is a proof that `(a * b) * c = a * (b * c)`.\n\nNote that when Lean says `a * b * c` it means `(a * b) * c`.\n\nNote that `(a * b) * c = a * (b * c)` cannot be proved by \\\"pure thought\\\":\nfor example subtraction is not associative, as `(6 - 2) - 1` is not\nequal to `6 - (2 - 1)`.":
 "`mul_assoc a b c` æ˜¯ `(a * b) * c = a * (b * c)` çš„è¯æ˜ã€‚\n\nè¯·æ³¨æ„ï¼Œå½“ Lean è¡¨ç¤º `a * b * c` æ—¶ï¼Œå®ƒçš„æ„æ€æ˜¯ `(a * b) * c`ã€‚\n\nè¯·æ³¨æ„ï¼Œ`(a * b) * c = a * (b * c)` ä¸èƒ½ä»…å‡­â€œç©ºæƒ³â€æ¥è¯æ˜ï¼šä¾‹å¦‚ï¼Œå‡æ³•ä¸æ˜¯ç»“åˆçš„ï¼Œå› ä¸º `(6 - 2) - 1` ä¸ç­‰äº `6 - (2 - 1)`ã€‚",
 "`le_zero x` is a proof of the implication `x â‰¤ 0 â†’ x = 0`.":
 "`le_zero x` æ˜¯ä¸€ä¸ªè•´å«å¼ `x â‰¤ 0 â†’ x = 0` çš„è¯æ˜ã€‚",
 "`le_zero x` is a proof of `x â‰¤ 0 â†’ x = 0`.":
 "`le_zero x` æ˜¯ `x â‰¤ 0 â†’ x = 0` çš„è¯æ˜ã€‚",
 "`le_two x` is a proof that if `x â‰¤ 2` then `x = 0` or `x = 1` or `x = 2`.":
 "`le_two x` è¯æ˜äº†å¦‚æœ `x â‰¤ 2` åˆ™ `x = 0` æˆ– `x = 1` æˆ– `x = 2`ã€‚",
 "`le_trans x y z` is a proof that if `x â‰¤ y` and `y â‰¤ z` then `x â‰¤ z`.\nMore precisely, it is a proof that `x â‰¤ y â†’ (y â‰¤ z â†’ x â‰¤ z)`. In words,\nIf $x \\le y$ then (pause) if $y \\le z$ then $x \\le z$.\n\n## A note on associativity\n\nIn Lean, `a + b + c` means `(a + b) + c`, because `+` is left associative. However\n`â†’` is right associative. This means that `x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z` in Lean means\nexactly that `â‰¤` is transitive. This is different to how mathematicians use\n$P \\implies Q \\implies R$; for them, this usually means that $P \\implies Q$\nand $Q \\implies R$.":
 "`le_trans x y z` è¯æ˜äº†å¦‚æœ `x â‰¤ y` å’Œ `y â‰¤ z` é‚£ä¹ˆ `x â‰¤ z`ã€‚\næ›´ç¡®åˆ‡åœ°è¯´ï¼Œå®ƒæ˜¯ `x â‰¤ y â†’ (y â‰¤ z â†’ x â‰¤ z)` çš„è¯æ˜ã€‚æ¢å¥è¯è¯´\nIf $x \\le y$ then (pause) if $y \\le z$ then $x \\le z$.\n\n## å…³äºå…³è”æ€§çš„è¯´æ˜\n\nåœ¨ Lean ä¸­ï¼Œ`a + b + c` è¡¨ç¤º `(a + b) + c`ï¼Œå› ä¸º `+` æ˜¯å·¦å…³è”ã€‚ä½†æ˜¯\n`â†’` æ˜¯å³å…³è”å¼ã€‚è¿™æ„å‘³ç€Leanä¸­çš„ `x â‰¤ y â†’ y â‰¤ z â†’ x â‰¤ z` è¡¨ç¤º\n`â‰¤` æ˜¯ä¼ é€’å¼çš„ã€‚è¿™ä¸æ•°å­¦å®¶ä½¿ç”¨\n$P\\implies Q\\implies R$ çš„ç”¨æ³•ä¸åŒï¼›å¯¹ä»–ä»¬æ¥è¯´ï¼Œè¿™é€šå¸¸æ„å‘³ç€ $P\\implies Q$\nå’Œ $Q\\implies R$ã€‚",
 "`le_total x y` is a proof that `x â‰¤ y` or `y â‰¤ x`.":
 "`le_total x y` æ˜¯ `x â‰¤ y` æˆ– `y â‰¤ x` çš„è¯æ˜ã€‚",
 "`le_succ_self x` is a proof that `x â‰¤ succ x`.":
 "`le_succ_self x` æ˜¯ `x â‰¤ succ x` çš„è¯æ˜ã€‚",
 "`le_refl x` is a proof of `x â‰¤ x`.\n\nThe reason for the name is that this lemma is \"reflexivity of $\\le$\"":
 "`le_refl x` æ˜¯ `x â‰¤ x` çš„è¯æ˜ã€‚\n\nè¿™ä¸ªå¼•ç†æ˜¯ â€œ$\\le$ çš„è‡ªåæ€§â€ å› æ­¤è¿™ä¹ˆå‘½å ã€‚",
 "`le_one x` is a proof that if `x â‰¤ 1` then `x = 0` or `x = 1`.":
 "`le_one x` æ˜¯â€œå¦‚æœ `x â‰¤ 1` é‚£ä¹ˆ `x = 0` æˆ– `x = 1` â€çš„è¯æ˜ã€‚",
 "`le_mul_right a b` is a proof that `a * b â‰  0 â†’ a â‰¤ a * b`.\n\nIt's one way of saying that a divisor of a positive number\nhas to be at most that number.":
 "`le_mul_right a b` æ˜¯ `a * b â‰  0 â†’ a â‰¤ a * b` çš„è¯æ˜ã€‚\n\nè¿™æ˜¯è¡¨è¾¾ä¸€ä¸ªæ­£æ•°çš„é™¤æ•°ä¸ä¼šå¤§äºè¿™ä¸ªæ•°çš„ä¸€ç§æ–¹å¼ã€‚",
 "`le_antisymm x y` is a proof that if `x â‰¤ y` and `y â‰¤ x` then `x = y`.":
 "`le_antisymm x y` æ˜¯å¦‚æœ `x â‰¤ y` å’Œ `y â‰¤ x` åˆ™ `x = y` çš„è¯æ˜ã€‚",
 "`is_zero_zero` is a proof of `is_zero 0 = True`.":
 "`is_zero_zero` æ˜¯ `is_zero 0 = True` çš„è¯æ˜ã€‚",
 "`is_zero_succ a` is a proof of `is_zero (succ a) = False`.":
 "`is_zero_succ a` æ˜¯ `is_zero (succ a) = False` çš„è¯æ˜ã€‚",
 "`four_eq_succ_three` is a proof of `4 = succ 3`.":
 "`four_eq_succ_three` æ˜¯ `4 = succ 3` çš„è¯æ˜ã€‚",
 "`exact` practice.": "`exact` ç»ƒä¹ ã€‚",
 "`eq_succ_of_ne_zero a` is a proof that `a â‰  0 â†’ âˆƒ n, a = succ n`.":
 "`eq_succ_of_ne_zero a` æ˜¯ `aâ‰ 0 â†’ âˆƒ n, a = succ n` çš„è¯æ˜ã€‚",
 "`add_zero c` is a proof of `c + 0 = c` so that was what got rewritten.\nYou can now change `b + 0` to `b` with `rw [add_zero]` or `rw [add_zero b]`. You\ncan usually stick to `rw [add_zero]` unless you need real precision.":
 "`add_zero c` æ˜¯ `c + 0 = c` çš„è¯æ˜ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥æ”¹å†™ç›®æ ‡äº†ã€‚ç°åœ¨ä½ å¯ä»¥ç”¨ `rw [add_zero]` æˆ– `rw [add_zero b]` æŠŠ `b + 0` æ”¹æˆ `b`ã€‚æ‚¨é€šå¸¸å¯ä»¥ä½¿ç”¨ `rw [add_zero]`ï¼Œé™¤éä½ éœ€è¦ç²¾å‡†æ§åˆ¶æ”¹å†™çš„å†…å®¹ã€‚",
 "`add_zero a` is a proof that `a + 0 = a`.\n\n## Summary\n\n`add_zero` is really a function, which\neats a number, and returns a proof of a theorem\nabout that number. For example `add_zero 37` is\na proof that `37 + 0 = 37`.\n\nThe `rw` tactic will accept `rw [add_zero]`\nand will try to figure out which number you omitted\nto input.\n\n## Details\n\nA mathematician sometimes thinks of `add_zero`\nas \\\"one thing\\\", namely a proof of $\\forall n âˆˆ â„•, n + 0 = n$.\nThis is just another way of saying that it's a function which\ncan eat any number n and will return a proof that `n + 0 = n`.":
 "`add_zero a` æ˜¯ `a + 0 = a` çš„è¯æ˜ã€‚\n\n## å°ç»“\n\n`add_zero` å®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªæ•°å­—ï¼Œå¹¶è¿”å›å…³äºé‚£ä¸ªæ•°å­—çš„å®šç†çš„è¯æ˜ã€‚ä¾‹å¦‚ï¼Œ`add_zero 37` æ˜¯ `37 + 0 = 37` çš„è¯æ˜ã€‚\n\n`rw` ç­–ç•¥ä¼šæ¥å— `rw [add_zero]` å¹¶å°è¯•æ¨æ–­å‡ºä½ çœç•¥è¾“å…¥çš„æ•°å­—ã€‚\n\n## ç»†èŠ‚\n\næ•°å­¦å®¶æœ‰æ—¶å°† `add_zero` è§†ä¸ºâ€œä¸€ä¸ªä¸œè¥¿â€ï¼Œå³ $âˆ€ n âˆˆ â„•, n + 0 = n$ çš„è¯æ˜ã€‚è¿™åªæ˜¯å¦ä¸€ç§è¯´æ³•ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå¯ä»¥æ¥å—ä»»ä½•æ•°å­— n å¹¶è¿”å› `n + 0 = n` çš„è¯æ˜ã€‚",
 "`add_succ a b` is the proof of `a + succ b = succ (a + b)`.":
 "`add_succ a b` æ˜¯ `a + succ b = succ (a + b)` çš„è¯æ˜ã€‚",
 "`add_sq a b` is the statement that $(a+b)^2=a^2+b^2+2ab.$":
 "`add_sq a b` æ˜¯ $(a+b)^2=a^2+b^2+2ab$ çš„è¯æ˜ã€‚",
 "`add_right_eq_self x y` is the theorem that $x + y = x\\implies y=0.$\nTwo ways to do it spring to mind; I'll mention them when you've solved it.":
 "`add_right_eq_self x y` æ˜¯ $x + y = x\\implies y=0.$ çš„å®šç†ã€‚\næˆ‘æƒ³åˆ°äº†ä¸¤ç§æ–¹æ³•ï¼Œç­‰ä½ è§£å‡ºæ¥äº†æˆ‘å†æã€‚",
 "`add_right_eq_self x y` is the theorem that $x + y = x \\implies y=0.$":
 "`add_right_eq_self x y` æ˜¯è¡¨ç¤º $x + y = x\\implies y=0$ çš„å®šç†ã€‚",
 "`add_right_comm a b c` is a proof that `(a + b) + c = (a + c) + b`\n\nIn Lean, `a + b + c` means `(a + b) + c`, so this result gets displayed\nas `a + b + c = a + c + b`.":
 "`add_right_comm a b c` æ˜¯ `(a + b) + c = (a + c) + b` çš„è¯æ˜ã€‚\n\nåœ¨ Lean ä¸­ï¼Œ`a + b + c` æ„å‘³ç€ `(a + b) + c`ï¼Œæ‰€ä»¥è¿™ä¸ªç»“æœè¢«æ˜¾ç¤ºä¸º `a + b + c = a + c + b`ã€‚",
 "`add_right_cancel a b n` is the theorem that $a+n=b+n \\implies a=b.$":
 "`add_right_cancel a b n` æ˜¯ $a+n=b+n \\implies a=b$ çš„å®šç†ã€‚",
 "`add_mul` is just as fiddly to prove by induction; but there's a trick\nwhich avoids it. Can you spot it?":
 "ç”¨å½’çº³æ³•è¯æ˜ `add_mul` ä¹Ÿå¾ˆéº»çƒ¦ï¼Œä½†æœ‰ä¸ªå°çªé—¨å¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚\nå¯ä»¥é¿å…è¿™ä¸ªé—®é¢˜ã€‚ä½ èƒ½å‘ç°å—ï¼Ÿ",
 "`add_mul a b c` is a proof that $(a+b)c=ac+bc$.":
 "`add_mul a b c` æ˜¯ $(a+b)c=ac+bc$ çš„è¯æ˜ã€‚",
 "`add_left_eq_self x y` is the theorem that $x + y = y\\implies x=0.$":
 "`add_left_eq_self x y` æ˜¯ $x + y = y\\implies x=0$ çš„å®šç†åå­—ã€‚",
 "`add_left_eq_self x y` is the theorem that $x + y = y \\implies x=0.$":
 "`add_left_eq_self x y` æ˜¯ $x + y = y\\implies x=0$ çš„å®šç†åå­—ã€‚",
 "`add_left_comm a b c` is a proof that `a + (b + c) = b + (a + c)`.":
 "`add_left_comm a b c` æ˜¯ `a + (b + c) = b + (a + c)` çš„è¯æ˜ã€‚",
 "`add_left_cancel a b n` is the theorem that $n+a=n+b\\implies a=b$.\nYou can prove it by induction on `n` or you can deduce it from `add_right_cancel`.":
 "`add_left_cancel a b n` æ˜¯å®šç† $n+a=n+b\\implies a=b$ã€‚ä½ å¯ä»¥é€šè¿‡å¯¹ `n` è¿›è¡Œå½’çº³æ¥è¯æ˜å®ƒï¼Œæˆ–è€…ä½ å¯ä»¥ä» `add_right_cancel` æ¨å¯¼å‡ºå®ƒã€‚",
 "`add_left_cancel a b n` is the theorem that $n+a=n+b \\implies a=b.$":
 "`add_left_cancel a b n` æ˜¯ $n+a=n+b \\implies a=b$ çš„å®šç†åå­—ã€‚",
 "`add_comm x y` is a proof of `x + y = y + x`.":
 "`add_comm x y` æ˜¯ `x + y = y + x` çš„è¯æ˜ã€‚",
 "`add_comm b c` is a proof that `b + c = c + b`. But if your goal\nis `a + b + c = a + c + b` then `rw [add_comm b c]` will not\nwork! Because the goal means `(a + b) + c = (a + c) + b` so there\nis no `b + c` term *directly* in the goal.\n\nUse associativity and commutativity to prove `add_right_comm`.\nYou don't need induction. `add_assoc` moves brackets around,\nand `add_comm` moves variables around.\n\nRemember that you can do more targetted rewrites by\nadding explicit variables as inputs to theorems. For example `rw [add_comm b]`\nwill only do rewrites of the form `b + ? = ? + b`, and `rw [add_comm b c]`\nwill only do rewrites of the form `b + c = c + b`.":
 "`add_comm b c` æ˜¯ä¸€ä¸ª `b + c = c + b` çš„è¯æ˜ã€‚ä½†å¦‚æœæ‚¨çš„ç›®æ ‡æ˜¯ `a + b + c = a + c + b`ï¼Œé‚£ä¹ˆ `rw [add_comm b c]` å°†ä¸èµ·ä½œç”¨ï¼å› ä¸ºç›®æ ‡æ˜¯ `(a + b) + c = (a + c) + b`ï¼Œæ‰€ä»¥ç›®æ ‡ä¸­*ç›´æ¥*æ²¡æœ‰ `b + c` é¡¹ã€‚\n\nä½¿ç”¨ç»“åˆå¾‹å’Œäº¤æ¢å¾‹æ¥è¯æ˜ `add_right_comm`ã€‚æ‚¨ä¸éœ€è¦ä½¿ç”¨å½’çº³æ³•ã€‚`add_assoc` ç§»åŠ¨æ‹¬å·ï¼Œ`add_comm` ç§»åŠ¨å˜é‡ã€‚\n\nè¯·è®°ä½ï¼Œæ‚¨å¯ä»¥é€šè¿‡å°†æ˜¾å¼å˜é‡æ·»åŠ ä¸ºå®šç†çš„è¾“å…¥æ¥è¿›è¡Œæ›´æœ‰é’ˆå¯¹æ€§çš„é‡å†™ã€‚\nä¾‹å¦‚ï¼Œ`rw [add_comm b]` åªä¼šé‡å†™å½¢å¦‚ `b + ? = ? + b` çš„å½¢å¼ï¼Œè€Œ `rw [add_comm b c]` åªä¼šé‡å†™å½¢å¦‚ `b + c = c + b` çš„å½¢å¼ã€‚",
 "`add_assoc a b c` is a proof\nthat `(a + b) + c = a + (b + c)`. Note that in Lean `(a + b) + c` prints\nas `a + b + c`, because the notation for addition is defined to be left\nassociative.":
 "`add_assoc a b c` æ˜¯ä¸€ä¸ª `(a + b) + c = a + (b + c)` çš„è¯æ˜ã€‚\nè¯·æ³¨æ„ï¼Œåœ¨ Lean `(a + b) + c` ä¸­æ˜¾ç¤º\nä¸º `a + b + c`ï¼Œå› ä¸ºåŠ æ³•ç¬¦å·è¢«å®šä¹‰ä¸ºå·¦\nç»“åˆçš„ã€‚",
 "`a â‰¤ b` is *notation* for `âˆƒ c, b = a + c`. This \"backwards E\"\nmeans \"there exists\". So `a â‰¤ b` means that there exists\na number `c` such that `b = a + c`. This definition works\nbecause there are no negative numbers in this game.\n\nTo *prove* an \"exists\" statement, use the `use` tactic.\nLet's see an example.":
 "`a â‰¤ b` æ˜¯ `âˆƒ c, b = a + c` çš„*ç¬¦å·è¡¨ç¤º*ã€‚è¿™ä¸ªâ€œå€’ Eâ€ä»£è¡¨â€œå­˜åœ¨â€ã€‚æ‰€ä»¥ `a â‰¤ b` æ„å‘³ç€å­˜åœ¨ä¸€ä¸ªæ•°å­— `c` ä½¿å¾— `b = a + c`ã€‚è¿™ä¸ªå®šä¹‰æœ‰æ•ˆæ˜¯å› ä¸ºåœ¨è¿™ä¸ªæ¸¸æˆä¸­æ²¡æœ‰è´Ÿæ•°ã€‚\n\nè¦*è¯æ˜*ä¸€ä¸ªâ€œå­˜åœ¨æ€§â€å®šç†ï¼Œå¯ä»¥ä½¿ç”¨ `use` ç­–ç•¥ã€‚\nè®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ã€‚",
 "`a â‰¤ b` is *notation* for `âˆƒ c, b = a + c`.\n\nBecause this game doesn't have negative numbers, this definition\nis mathematically valid.\n\nThis means that if you have a goal of the form `a â‰¤ b` you can\nmake progress with the `use` tactic, and if you have a hypothesis\n`h : a â‰¤ b`, you can make progress with `cases h with c hc`.":
 "`a â‰¤ b` æ˜¯ `âˆƒ c, b = a + c` çš„*ç¬¦å·è¡¨ç¤º*ã€‚\n\nå› ä¸ºè¿™ä¸ªæ¸¸æˆæ²¡æœ‰è´Ÿæ•°ï¼Œè¿™ä¸ªå®šä¹‰åœ¨æ•°å­¦ä¸Šæ˜¯æœ‰æ•ˆçš„ã€‚\n\nè¿™æ„å‘³ç€å¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a â‰¤ b` çš„ç›®æ ‡ï¼Œä½ å¯ä»¥ç”¨ `use` ç­–ç•¥æ¥å–å¾—è¿›å±•ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰¤ b`ï¼Œä½ å¯ä»¥ç”¨ `cases h with c hc` æ¥å–å¾—è¿›å±•ã€‚",
 "`a â‰  b` is *notation* for `(a = b) â†’ False`.\n\nThe reason this is mathematically\nvalid is that if `P` is a true-false statement then `P â†’ False`\nis the logical opposite of `P`. Indeed `True â†’ False` is false,\nand `False â†’ False` is true!\n\nThe upshot of this is that use can treat `a â‰  b` in exactly\nthe same way as you treat any implication `P â†’ Q`. For example,\nif your *goal* is of the form `a â‰  b` then you can make progress\nwith `intro h`, and if you have a hypothesis `h` of the\nform `a â‰  b` then you can `apply h at h1` if `h1` is a proof\nof `a = b`.":
 "`a â‰  b` æ˜¯ç”± `(a = b) â†’ False` å®šä¹‰çš„ ã€‚\n\n  è¿™åœ¨æ•°å­¦ä¸Šåˆæ³•çš„åŸå› æ˜¯ï¼Œå¦‚æœ `P` æ˜¯ä¸€ä¸ªçœŸå‡å‘½é¢˜ï¼Œé‚£ä¹ˆ `P â†’ False`\n  ä¸ `P` çš„é€»è¾‘ç›¸åã€‚ç¡®å® `True â†’ False` æ˜¯å‡çš„ï¼Œ\n  `False â†’ False` æ˜¯çœŸçš„ï¼\n\n  è¿™æ ·åšçš„ç»“æœæ˜¯ï¼Œ\n  å¯ç”¨å¤„ç†ä»»ä½• `P â†’ Q` çš„æ–¹å¼å¤„ç† `a â‰  b`ã€‚ä¾‹å¦‚ï¼Œ\n  å¦‚æœ *ç›®æ ‡* çš„å½¢å¼ä¸º `a â‰  b` é‚£ä¹ˆæ‚¨å¯ä»¥ç”¨ `intro h`å–å¾—è¿›å±•ï¼›\n  å¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  b` é‚£ä¹ˆä½ å¯ä»¥ `apply h at h1` å¦‚æœ `h1` æ˜¯\n  `a = b`çš„å‡è®¾ã€‚",
 "`Pow a b`, with notation `a ^ b`, is the usual\n  exponentiation of natural numbers. Internally it is\n  defined via two axioms:\n\n  * `pow_zero a : a ^ 0 = 1`\n\n  * `pow_succ a b : a ^ succ b = a ^ b * a`\n\nNote in particular that `0 ^ 0 = 1`.":
 "`Pow a b`ï¼Œå…¶ç¬¦å·è¡¨ç¤ºä¸º `a ^ b`ï¼Œæ˜¯è‡ªç„¶æ•°çš„å¸¸è§„æŒ‡æ•°è¿ç®—ã€‚åœ¨å†…éƒ¨ï¼Œå®ƒæ˜¯é€šè¿‡ä¸¤ä¸ªå…¬ç†å®šä¹‰çš„ï¼š\n\n* `pow_zero a : a ^ 0 = 1`\n\n* `pow_succ a b : a ^ succ b = a ^ b * a`\n\nç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ `0 ^ 0 = 1`ã€‚",
 "`Mul a b`, with notation `a * b`, is the usual\n  product of natural numbers. Internally it is\n  via two axioms:\n\n  * `mul_zero a : a * 0 = 0`\n\n  * `mul_succ a b : a * succ b = a * b + a`\n\nOther theorems about naturals, such as `zero_mul`,\nare proved by induction from these two basic theorems.":
 "`Mul a b`ï¼Œå…¶ç¬¦å·è¡¨ç¤ºä¸º `a * b`ï¼Œæ˜¯è‡ªç„¶æ•°çš„å¸¸è§„ä¹˜ç§¯ã€‚å®ƒæ˜¯é€šè¿‡ä¸¤æ¡è§„åˆ™å®šä¹‰çš„ï¼š\n\n* `mul_zero a : a * 0 = 0`\n\n* `mul_succ a b : a * succ b = a * b + a`\n\nå…³äºè‡ªç„¶æ•°çš„å…¶ä»–å®šç†ï¼Œæ¯”å¦‚ `zero_mul`ï¼Œéƒ½æ˜¯é€šè¿‡ä»è¿™ä¸¤ä¸ªåŸºæœ¬å®šç†è¿›è¡Œå½’çº³è¯æ˜å¾—åˆ°çš„ã€‚",
 "`Add a b`, with notation `a + b`, is\nthe usual sum of natural numbers. Internally it is defined\nvia the following two hypotheses:\n\n* `add_zero a : a + 0 = a`\n\n* `add_succ a b : a + succ b = succ (a + b)`\n\nOther theorems about naturals, such as `zero_add a : 0 + a = a`, are proved\nby induction using these two basic theorems.\"":
 "`Add a b`ï¼Œç¬¦å·ä¸º `a + b`ï¼Œæ˜¯\nè‡ªç„¶æ•°ä¹‹å’Œã€‚\né€šè¿‡ä»¥ä¸‹ä¸¤ä¸ªå‡è®¾å®šä¹‰ï¼š\n\n* `add_zero a : a + 0 = a`\n\n* `add_succ a b : a + succ b = succ (a + b)`\n\nå…¶ä»–å…³äºè‡ªç„¶æ•°çš„å®šç†ï¼Œä¾‹å¦‚ `zero_add a : 0 + a = a`ï¼Œä¹Ÿ\né€šè¿‡æ•°å­¦å½’çº³æ³•ä½¿ç”¨è¿™ä¸¤ä¸ªåŸºæœ¬å®šä¹‰è¿›è¡Œè¯æ˜ã€‚",
 "[final boss music]": "ã€æœ€ç»ˆBossèƒŒæ™¯éŸ³ä¹ã€‘",
 "[dramatic music]. Now are you ready to face the first boss of the game?":
 "ã€èƒŒæ™¯éŸ³ä¹ã€‘ç°åœ¨ä½ å‡†å¤‡å¥½é¢å¯¹æ¸¸æˆé‡Œçš„ç¬¬ä¸€ä¸ªbossäº†å—ï¼Ÿ",
 "[boss battle music]\n\nLook in your inventory to see the proofs you have available.\nThese should be enough.":
 "ã€Bossæˆ˜éŸ³ä¹ã€‘\n\næŸ¥çœ‹æ‚¨çš„åº“å­˜ä»¥æŸ¥çœ‹æ‚¨æ‹¥æœ‰çš„å¯ç”¨å®šç†ã€‚\nè¿™äº›åº”è¯¥è¶³å¤Ÿäº†ã€‚",
 "You've now seen all the tactics you need to beat the final boss of the game.\nYou can begin the journey towards this boss by entering Multiplication World.\n\nOr you can go off the beaten track and learn some new tactics in Implication\nWorld. These tactics let you prove more facts about addition, such as\nhow to deduce `a = 0` from `x + a = x`.\n\nClick \"Leave World\" and make your choice.":
 "ä½ ç°åœ¨å·²ç»æŒæ¡äº†å‡»è´¥æ¸¸æˆæœ€ç»ˆ BOSS æ‰€éœ€çš„æ‰€æœ‰ç­–ç•¥ã€‚\nä½ å¯ä»¥è¿›å…¥ä¹˜æ³•ä¸–ç•Œï¼Œå¼€å§‹å¾æœ BOSS çš„å†’é™©ä¹‹æ—…ã€‚\n\næˆ–è€…ï¼Œä½ å¯ä»¥ç¦»å¼€å¸¸è§„è·¯çº¿ï¼Œåœ¨è•´æ¶µä¸–ç•Œä¸­å­¦ä¹ ä¸€äº›æ–°çš„ç­–ç•¥ã€‚\nè¿™äº›ç­–ç•¥å¯ä»¥è®©ä½ è¯æ˜æ›´å¤šå…³äºåŠ æ³•çš„äº‹å®ï¼Œä¾‹å¦‚ä» `x + a = x` æ¨å¯¼ `a = 0`ã€‚\n\nç‚¹å‡»â€œç¦»å¼€ä¸–ç•Œâ€ï¼Œåšå‡ºä½ çš„é€‰æ‹©å§ã€‚",
 "You want to use `add_right_eq_zero`, which you already\nproved, but you'll have to start with `symm at` your hypothesis.":
 "ä½ æƒ³ä½¿ç”¨ `add_right_eq_zero`ï¼Œè¿™æ˜¯ä½ å·²ç»è¯æ˜è¿‡çš„ï¼Œä½†ä½ éœ€è¦ä»å¯¹ä½ çš„å‡è®¾ä½¿ç”¨ `symm at` å¼€å§‹ã€‚",
 "You still don't know which way to go, so do `cases Â«{e}Â» with a`.":
 "ä½ ä»ç„¶ä¸çŸ¥é“è¯¥èµ°å“ªä¸ªåˆ†æ”¯ï¼Œæ‰€ä»¥è¦åš `cases Â«{e}Â» with a`ã€‚",
 "You now know enough tactics to prove `2 + 2 = 4`! Let's begin the journey.":
 "ä½ ç°åœ¨å·²ç»å­¦ä¼šäº†è¶³å¤Ÿçš„ç­–ç•¥æ¥è¯æ˜ `2 + 2 = 4`ï¼è®©æˆ‘ä»¬å¼€å§‹è¿™æ®µæ—…ç¨‹å§ã€‚",
 "You might want to think about whether induction\non `a` or `b` is the best idea.":
 "ä½ å¯èƒ½æƒ³è€ƒè™‘ä¸€ä¸‹ï¼Œå¯¹ `a` è¿˜æ˜¯ `b` è¿›è¡Œå½’çº³è¯æ˜æ‰æ˜¯æœ€å¥½çš„ä¸»æ„ã€‚",
 "You can use `rw [zero_add] at Â«{h}Â»` to rewrite at `Â«{h}Â»` instead\nof at the goal.":
 "ä½ å¯ä»¥ä½¿ç”¨ `rw [zero_add] at Â«{h}Â»` æ¥åœ¨ `Â«{h}Â»` å¤„è¿›è¡Œé‡å†™ï¼Œè€Œä¸æ˜¯åœ¨ç›®æ ‡å¤„è¿›è¡Œã€‚",
 "You can start a proof by induction on `n` by typing:\n`induction n with d hd`.":
 "ä½ å¯ä»¥é€šè¿‡è¾“å…¥ä»¥ä¸‹å†…å®¹æ¥å¼€å§‹å¯¹ `n` è¿›è¡Œå½’çº³è¯æ˜ï¼š\n`induction n with d hd`ã€‚",
 "You can read more about the `decide` tactic by clicking\non it in the top right.":
 "ä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å³ä¸Šè§’çš„ `decide` æ¥äº†è§£æ›´å¤šå…³äº `decide` ç­–ç•¥çš„ä¿¡æ¯ã€‚",
 "You can put a `â†` in front of any theorem provided to `rw` to rewrite\nthe other way around. Look at the docs for `rw` for an explanation. Type `â†` with `\\l`.":
 "ä½ å¯ä»¥åœ¨æä¾›ç»™ `rw` çš„ä»»ä½•å®šç†å‰é¢æ”¾ä¸€ä¸ª `â†` æ¥è¿›è¡Œåå‘é‡å†™ã€‚æŸ¥çœ‹ `rw` çš„æ–‡æ¡£ä»¥è·å¾—è§£é‡Šã€‚ä½¿ç”¨ `\\l` è¾“å…¥ `â†`ã€‚",
 "You can prove $1\\times m=m$ in at least three ways.\nEither by induction, or by using `succ_mul`, or\nby using commutativity. Which do you think is quickest?":
 "æ‚¨å¯ä»¥è‡³å°‘é€šè¿‡ä¸‰ç§æ–¹å¼è¯æ˜ $1\\times m=m$ã€‚\né€šè¿‡å½’çº³æ³•ï¼Œæˆ–ä½¿ç”¨ `succ_mul`ï¼Œæˆ–\né€šè¿‡ä½¿ç”¨äº¤æ¢å¾‹ã€‚ä½ è®¤ä¸ºå“ªä¸ªæœ€å¿«ï¼Ÿ",
 "You can probably take it from here.": "ä½ å¯ä»¥ä»è¿™é‡Œå¼€å§‹ã€‚",
 "You can now finish with `exact h`.": "ç°åœ¨æ‚¨å¯ä»¥ä½¿ç”¨ `exact h` æ¥å®Œæˆè¯æ˜ã€‚",
 "You can now `apply mul_left_cancel at h`":
 "ç°åœ¨æ‚¨å¯ä»¥ `apply mul_left_cancel at h` ã€‚",
 "You can make your own tactics in Lean.\nThis code here\n```\nmacro \"simp_add\" : tactic => `(tactic|(\n  simp only [add_assoc, add_left_comm, add_comm]))\n```\nwas used to create a new tactic `simp_add`, which runs\n`simp only [add_assoc, add_left_comm, add_comm]`.\nTry running `simp_add` to solve this level!":
 "ä½ å¯ä»¥åœ¨ Lean ä¸­åˆ›å»ºè‡ªå·±çš„ç­–ç•¥ã€‚\nè¿™é‡Œçš„ä»£ç \n```\nmacro \"simp_add\" : tactic => `(tactic|(\n  simp only [add_assoc, add_left_comm, add_comm]))\n```\nè¢«ç”¨æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ç­–ç•¥ `simp_add`ï¼Œå®ƒä¼šæ‰§è¡Œ\n`simp only [add_assoc, add_left_comm, add_comm]`ã€‚\nå°è¯•è¿è¡Œ `simp_add` æ¥è§£å†³è¿™ä¸ªå…³å¡ï¼",
 "You can just mimic the previous proof to do this one -- or you can figure out a way\nof using it.":
 "ä½ å¯ä»¥æ¨¡ä»¿ä¹‹å‰çš„è¯æ˜æ¥å®Œæˆè¿™ä¸ªâ€”â€”æˆ–è€…ä½ å¯ä»¥æƒ³å‡ºä¸€ç§æ–¹æ³•\nä½¿ç”¨ä¹‹å‰çš„è¯æ˜ã€‚",
 "You can do induction on any of the three variables. Some choices\nare harder to push through than others. Can you do the inductive step in\n5 rewrites only?":
 "ä½ å¯ä»¥å¯¹ä»»ä½•ä¸‰ä¸ªå˜é‡ä¸­çš„ä»»ä½•ä¸€ä¸ªè¿›è¡Œå½’çº³ã€‚æœ‰äº›é€‰æ‹©æ¯”å…¶ä»–é€‰æ‹©æ›´éš¾ä»¥æ¨è¿›ã€‚ä½ èƒ½ä»…ç”¨5æ¬¡æ”¹å†™å®Œæˆå½’çº³æ­¥éª¤å—ï¼Ÿ",
 "Why did we not just define `succ n` to be `n + 1`? Because we have not\neven *defined* addition yet! We'll do that in the next level.":
 "ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸ç›´æ¥å°† `succ n` å®šä¹‰ä¸º `n + 1`ï¼Ÿå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰\n *å®šä¹‰* åŠ æ³•ï¼æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€å…³åšåˆ°è¿™ä¸€ç‚¹ã€‚",
 "What do you think of this two-liner:\n```\nsymm\nexact zero_ne_one\n```\n\n`exact` doesn't just take hypotheses, it will eat any proof which exists\nin the system.":
 "ä½ å¯¹è¿™ä¸¤è¡Œä»£ç æœ‰ä»€ä¹ˆçœ‹æ³•ï¼Ÿ\n\n```\nsymm\nexact zero_ne_one\n```\n\nè¯·æ³¨æ„ï¼Œ`exact` ä¸ä»…é™äºä½¿ç”¨å‡è®¾ï¼Œå®ƒå¯ä»¥æ¥å—ç³»ç»Ÿä¸­å­˜åœ¨çš„ä»»ä½•è¯æ˜ã€‚",
 "Well done! You now have enough tools to tackle the main boss of this level.":
 "åšå¾—å¥½ï¼ç°åœ¨ä½ æœ‰è¶³å¤Ÿçš„å·¥å…·æ¥å¯¹ä»˜è¿™ä¸ªå…³å¡çš„å¤§Bossäº†ã€‚",
 "Well done!": "åšå¾—å¥½ï¼",
 "Welcome to tutorial world! In this world we learn the basics\nof proving theorems. The boss level of this world\nis the theorem `2 + 2 = 4`.\n\nYou prove theorems by solving puzzles using tools called *tactics*.\nThe aim is to prove the theorem by applying tactics\nin the right order.\n\nLet's learn some basic tactics. Click on \"Start\" below\nto begin your quest.":
 "æ¬¢è¿è¿›å…¥æ•™ç¨‹ä¸–ç•Œï¼åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æŒæ¡è¯æ˜å®šç†çš„åˆæ­¥æŠ€èƒ½ã€‚è¿™ä¸ªä¸–ç•Œä¸­çš„ç»ˆææŒ‘æˆ˜æ˜¯è¯æ˜ `2 + 2 = 4` è¿™ä¸€å®šç†ã€‚\n\nè§£å†³è¿™äº›è°œé¢˜å¹¶è¯æ˜å®šç†çš„è¿‡ç¨‹ä¸­ï¼Œä½ å°†ä½¿ç”¨ä¸€ç§åä¸º*ç­–ç•¥*çš„å¼ºå¤§å·¥å…·ã€‚è¯æ˜å®šç†çš„å…³é”®åœ¨äºå‡†ç¡®åœ°åº”ç”¨è¿™äº›ç­–ç•¥ã€‚\n\nç°åœ¨ï¼Œè®©æˆ‘ä»¬å¼€å§‹å­¦ä¹ ä¸€äº›åŸºæœ¬ç­–ç•¥å§ã€‚è¯·ç‚¹å‡»ä¸‹é¢çš„â€œå¼€å§‹â€æŒ‰é’®ï¼Œå¼€å¯ä½ çš„è¯æ˜ä¹‹æ—…ã€‚",
 "Welcome to Addition World! In this world we'll learn the `induction` tactic.\nThis will enable us to defeat the boss level of this world, namely `x + y = y + x`.\n\nThe tactics `rw`, `rfl` and `induction` are the only tactics you'll need to\nbeat all the levels in Addition World, Multiplication World, and Power World.\nPower World contains the final boss of the game.\n\nThere are plenty more tactics in this game, but you'll only need to know them if you\nwant to explore the game further (for example if you decide to 100%\nthe game).":
 "æ¬¢è¿æ¥åˆ°åŠ æ³•ä¸–ç•Œï¼åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  `induction`ï¼ˆå½’çº³ï¼‰ç­–ç•¥ã€‚è¿™å°†ä½¿æˆ‘ä»¬èƒ½å¤Ÿå‡»è´¥è¿™ä¸ªä¸–ç•Œçš„Bossçº§åˆ«ï¼Œå³ `x + y = y + x`ã€‚\n\nç­–ç•¥ `rw`ï¼ˆé‡å†™ï¼‰ã€`rfl`ï¼ˆåå°„ï¼‰å’Œ `induction`ï¼ˆå½’çº³ï¼‰æ˜¯ä½ åœ¨åŠ æ³•ä¸–ç•Œã€ä¹˜æ³•ä¸–ç•Œå’Œå¹‚ä¸–ç•Œä¸­å‡»è´¥æ‰€æœ‰å…³å¡æ‰€éœ€è¦ç­–ç•¥ã€‚å¹‚ä¸–ç•ŒåŒ…å«äº†æ¸¸æˆçš„æœ€ç»ˆBossã€‚\n\nè¿™ä¸ªæ¸¸æˆä¸­è¿˜æœ‰æ›´å¤šçš„ç­–ç•¥ï¼Œä½†åªæœ‰å½“ä½ æƒ³è¿›ä¸€æ­¥æ¢ç´¢æ¸¸æˆæ—¶ï¼ˆä¾‹å¦‚å¦‚æœä½ å†³å®šå®Œæˆæ¸¸æˆçš„100%ï¼‰æ‰éœ€è¦äº†è§£å®ƒä»¬ã€‚",
 "We've seen `le_zero`, the proof that if `x â‰¤ 0` then `x = 0`.\nNow we'll prove that if `x â‰¤ 1` then `x = 0` or `x = 1`.":
 "æˆ‘ä»¬å·²ç»çœ‹åˆ°äº† `le_zero`ï¼Œè¿™æ˜¯å¦‚æœ `x â‰¤ 0` é‚£ä¹ˆ `x = 0` çš„è¯æ˜ã€‚\nç°åœ¨æˆ‘ä»¬å°†è¯æ˜å¦‚æœ `x â‰¤ 1` é‚£ä¹ˆ `x = 0` æˆ– `x = 1`ã€‚",
 "We've proved that `x â‰¤ 0` implies `x = 0`. The last two levels\nin this world will prove which numbers are `â‰¤ 1` and `â‰¤ 2`.\nThis lemma will be helpful for them.":
 "æˆ‘ä»¬å·²ç»è¯æ˜ `x â‰¤ 0` è•´æ¶µ `x = 0`ã€‚\nåœ¨è¿™ä¸ªä¸–ç•Œçš„æœ€åä¸¤å…³å°†è¯æ˜å“ªäº›æ•°å­—æ˜¯ `â‰¤ 1` å’Œ `â‰¤ 2` çš„ã€‚\nè¿™ä¸ªå¼•ç†å¯¹è¯æ˜å®ƒä»¬å°†æ˜¯æœ‰å¸®åŠ©çš„ã€‚",
 "We've proved that $2+2=4$; in Implication World we'll learn\nhow to prove $2+2\\neq 5$.\n\nIn Addition World we proved *equalities* like $x + y = y + x$.\nIn this second tutorial world we'll learn some new tactics,\nenabling us to prove *implications*\nlike $x+1=4 \\implies x=3.$\n\nWe'll also learn two new fundamental facts about\nnatural numbers, which Peano introduced as axioms.\n\nClick on \"Start\" to proceed.":
 "æˆ‘ä»¬å·²ç»è¯æ˜äº† $2+2=4$ï¼›åœ¨â€œè•´æ¶µä¸–ç•Œâ€ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ \nå¦‚ä½•è¯æ˜ $2+2\\neq 5$ã€‚\n\nåœ¨â€œåŠ æ³•ä¸–ç•Œâ€ä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ $x + y = y + x$ ç­‰*ç­‰å¼*ã€‚\nåœ¨ç¬¬äºŒä¸ªæ•™ç¨‹ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ ä¸€äº›æ–°çš„ç­–ç•¥ã€\nä½¿æˆ‘ä»¬èƒ½å¤Ÿè¯æ˜\nå¦‚ $x+1=4 \\implies x=3.$\n\næˆ‘ä»¬è¿˜å°†å­¦ä¹ å…³äºè‡ªç„¶æ•°çš„ä¸¤ä¸ªæ–°çš„åŸºæœ¬äº‹å®ã€‚\nè‡ªç„¶æ•°çš„ä¸¤ä¸ªæ–°çš„åŸºæœ¬äº‹å®ã€‚\n\nç‚¹å‡» \"å¼€å§‹ \"ç»§ç»­ã€‚",
 "We've just seen that `0 ^ 0 = 1`, but if `n`\nis a successor, then `0 ^ n = 0`. We prove that here.":
 "æˆ‘ä»¬åˆšåˆšçœ‹åˆ° `0 ^ 0 = 1`ï¼Œä½†å¦‚æœ `n` æ˜¯åç»§æ•°ï¼Œ\nåˆ™ `0 ^ n = 0`ã€‚æˆ‘ä»¬å°†åœ¨è¿™é‡Œè¯æ˜è¿™ä¸€ç‚¹ã€‚",
 "We've been adding up two numbers; in this level we will add up three.\n\n  What does $x+y+z$ *mean*? It could either mean $(x+y)+z$, or it\n  could mean $x+(y+z)$. In Lean, $x+y+z$ means $(x+y)+z$.\n\n  But why do we care which one it means; $(x+y)+z$ and $x+(y+z)$ are *equal*!\n\n  That's true, but we didn't prove it yet. Let's prove it now by induction.":
 "æˆ‘ä»¬å·²ç»å­¦ä¼šäº†å°†ä¸¤ä¸ªæ•°ç›¸åŠ ï¼›åœ¨è¿™ä¸ªå±‚çº§ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†ä¸‰ä¸ªæ•°ç›¸åŠ ã€‚\n\n$x+y+z$ *æ„å‘³ç€*ä»€ä¹ˆï¼Ÿå®ƒå¯ä»¥æ„å‘³ç€ $(x+y)+z$ï¼Œä¹Ÿå¯ä»¥æ„å‘³ç€ $x+(y+z)$ã€‚åœ¨ Lean ä¸­ï¼Œ$x+y+z$ è¡¨ç¤º $(x+y)+z$ã€‚\n\nä½†æˆ‘ä»¬ä¸ºä»€ä¹ˆè¦åœ¨æ„å®ƒæ„å‘³ç€å“ªä¸€ä¸ªï¼›$(x+y)+z$ å’Œ $x+(y+z)$ æ˜¯*ç›¸ç­‰çš„*ï¼\n\nç¡®å®å¦‚æ­¤ï¼Œä½†æˆ‘ä»¬è¿˜æ²¡æœ‰è¯æ˜å®ƒã€‚ç°åœ¨è®©æˆ‘ä»¬é€šè¿‡å½’çº³æ¥è¯æ˜å®ƒã€‚",
 "We're going to change that `False` into `True`. Start by changing it into\n`is_zero (succ a)` by executing `rw [â† is_zero_succ a]`.":
 "æˆ‘ä»¬å°†è¦æŠŠé‚£ä¸ª `False` å˜æˆ `True`ã€‚é¦–å…ˆé€šè¿‡æ‰§è¡Œ `rw [â† is_zero_succ a]` æŠŠå®ƒå˜æˆ `is_zero (succ a)`ã€‚",
 "We'll need this lemma to prove that two is prime!\n\nYou'll need to know that `âˆ¨` is right associative. This means that\n`x = 0 âˆ¨ x = 1 âˆ¨ x = 2` actually means `x = 0 âˆ¨ (x = 1 âˆ¨ x = 2)`.\nThis affects how `left` and `right` work.":
 "æˆ‘ä»¬éœ€è¦è¿™ä¸ªå¼•ç†æ¥è¯æ˜äºŒæ˜¯è´¨æ•°ï¼\n\nä½ éœ€è¦çŸ¥é“ `âˆ¨` æ˜¯å³ç»“åˆçš„ã€‚è¿™æ„å‘³ç€ `x = 0 âˆ¨ x = 1 âˆ¨ x = 2` å®é™…ä¸Šæ„å‘³ç€ `x = 0 âˆ¨ (x = 1 âˆ¨ x = 2)`ã€‚è¿™ä¼šå½±å“ `left` å’Œ `right` çš„å·¥ä½œæ–¹å¼ã€‚",
 "We'd like to prove `2 + 2 = 4` but right now\nwe can't even *state* it\nbecause we haven't yet defined addition.\n\n## Defining addition.\n\nHow are we going to add $37$ to an arbitrary number $x$? Well,\nthere are only two ways to make numbers in this game: $0$\nand successors. So to define `37 + x` we will need\nto know what `37 + 0` is and what `37 + succ x` is.\nLet's start with adding `0`.\n\n### Adding 0\n\nTo make addition agree with our intuition, we should *define* `37 + 0`\nto be `37`. More generally, we should define `a + 0` to be `a` for\nany number `a`. The name of this proof in Lean is `add_zero a`.\nFor example `add_zero 37` is a proof of `37 + 0 = 37`,\n`add_zero x` is a proof of `x + 0 = x`, and `add_zero` is a proof\nof `? + 0 = ?`.\n\nWe write `add_zero x : x + 0 = x`, so `proof : statement`.":
 "æˆ‘ä»¬æ­£å¯»æ±‚è¯æ˜ `2 + 2 = 4`ï¼Œä½†ç›®å‰æˆ‘ä»¬è¿*è¡¨è¿°*å®ƒéƒ½åšä¸åˆ°ï¼Œå› ä¸ºåŠ æ³•å°šæœªè¢«å®šä¹‰ã€‚\n\n## åŠ æ³•çš„å®šä¹‰\n\nå¦‚ä½•å®ç°å°†ä»»æ„æ•°å­— $x$ åŠ åˆ° $37$ ä¸Šå‘¢ï¼Ÿåœ¨è¿™ä¸ªæ¸¸æˆé‡Œï¼Œæˆ‘ä»¬åªæœ‰ä¸¤ç§æ–¹å¼ç”Ÿæˆæ•°å­—ï¼š$0$ å’Œåç»§æ•°ã€‚å› æ­¤ï¼Œä¸ºäº†å®šä¹‰ `37 + x`ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç™½ `37 + 0` å’Œ `37 + succ x` åˆ†åˆ«æ˜¯ä»€ä¹ˆã€‚å…ˆä»åŠ  `0` çš„æƒ…å†µå¼€å§‹æ¢ç´¢ã€‚\n\n### åŠ  0\n\nä¸ºäº†è®©åŠ æ³•æ“ä½œç¬¦åˆç›´è§‰ï¼Œæˆ‘ä»¬åº”å½“*å®šä¹‰* `37 + 0` ä¸º `37`ã€‚æ›´å¹¿æ³›æ¥è¯´ï¼Œå¯¹äºä»»ä½•æ•°å­— `a`ï¼Œæˆ‘ä»¬å®šä¹‰ `a + 0` åº”ç­‰äº `a`ã€‚åœ¨ Lean ä¸­ï¼Œä»è¿™ä¸ªå®šä¹‰ç›´æ¥è¡ç”Ÿå‡ºçš„å®šç†è¢«å‘½åä¸º `add_zero a`ã€‚æ¯”å¦‚ï¼Œ`add_zero 37` è¯æ˜äº† `37 + 0 = 37`ï¼Œ`add_zero x` è¯æ˜äº† `x + 0 = x`ï¼Œè€Œ `add_zero` åˆ™è¯æ˜äº† `? + 0 = ?`ã€‚\n\næˆ‘ä»¬å°†å®šç†è®°ä½œ `add_zero x : x + 0 = x`ï¼Œå…¶ä¸­å®šç†çš„åç§°ä½äºå‰é¢ï¼Œè€Œå®šç†çš„è¡¨è¿°åˆ™ä½äºåé¢ã€‚è¿™å’Œä¹‹å‰åœ¨*å‡è®¾*ä¸­çš„è®°æ³•å¾ˆåƒã€‚",
 "We want to use `le_mul_right`, but we need a hypothesis `x * y â‰  0`\nwhich we don't have. Yet. Execute `have h2 : x * y â‰  0` (you can type `â‰ ` with `\\ne`).\nYou'll be asked to\nprove it, and then you'll have a new hypothesis which you can apply\n`le_mul_right` to.":
 "æˆ‘ä»¬æƒ³ä½¿ç”¨ `le_mul_right`ï¼Œä½†æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæˆ‘ä»¬è¿˜æ²¡æœ‰çš„å‡è®¾ `x * y â‰  0`ã€‚\nç°åœ¨æ‰§è¡Œ `have h2 : x * y â‰  0`ï¼ˆä½ å¯ä»¥ç”¨ `\\ne` è¾“å…¥ `â‰ `ï¼‰ã€‚\nä½ å°†è¢«è¦æ±‚è¯æ˜å®ƒï¼Œç„¶åä½ å°†æœ‰ä¸€ä¸ªæ–°çš„å‡è®¾ï¼Œä½ å¯ä»¥åº”ç”¨ `le_mul_right` åˆ°è¿™ä¸ªå‡è®¾ä¸Šã€‚",
 "We want to reduce this to a hypothesis `b = 0` and a goal `a * b = 0`,\nwhich is logically equivalent but much easier to prove. Remember that `X â‰  0`\nis notation for `X = 0 â†’ False`. Click on `Show more help!` if you need hints.":
 "æˆ‘ä»¬æƒ³å°†è¿™ä¸ªé—®é¢˜ç®€åŒ–ä¸ºå‡è®¾ `b = 0` å’Œç›®æ ‡ `a * b = 0`ï¼Œè¿™åœ¨é€»è¾‘ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œä½†æ›´å®¹æ˜“è¯æ˜ã€‚\nè®°ä½ï¼Œ`X â‰  0` æ˜¯ `X = 0 â†’ False` çš„ç¬¦å·è¡¨ç¤ºã€‚å¦‚æœä½ éœ€è¦æç¤ºï¼Œè¯·ç‚¹å‡»`Show more help!`ï¼ˆæ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼ï¼‰ã€‚",
 "We still can't prove `2 + 2 â‰  5` because we have not talked about the\ndefinition of `â‰ `. In Lean, `a â‰  b` is *notation* for `a = b â†’ False`.\nHere `False` is a generic false proposition, and `â†’` is Lean's notation\nfor \"implies\". In logic we learn\nthat `True â†’ False` is false, but `False â†’ False` is true. Hence\n`X â†’ False` is the logical opposite of `X`.\n\nEven though `a â‰  b` does not look like an implication,\nyou should treat it as an implication. The next two levels will show you how.\n\n`False` is a goal which you cannot deduce from a consistent set of assumptions!\nSo if your goal is `False` then you had better hope that your hypotheses\nare contradictory, which they are in this level.":
 "æˆ‘ä»¬ä»ç„¶ä¸èƒ½è¯æ˜ `2 + 2 â‰  5`ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰è®¨è®º `â‰ ` çš„å®šä¹‰ã€‚åœ¨ Lean ä¸­ï¼Œ`a â‰  b` æ˜¯ `a = b â†’ False` çš„*ç¬¦å·è¡¨ç¤º*ã€‚è¿™é‡Œçš„ `False` æ˜¯ä¸€ä¸ªé€šç”¨çš„å‡å‘½é¢˜ï¼Œ`â†’` æ˜¯ Lean ä¸­è¡¨ç¤ºâ€œè•´å«â€çš„ç¬¦å·\nã€‚\nåœ¨é€»è¾‘å­¦ä¸­æˆ‘ä»¬å­¦åˆ°ï¼Œ`True â†’ False` æ˜¯å‡çš„ï¼Œä½† `False â†’ False` æ˜¯çœŸçš„ã€‚å› æ­¤ï¼Œ`X â†’ false` æ˜¯ `X` çš„é€»è¾‘å–åã€‚\n\nå°½ç®¡ `a â‰  b` çœ‹èµ·æ¥ä¸åƒè•´å«ï¼Œä½ åº”è¯¥å°†å…¶è§†ä¸ºè•´å«ã€‚æ¥ä¸‹æ¥çš„ä¸¤å…³å°†å‘ä½ å±•ç¤ºæ€æ ·ä½¿ç”¨å®ƒã€‚\n\n`False` æ˜¯ä¸€ä¸ªæ— æ³•ä»ä¸€è‡´çš„å‡è®¾é›†ä¸­æ¨å¯¼å‡ºçš„ç›®æ ‡ï¼æ‰€ä»¥å¦‚æœä½ çš„ç›®æ ‡æ˜¯ `False`ï¼Œé‚£ä¹ˆä½ æœ€å¥½å¸Œæœ›ä½ çš„å‡è®¾æ˜¯çŸ›ç›¾çš„ï¼Œå°±åƒåœ¨æœ¬å…³ä¸­ä¸€æ ·ã€‚",
 "We now start work on an algorithm to do addition more efficiently. Recall that\nwe defined addition by recursion, saying what it did on `0` and successors.\nIt is an axiom of Lean that recursion is a valid\nway to define functions from types such as the naturals.\n\nLet's define a new function `pred` from the naturals to the naturals, which\nattempts to subtract 1 from the input. The definition is this:\n\n```\npred 0 := 37\npred (succ n) := n\n```\n\nWe cannot subtract one from 0, so we just return a junk value. As well as this\ndefinition, we also create a new lemma `pred_succ`, which says that `pred (succ n) = n`.\nLet's use this lemma to prove `succ_inj`, the theorem which\nPeano assumed as an axiom and which we have already used extensively without justification.":
 "æˆ‘ä»¬ç°åœ¨å¼€å§‹ç ”ç©¶ä¸€ä¸ªæ›´é«˜æ•ˆè¿›è¡ŒåŠ æ³•è®¡ç®—çš„ç®—æ³•ã€‚å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬é€šè¿‡é€’å½’å®šä¹‰äº†åŠ æ³•ï¼Œè¯´æ˜äº†å®ƒå¯¹ `0` å’Œåç»§è€…çš„ä½œç”¨ã€‚Lean çš„ä¸€ä¸ªå…¬ç†æ˜¯é€’å½’æ˜¯ä»åƒè‡ªç„¶æ•°è¿™æ ·çš„ç±»å‹å®šä¹‰å‡½æ•°çš„æœ‰æ•ˆæ–¹å¼ã€‚\n\nè®©æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªä»è‡ªç„¶æ•°åˆ°è‡ªç„¶æ•°çš„æ–°å‡½æ•° `pred`ï¼Œå®ƒè¯•å›¾ä»è¾“å…¥ä¸­å‡å» 1ã€‚å®šä¹‰å¦‚ä¸‹ï¼š\n\n```\npred 0 := 37\npred (succ n) := n\n```\n\næˆ‘ä»¬ä¸èƒ½ä» 0 ä¸­å‡å» 1ï¼Œæ‰€ä»¥æˆ‘ä»¬åªæ˜¯è¿”å›ä¸€ä¸ªæ— ç”¨çš„å€¼ã€‚é™¤äº†è¿™ä¸ªå®šä¹‰ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å¼•ç† `pred_succ`ï¼Œå®ƒè¯´ `pred (succ n) = n`ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¿™ä¸ªå¼•ç†æ¥è¯æ˜ `succ_inj`ï¼Œè¿™æ˜¯çš®äºšè¯ºå‡è®¾ä¸ºå…¬ç†çš„å®šç†ï¼Œæˆ‘ä»¬åœ¨æ²¡æœ‰è¯æ˜å®ƒçš„æƒ…å†µä¸‹å·²ç»å¹¿æ³›ä½¿ç”¨äº†ã€‚",
 "We now have enough to state a mathematically accurate, but slightly\nclunky, version of Fermat's Last Theorem.\n\nFermat's Last Theorem states that if $x,y,z>0$ and $m \\geq 3$ then $x^m+y^m\\not =z^m$.\nIf you didn't do inequality world yet then we can't talk about $m \\geq 3$,\nso we have to resort to the hack of using `n + 3` for `m`,\nwhich guarantees it's big enough. Similarly instead of `x > 0` we\nuse `a + 1`.\n\nThis level looks superficially like other levels we have seen,\nbut the shortest solution known to humans would translate into\nmany millions of lines of Lean code. The author of this game,\nKevin Buzzard, is working on translating the proof by Wiles\nand Taylor into Lean, although this task will take many years.\n\n## CONGRATULATIONS!\n\nYou've finished the main quest of the natural number game!\nIf you would like to learn more about how to use Lean to\nprove theorems in mathematics, then take a look\nat [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/),\nan interactive textbook which you can read in your browser,\nand which explains how to work with many more mathematical concepts in Lean.":
 "æˆ‘ä»¬ç°åœ¨å·²ç»æœ‰è¶³å¤Ÿçš„æ¡ä»¶æ¥é™ˆè¿°ä¸€ä¸ªæ•°å­¦ä¸Šå‡†ç¡®ä½†æœ‰äº›ç¬¨æ‹™çš„è´¹é©¬å¤§å®šç†äº†ã€‚\n\nè´¹é©¬å¤§å®šç†æŒ‡å‡ºï¼Œå¦‚æœ $x,y,z>0$ ä¸” $m \\geq 3$ï¼Œé‚£ä¹ˆ $x^m+y^m \\not = z^m$ã€‚\nå¦‚æœä½ è¿˜æ²¡å­¦ä¹ è¿‡ä¸ç­‰å¼ä¸–ç•Œï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸èƒ½è®¨è®º $m \\geq 3$ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¾—ä¸é‡‡ç”¨ä½¿ç”¨ `n + 3` ä»£æ›¿ `m` çš„æ–¹æ³•ï¼Œè¿™ä¿è¯äº†å®ƒè¶³å¤Ÿå¤§ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ç”¨ `a + 1` ä»£æ›¿ `x > 0`ã€‚\n\nè¿™ä¸€å…³è¡¨é¢ä¸Šçœ‹èµ·æ¥åƒæˆ‘ä»¬è§è¿‡çš„å…¶ä»–å…³å¡ï¼Œä½†äººç±»å·²çŸ¥çš„æœ€çŸ­è§£æ³•ä¹Ÿå°†è½¬åŒ–ä¸ºæ•°ç™¾ä¸‡è¡Œçš„ Lean ä»£ç ã€‚\nè¿™ä¸ªæ¸¸æˆçš„ä½œè€…ï¼ŒKevin Buzzardï¼Œæ­£åœ¨å°† Wiles å’Œ Taylor çš„è¯æ˜ç¿»è¯‘æˆ Leanï¼Œå°½ç®¡è¿™é¡¹ä»»åŠ¡å°†èŠ±è´¹è®¸å¤šå¹´ã€‚\n\n## ç¥è´ºï¼\n\nä½ å·²ç»å®Œæˆäº†è‡ªç„¶æ•°æ¸¸æˆçš„ä¸»çº¿ä»»åŠ¡ï¼\nå¦‚æœä½ æƒ³äº†è§£æ›´å¤šå…³äºå¦‚ä½•ä½¿ç”¨ Lean æ¥è¯æ˜æ•°å­¦å®šç†çš„ä¿¡æ¯ï¼Œè¯·æŸ¥çœ‹ [Mathematics In Lean](https://leanprover-community.github.io/mathematics_in_lean/)ï¼Œ\nè¿™æ˜¯ä¸€æœ¬äº’åŠ¨æ•™ç§‘ä¹¦ï¼Œä½ å¯ä»¥åœ¨æµè§ˆå™¨ä¸­é˜…è¯»å®ƒï¼Œå®ƒè§£é‡Šäº†å¦‚ä½•åœ¨ Lean ä¸­å¤„ç†æ›´å¤šçš„æ•°å­¦æ¦‚å¿µã€‚",
 "We now have enough to prove that multiplication is associative,\nthe boss level of multiplication world. Good luck!":
 "æˆ‘ä»¬ç°åœ¨æœ‰è¶³å¤Ÿçš„å·¥å…·å»è¯æ˜ä¹˜æ³•æœä»ç»“åˆå¾‹ï¼Œ\nä¹˜æ³•ä¸–ç•Œçš„bosså…³ã€‚ç¥ä½ å¥½è¿ï¼",
 "We know `zero_ne_succ n` is a proof of `0 = succ n â†’ False` -- but what\nif we have a hypothesis `succ n = 0`? It's the wrong way around!\n\nThe `symm` tactic changes a goal `x = y` to `y = x`, and a goal `x â‰  y`\nto `y â‰  x`. And `symm at h`\ndoes the same for a hypothesis `h`. We've proved $0 \\neq 1$ and called\nthe proof `zero_ne_one`; now try proving $1 \\neq 0$.":
 "æˆ‘ä»¬çŸ¥é“ `zero_ne_succ n` æ˜¯è¯æ˜ `0 = succ n â†’ False` çš„è¯æ˜ã€‚ä½†æ˜¯å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå‡è®¾ `succ n = 0` å‘¢ï¼Ÿè¿™æ°å¥½æ˜¯åè¿‡æ¥çš„ï¼\n\n`symm` ç­–ç•¥å¯ä»¥å°†ç›®æ ‡ `x = y` æ”¹ä¸º `y = x`ï¼Œå¹¶å°†ç›®æ ‡ `x â‰  y` æ”¹ä¸º `y â‰  x`ã€‚è€Œ `symm at h` å¯¹å‡è®¾ `h` ä¹ŸåšåŒæ ·çš„æ“ä½œã€‚\næˆ‘ä»¬å·²ç»è¯æ˜äº† $0 \\neq 1$ï¼Œå¹¶å°†è¯æ˜å‘½åä¸º `zero_ne_one`ï¼›ç°åœ¨è¯·å°è¯•è¯æ˜ $1 \\neq 0$ã€‚",
 "We have seen how to `apply` theorems and assumptions\nof the form `P â†’ Q`. But what if our *goal* is of the form `P â†’ Q`?\nTo prove this goal, we need to know how to say \"let's assume `P` and deduce `Q`\"\nin Lean. We do this with the `intro` tactic.":
 "æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†å¦‚ä½• `apply` å½¢å¼ä¸º `P â†’ Q` çš„å®šç†å’Œå‡è®¾ã€‚\nä½†å¦‚æœæˆ‘ä»¬çš„ *ç›®æ ‡* æ˜¯å½¢å¼ä¸º `P â†’ Q` çš„å‘¢ï¼Ÿ\nè¦è¯æ˜è¿™ä¸ªç›®æ ‡ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å¦‚ä½•åœ¨ Lean ä¸­è¡¨ç¤º â€œå‡è®¾ `P` å¹¶æ¨å¯¼å‡º `Q`â€ã€‚æˆ‘ä»¬ç”¨ `intro` ç­–ç•¥æ¥åšè¿™ä»¶äº‹ã€‚",
 "We gave a pretty unsatisfactory proof of `2 + 2 â‰  5` earlier on; now give a nicer one.":
 "æˆ‘ä»¬å‰é¢ç»™å‡ºçš„ `2 + 2 â‰  5` è¯æ˜å¹¶ä¸ä»¤äººæ»¡æ„ï¼Œç°åœ¨ç»™å‡ºä¸€ä¸ªæ›´å¥½çš„è¯æ˜ã€‚",
 "We don't know whether to go left or right yet. So start with `cases Â«{h}Â» with hx hy`.":
 "æˆ‘ä»¬è¿˜ä¸ç¡®å®šæ˜¯å‘å·¦è¿˜æ˜¯å‘å³ã€‚æ‰€ä»¥ä» `cases Â«{h}Â» with hx hy` å¼€å§‹ã€‚",
 "We define a function `is_zero` thus:\n\n```\nis_zero 0 := True\nis_zero (succ n) := False\n```\n\nWe also create two lemmas, `is_zero_zero` and `is_zero_succ n`, saying that `is_zero 0 = True`\nand `is_zero (succ n) = False`. Let's use these lemmas to prove `succ_ne_zero`, Peano's\nLast Axiom. Actually, we have been using `zero_ne_succ` before, but it's handy to have\nthis opposite version too, which can be proved in the same way. Note: you can\ncheat here by using `zero_ne_succ` but the point of this world is to show\nyou how to *prove* results like that.\n\nIf you can turn your goal into `True`, then the `trivial` tactic will solve it.":
 "æˆ‘ä»¬è¿™æ ·å®šä¹‰ä¸€ä¸ªå‡½æ•° `is_zero` ï¼š\n\n```\nis_zero 0 := True\nis_zero (succ n) := False\n```\n\næˆ‘ä»¬è¿˜åˆ›å»ºä¸¤ä¸ªå¼•ç† `is_zero_zero` å’Œ `is_zero_succ n`ï¼Œè¡¨ç¤º `is_zero 0 = True`\nå’Œ `is_zero (succ n) = False`ã€‚è®©æˆ‘ä»¬ä½¿ç”¨è¿™äº›å¼•ç†æ¥è¯æ˜ `succ_ne_zero`ï¼ŒPeano çš„\næœ€åçš„å…¬ç†ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬ä¹‹å‰ä¸€ç›´åœ¨ä½¿ç”¨ `zero_ne_succ`ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé€†å‘çš„ç‰ˆæœ¬ä¼šå¾ˆæ–¹ä¾¿ã€‚\nå®ƒå¯ä»¥ç”¨åŒæ ·çš„æ–¹å¼è¯æ˜ã€‚æ³¨æ„ï¼šä½ å¯ä»¥\né€šè¿‡ä½¿ç”¨ `zero_ne_succ` åœ¨è¿™é‡Œä½œå¼Šï¼Œä½†è¿™ä¸ªä¸–ç•Œçš„é‡ç‚¹æ˜¯å±•ç¤º\nä½ å¦‚ä½• *è¯æ˜* è¿™æ ·çš„ç»“æœã€‚\n\nå¦‚æœä½ èƒ½æŠŠä½ çš„ç›®æ ‡å˜æˆ`True`ï¼Œé‚£ä¹ˆ`trivial` ç­–ç•¥ï¼ˆtacticï¼‰å°±èƒ½è§£å†³å®ƒã€‚",
 "Very well done.\n\nA passing mathematician remarks that with you've just proved that `â„•` is totally\nordered.\n\nThe final few levels in this world are much easier.":
 "å¤ªæ£’äº†ï¼\n\nä¸€ä½è·¯è¿‡çš„æ•°å­¦å®¶è¯„è®ºè¯´ï¼Œæ‚¨åˆšåˆšè¯æ˜äº†è‡ªç„¶æ•°é›† `â„•` æ˜¯å…¨åºçš„ã€‚\n\nå‰©ä¸‹çš„å…³å¡ä¼šæ›´å®¹æ˜“ä¸€äº›ã€‚",
 "Use the previous lemma with `apply eq_succ_of_ne_zero at ha`.":
 "é€šè¿‡`apply eq_succ_of_ne_zero at ha`æ¥ä½¿ç”¨å‰é¢çš„å¼•ç†ã€‚",
 "Use `mul_eq_zero` and remember that `tauto` will solve a goal\nif there are hypotheses `a = 0` and `a â‰  0`.":
 "ä½¿ç”¨ `mul_eq_zero` å¹¶è®°ä½ï¼Œå¦‚æœå­˜åœ¨å‡è®¾ `a = 0` å’Œ `a â‰  0`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ä¸€ä¸ªç›®æ ‡ã€‚",
 "Use `add_succ`.": "ä½¿ç”¨ `add_succ`ã€‚",
 "Tutorial World": "æ•™ç¨‹ä¸–ç•Œ",
 "Try `rw [â† one_eq_succ_zero]` to change `succ 0` into `1`.":
 "å°è¯•ç”¨ `rw [â† one_eq_succ_zero]` å°† `succ 0` æ”¹ä¸º `1`ã€‚",
 "Try `rw [add_zero c]`.": "å°è¯•ä½¿ç”¨ `rw [add_zero c]`ã€‚",
 "Try `cases Â«{hd}Â» with h1 h2`.": "å°è¯• `cases Â«{hd}Â» with h1 h2`ã€‚",
 "Totality of `â‰¤` is the boss level of this world, and it's coming up next. It says that\nif `a` and `b` are naturals then either `a â‰¤ b` or `b â‰¤ a`.\nBut we haven't talked about `or` at all. Here's a run-through.\n\n1) The notation for \"or\" is `âˆ¨`. You won't need to type it, but you can\ntype it with `\\or`.\n\n2) If you have an \"or\" statement in the *goal*, then two tactics made\nprogress: `left` and `right`. But don't choose a direction unless your\nhypotheses guarantee that it's the correct one.\n\n3) If you have an \"or\" statement as a *hypothesis* `h`, then\n`cases h with h1 h2` will create two goals, one where you went left,\nand the other where you went right.":
 "\"`â‰¤`çš„å®Œå…¨æ€§æ˜¯è¿™ä¸ªä¸–ç•Œçš„è€å¤§çº§åˆ«ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å®ƒäº†ã€‚å®ƒè¡¨æ˜å¦‚æœ`a`å’Œ`b`æ˜¯è‡ªç„¶æ•°ï¼Œ\né‚£ä¹ˆè¦ä¹ˆ`a â‰¤ b`ï¼Œè¦ä¹ˆ`b â‰¤ a`ã€‚ä½†æˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰è®¨è®ºè¿‡`æˆ–`ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç®€è¦è¯´æ˜ã€‚\n\n1) â€œæˆ–â€çš„ç¬¦å·æ˜¯`âˆ¨`ã€‚ä½ ä¸éœ€è¦ç›´æ¥æ‰“å®ƒï¼Œä½ å¯ä»¥ç”¨`\\or`æ¥è¾“å…¥å®ƒã€‚\n\n2) å¦‚æœä½ çš„ *ç›®æ ‡* æ˜¯ä¸€ä¸ªâ€œæˆ–â€å‘½é¢˜ï¼Œé‚£ä¹ˆæœ‰ä¸¤ä¸ªç­–ç•¥å¯ä»¥å–å¾—è¿›å±•ï¼š`left`å’Œ`right`ã€‚\nä½†é™¤éä½ çš„çŸ¥é“å“ªè¾¹æ˜¯çœŸçš„ï¼Œå¦åˆ™ä¸è¦é€‰æ‹©ä¸€ä¸ªæ–¹å‘ã€‚\n\n3) å¦‚æœä½ åœ¨ *å‡è®¾* ä¸­æœ‰ä¸€ä¸ªâ€œæˆ–â€å‘½é¢˜`h`ï¼Œé‚£ä¹ˆ`cases h with h1 h2`ä¼šåˆ›å»ºä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªå‡è®¾å·¦è¾¹æ˜¯çœŸçš„ï¼Œå¦ä¸€ä¸ªå‡è®¾å³è¾¹æ˜¯çœŸçš„ã€‚",
 "To solve this level, you need to `use` a number `c` such that `x = 0 + c`.":
 "è¦é€šè¿‡æœ¬å…³å¡ï¼Œæ‚¨éœ€è¦ `use` ä¸€ä¸ªæ•°å­— `c` ä½¿å¾— `x = 0 + c`ã€‚",
 "Those of you interested in speedrunning the game may want to know\nthat `repeat rw [add_zero]` will do both rewrites at once.":
 "å¯¹äºé‚£äº›å¯¹å¿«é€Ÿé€šå…³æ¸¸æˆæ„Ÿå…´è¶£çš„ç©å®¶ï¼Œä¸€ä¸ªå°æŠ€å·§æ˜¯ä½¿ç”¨ `repeat rw [add_zero]` å¯ä»¥ä¸€æ¬¡æ€§å®Œæˆä¸¤æ¬¡é‡å†™æ“ä½œã€‚",
 "This world introduces exponentiation. If you want to define `37 ^ n`\nthen, as always, you will need to know what `37 ^ 0` is, and\nwhat `37 ^ (succ d)` is, given only `37 ^ d`.\n\nYou can probably guess the names of the general theorems:\n\n  * `pow_zero (a : â„•) : a ^ 0 = 1`\n  * `pow_succ (a b : â„•) : a ^ succ b = a ^ b * a`\n\nUsing only these, can you get past the final boss level?\n\nThe levels in this world were designed by Sian Carey, a UROP student\nat Imperial College London, funded by a Mary Lister McCammon Fellowship\nin the summer of 2019. Thanks to Sian and also thanks to Imperial\nCollege for funding her.":
 "è¿™ä¸ªä¸–ç•Œå¼•å…¥äº†å¹‚è¿ç®—ã€‚å¦‚æœä½ æƒ³å®šä¹‰ `37 ^ n`ï¼Œé‚£ä¹ˆåƒå¾€å¸¸ä¸€æ ·ï¼Œä½ éœ€è¦çŸ¥é“ `37 ^ 0` æ˜¯ä»€ä¹ˆï¼Œä»¥åŠåœ¨ä»…çŸ¥ `37 ^ d` çš„æƒ…å†µä¸‹ï¼Œ`37 ^ (succ d)` æ˜¯ä»€ä¹ˆã€‚\n\nä½ å¯èƒ½å·²ç»çŒœåˆ°äº†è¿™äº›ä¸€èˆ¬å®šç†çš„åç§°ï¼š\n\n  * `pow_zero (a : â„•) : a ^ 0 = 1`\n  * `pow_succ (a b : â„•) : a ^ succ b = a ^ b * a`\n\nä»…ç”¨è¿™äº›å®šç†ï¼Œä½ èƒ½é€šè¿‡æœ€åçš„bosså…³å¡å—ï¼Ÿ\n\nè¿™ä¸ªä¸–ç•Œä¸­çš„å…³å¡ç”±å¸å›½ç†å·¥å­¦é™¢çš„ UROP å­¦ç”Ÿ Sian Carey åœ¨ 2019 å¹´å¤å¤©è®¾è®¡ï¼Œå¥¹çš„é¡¹ç›®å¾—åˆ°äº† Mary Lister McCammon å¥–å­¦é‡‘çš„èµ„åŠ©ã€‚æ„Ÿè°¢ Sianï¼Œä¹Ÿæ„Ÿè°¢å¸å›½ç†å·¥å­¦é™¢å¯¹å¥¹çš„èµ„åŠ©ã€‚",
 "This time, use the `left` tactic.": "è¿™ä¸€æ¬¡ï¼Œä½¿ç”¨ `left` ç­–ç•¥ã€‚",
 "This level proves that if `a â‰  0` and `b â‰  0` then `a * b â‰  0`. One strategy\nis to write both `a` and `b` as `succ` of something, deduce that `a * b` is\nalso `succ` of something, and then `apply zero_ne_succ`.":
 "è¿™ä¸ªå…³å¡è¦è¯æ˜å¦‚æœ `a â‰  0` ä¸” `b â‰  0`ï¼Œé‚£ä¹ˆ `a * b â‰  0`ã€‚\nä¸€ç§ç­–ç•¥æ˜¯å°† `a` å’Œ `b` éƒ½å†™æˆæŸç‰©çš„ `succ`ï¼ˆåç»§ï¼‰ï¼Œæ¨æ–­å‡º `a * b` ä¹Ÿæ˜¯æŸç‰©çš„ `succ`ï¼Œç„¶ååº”ç”¨ `zero_ne_succ`ã€‚",
 "This level proves that if `a * b = 0` then `a = 0` or `b = 0`. It is\nlogically equivalent to the last level, so there is a very short proof.":
 "è¿™ä¸ªå…³å¡è¦è¯æ˜å¦‚æœ `a * b = 0` é‚£ä¹ˆ `a = 0` æˆ–è€… `b = 0`ã€‚è¿™åœ¨é€»è¾‘ä¸Šç­‰åŒä¸Šä¸€ä¸ªå…³å¡ï¼Œæ‰€ä»¥æœ‰ä¸€ä¸ªéå¸¸ç®€çŸ­çš„è¯æ˜ã€‚",
 "This level proves `x * y = 1 â†’ x = 1`, the multiplicative analogue of Advanced Addition\nWorld's `x + y = 0 â†’ x = 0`. The strategy is to prove that `x â‰¤ 1` and then use the\nlemma `le_one` from `â‰¤` world.\n\nWe'll prove it using a new and very useful tactic called `have`.":
 "åœ¨è¿™ä¸ªå…³å¡ï¼Œæˆ‘ä»¬è¯æ˜äº† `x * y = 1 â†’ x = 1`ï¼Œè¿™æ˜¯é«˜çº§åŠ æ³•ä¸–ç•Œä¸­ `x + y = 0 â†’ x = 0` çš„ä¹˜æ³•ç±»æ¯”ã€‚ç­–ç•¥æ˜¯è¯æ˜ `x â‰¤ 1`ï¼Œç„¶åä½¿ç”¨æ¥è‡ª `â‰¤` ä¸–ç•Œçš„å¼•ç† `le_one`ã€‚\n\næˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªæ–°çš„éå¸¸æœ‰ç”¨çš„ç­–ç•¥å«åš `have` æ¥è¯æ˜å®ƒã€‚",
 "This level is more important than you think; it plays\na useful role when battling a big boss later on.":
 "è¿™ä¸ªå…³å¡æ¯”ä½ æƒ³è±¡çš„æ›´é‡è¦ï¼›åœ¨ä¹‹åä¸ä¸€ä¸ªå¤§bossæˆ˜æ–—æ—¶ï¼Œå®ƒå°†å¸®åŠ©ä½ ã€‚",
 "This level asks you to prove *antisymmetry* of $\\leq$.\nIn other words, if $x \\leq y$ and $y \\leq x$ then $x = y$.\nIt's the trickiest one so far. Good luck!":
 "è¿™ä¸€å…³å¡è¦æ±‚ä½ è¯æ˜ $\\leq$ çš„ *åå¯¹ç§°æ€§* ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœ $x \\leq y$ ä¸” $y \\leq x$ï¼Œé‚£ä¹ˆ $x = y$ã€‚\nè¿™æ˜¯æœ¬æ¸¸æˆåˆ°ç›®å‰æœ€æ£˜æ‰‹çš„è¯æ˜ä¹‹ä¸€ã€‚ç¥ä½ å¥½è¿ï¼",
 "This lemma would have been easy if we had known that `x + y = y + x`. That theorem\n  is called `add_comm` and it is *true*, but unfortunately its proof *uses* both\n  `add_zero` and `zero_add`!\n\n  Let's continue on our journey to `add_comm`, the proof of `x + y = y + x`.":
 "å¦‚æœæˆ‘ä»¬çŸ¥é“ `x + y = y + x` ï¼Œé‚£ä¹ˆè¯æ˜è¿™ä¸ªå¼•ç†å°±ä¼šå¾ˆå®¹æ˜“ã€‚é‚£ä¸ªå®šç†\n  è¢«ç§°ä¸º `add_comm`  å¹¶ä¸”å®ƒæ˜¯ *æˆç«‹çš„* ï¼Œä½†ä¸å¹¸çš„æ˜¯å®ƒçš„è¯æ˜ *ç”¨åˆ°äº†* \n  `add_zero` å’Œ `zero_add`ï¼\n\n  è®©æˆ‘ä»¬ç»§ç»­æˆ‘ä»¬è¯æ˜ `add_comm`ï¼Œå³ `x + y = y + x` çš„æ—…ç¨‹ã€‚",
 "This is I think the toughest level yet. Tips: if `a` is a number\nthen `cases a with b` will split into cases `a = 0` and `a = succ b`.\nAnd don't go left or right until your hypotheses guarantee that\nyou can prove the resulting goal!\n\nI've left hidden hints; if you need them, retry from the beginning\nand click on \"Show more help!\"":
 "æˆ‘è®¤ä¸ºè¿™æ˜¯è¿„ä»Šä¸ºæ­¢æœ€éš¾çš„å…³å¡ã€‚æç¤ºï¼šå¦‚æœ `a` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases a with b` ä¼šåˆ†è§£ä¸º `a = 0` å’Œ `a = succ b` ä¸¤ç§æƒ…å†µã€‚ä¸è¦åœ¨ä½ çš„å‡è®¾ä¸èƒ½ä¿è¯ä½ èƒ½è¯æ˜æœ€ç»ˆç›®æ ‡ä¹‹å‰é€‰æ‹©è¯æ˜å·¦è¾¹æˆ–å³è¾¹ï¼\n\næˆ‘ç•™ä¸‹äº†ä¸€äº›éšè—çš„æç¤ºï¼›å¦‚æœä½ éœ€è¦ï¼Œè¯·ä»å¤´å¼€å§‹é‡è¯•å¹¶ç‚¹å‡»â€œæ˜¾ç¤ºæ›´å¤šå¸®åŠ©â€ï¼",
 "The way to start this proof is `induction b with d hd generalizing c`.":
 "å¼€å§‹è¯æ˜çš„æ–¹æ³•æ˜¯ `induction b with d hd generalizing c`ã€‚",
 "The rfl tactic": "rflç­–ç•¥",
 "The reason `Â«{x}Â» â‰¤ Â«{x}Â»` is because `Â«{x}Â» = Â«{x}Â» + 0`.\nSo you should start this proof with `use 0`.":
 "å› ä¸º `Â«{x}Â» = Â«{x}Â» + 0`ï¼Œæ‰€ä»¥`Â«{x}Â» â‰¤ Â«{x}Â»` ã€‚\næ‰€ä»¥ä½ åº”è¯¥ç”¨ `use 0` å¼€å§‹è¿™ä¸ªè¯æ˜ã€‚",
 "The previous lemma can be used to prove this one.": "å…ˆå‰çš„å¼•ç†å¯ä»¥ç”¨æ¥è¯æ˜è¿™ä¸ªå¼•ç†ã€‚",
 "The next result we'll need in `â‰¤` World is that if `a + b = 0` then `a = 0` and `b = 0`.\nLet's prove one of these facts in this level, and the other in the next.\n\n## A new tactic: `cases`\n\nThe `cases` tactic will split an object or hypothesis up into the possible ways\nthat it could have been created.\n\nFor example, sometimes you want to deal with the two cases `b = 0` and `b = succ d` separately,\nbut don't need the inductive hypothesis `hd` that comes with `induction b with d hd`.\nIn this situation you can use `cases b with d` instead. There are two ways to make\na number: it's either zero or a successor. So you will end up with two goals, one\nwith `b = 0` and one with `b = succ d`.\n\nAnother example: if you have a hypothesis `h : False` then you are done, because a false statement implies\nany statement. Here `cases h` will close the goal, because there are *no* ways to\nmake a proof of `False`! So you will end up with no goals, meaning you have proved everything.":
 "åœ¨è¿™ä¸€å…³ä¸­ï¼Œè®©æˆ‘ä»¬è¯æ˜å…¶ä¸­ä¸€ä¸ªäº‹å®ï¼Œè€Œåœ¨ä¸‹ä¸€å…³è¯æ˜å¦ä¸€ä¸ªã€‚\n\n## ä¸€ç§æ–°çš„ç­–ç•¥ï¼š`cases`\n\n`cases` ç­–ç•¥ä¼šå°†ä¸€ä¸ªå¯¹è±¡æˆ–å‡è®¾åˆ†è§£ä¸ºå¯èƒ½çš„åˆ›å»ºæ–¹å¼ã€‚\n\nä¾‹å¦‚ï¼Œæœ‰æ—¶ä½ æƒ³åˆ†åˆ«å¤„ç† `b = 0` å’Œ `b = succ d` è¿™ä¸¤ç§æƒ…å†µï¼Œä½†ä¸éœ€è¦ä¸ `induction b with d hd` ä¸€èµ·æ¥çš„å½’çº³å‡è®¾ `hd`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ `cases b with d`ã€‚åˆ¶é€ ä¸€ä¸ªæ•°å­—æœ‰ä¸¤ç§æ–¹å¼ï¼šå®ƒè¦ä¹ˆæ˜¯é›¶ï¼Œè¦ä¹ˆæ˜¯åç»§è€…ã€‚æ‰€ä»¥ä½ æœ€ç»ˆä¼šå¾—åˆ°ä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `b = 0`ï¼Œå¦ä¸€ä¸ªæ˜¯ `b = succ d`ã€‚\n\nå¦ä¸€ä¸ªä¾‹å­ï¼šå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : False`ï¼Œé‚£ä¹ˆä½ å°±å®Œæˆè¯æ˜äº†ï¼Œå› ä¸ºä» `False` å¯ä»¥æ¨å‡ºä»»ä½•è¯æ˜ã€‚è¿™é‡Œ `cases h` å°†è¯æ˜ç›®æ ‡ï¼Œå› ä¸ºæ²¡æœ‰ *ä»»ä½•* æ–¹æ³•å¯ä»¥è¯æ˜ `False`ï¼æ‰€ä»¥ä½ æœ€ç»ˆä¼šæ²¡æœ‰ç›®æ ‡ï¼Œæ„å‘³ç€ä½ å·²ç»è¯æ˜äº†ä¸€åˆ‡ã€‚",
 "The music gets ever more dramatic, as we explore\nthe interplay between exponentiation and multiplication.\n\nIf you're having trouble exchanging the right `x * y`\nbecause `rw [mul_comm]` swaps the wrong multiplication,\nthen read the documentation of `rw` for tips on how to fix this.":
 "å½“æˆ‘ä»¬æ¢ç´¢æ—¶ï¼ŒéŸ³ä¹å˜å¾—æ›´åŠ æˆå‰§åŒ–\næ±‚å¹‚å’Œä¹˜æ³•ä¹‹é—´çš„ç›¸äº’ä½œç”¨ã€‚\n\nå¦‚æœæ‚¨åœ¨æ›´æ¢æ­£ç¡®çš„ `x * y` æ—¶é‡åˆ°é—®é¢˜\nå› ä¸º `rw [mul_comm]` äº¤æ¢äº†é”™è¯¯çš„ä¹˜æ³•ï¼Œ\nç„¶åé˜…è¯» `rw` çš„æ–‡æ¡£ä»¥è·å–æœ‰å…³å¦‚ä½•è§£å†³æ­¤é—®é¢˜çš„æç¤ºã€‚",
 "The music dies down. Is that it?\n\nCourse it isn't, you can\nclearly see that there are two worlds left.\n\nA passing mathematician says that mathematicians don't have a name\nfor the structure you just constructed. You feel cheated.\n\nSuddenly the music starts up again. This really is the final boss.":
 "èƒŒæ™¯éŸ³ä¹æ¸æ¸å¹³æ¯ã€‚æ˜¯è¿™æ ·å—ï¼Ÿ\n\nå½“ç„¶ä¸æ˜¯ï¼Œä½ å¯ä»¥\næ¸…æ¥šåœ°çœ‹åˆ°å‰©ä¸‹ä¸¤ä¸ªä¸–ç•Œã€‚\n\nè·¯è¿‡çš„æ•°å­¦å®¶è¯´æ•°å­¦å®¶æ²¡æœ‰åå­—\nå¯¹äºæ‚¨åˆšåˆšæ„å»ºçš„ç»“æ„ã€‚ä½ æ„Ÿè§‰è¢«æ¬ºéª—äº†ã€‚\n\nçªç„¶éŸ³ä¹å†æ¬¡å“èµ·ã€‚è¿™ç¡®å®æ˜¯æœ€ç»ˆbossã€‚",
 "The lemma proved in the final level of this world will be helpful\nin Divisibility World.":
 "åœ¨è¿™ä¸ªä¸–ç•Œçš„æœ€åä¸€ä¸ªå±‚çº§è¯æ˜çš„å¼•ç†å°†åœ¨å¯é™¤æ€§ä¸–ç•Œä¸­å¾ˆæœ‰å¸®åŠ©ã€‚",
 "The inductive hypothesis `hd` is \"For all natural numbers `c`, `a * d = a * c â†’ d = c`\".\nYou can `apply` it `at` any hypothesis of the form `a * d = a * ?`.":
 "å½’çº³å‡è®¾ `hd` æ˜¯â€œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° `c`ï¼Œ`a * d = a * c â†’ d = c`â€çš„è¯æ˜ã€‚ä½ å¯ä»¥åœ¨ä»»ä½•å½¢å¼ä¸º `a * d = a * ?` çš„å‡è®¾ä¸Šåº”ç”¨ï¼ˆ`apply`ï¼‰å®ƒã€‚",
 "The goal in this level is one of our hypotheses. Solve the goal by executing `exact h1`.":
 "è¿™ä¸€å±‚çš„ç›®æ ‡æ˜¯æˆ‘ä»¬çš„ä¸€ä¸ªå‡è®¾ã€‚é€šè¿‡æ‰§è¡Œ `exact h1` æ¥è§£å†³ç›®æ ‡ã€‚",
 "The first sub-boss of Multiplication World is `mul_comm x y : x * y = y * x`.\n\nWhen you've proved this theorem we will have \"spare\" proofs\nsuch as `zero_mul`, which is now easily deducible from `mul_zero`.\nBut we'll keep hold of these proofs anyway, because it's convenient\nto have exactly the right tool for a job.":
 "ä¹˜æ³•ä¸–ç•Œçš„ç¬¬ä¸€ä¸ªå° Boss æ˜¯ `mul_comm x y : x * y = y * x`ã€‚\n\nå½“ä½ è¯æ˜äº†è¿™ä¸ªå®šç†åï¼Œæˆ‘ä»¬å°†æœ‰ä¸€äº›â€œå¤šä½™â€çš„è¯æ˜\nä¾‹å¦‚ `zero_mul`ï¼Œå®ƒç°åœ¨å¯ä»¥è½»æ¾åœ°ä» `mul_zero` ä¸­æ¨å¯¼å‡ºæ¥ã€‚\nä½†æ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½ä¼šä¿ç•™è¿™äº›è¯æ˜ï¼Œå› ä¸º\næ‹¥æœ‰é€‚åˆå·¥ä½œçš„å·¥å…·ä¼šå¾ˆæ–¹ä¾¿ã€‚",
 "The classical introduction game for Lean.": "ç»å…¸çš„Leanå…¥é—¨æ¸¸æˆã€‚",
 "The `use` tactic": "`use` ç­–ç•¥",
 "The `exact` tactic": "`exact` ç­–ç•¥",
 "The `apply` tactic.": "`apply` ç­–ç•¥ã€‚",
 "Start with induction on `n`.": "ä»å¯¹ `n` çš„å½’çº³å¼€å§‹ã€‚",
 "Start with `rw [â† pred_succ a]` and take it from there.":
 "ä» `rw [â† pred_succ a]` å¼€å§‹ï¼Œç„¶åå†ç»§ç»­ã€‚",
 "Start with `rw [two_eq_succ_one]` to begin to break `2` down into its definition.":
 "ä»ä½¿ç”¨ `rw [two_eq_succ_one]` å¼€å§‹ï¼Œå°† `2` åˆ†è§£ä¸ºå®ƒçš„å®šä¹‰ã€‚",
 "Start with `repeat rw [add_assoc]` to push all the brackets to the right.":
 "ä» `repeat rw [add_assoc]` å¼€å§‹ï¼Œå°†æ‰€æœ‰çš„æ‹¬å·æ¨åˆ°å³è¾¹ã€‚",
 "Start with `intro hb`.": "ä» `intro hb` å¼€å§‹ã€‚",
 "Start with `intro h`.": "ä» `intro h` å¼€å§‹ã€‚",
 "Start with `intro h` to assume the hypothesis.": "ç”¨ `intro h` å¼€å§‹è®¾å‡è®¾ã€‚",
 "Start with `intro h` to assume the hypothesis and call its proof `h`.":
 "ä½¿ç”¨ `intro h` æ¥è®¾å‡è®¾ä¸º `h`ã€‚",
 "Start with `intro h` (remembering that `X â‰  Y` is just notation\nfor `X = Y â†’ False`).":
 "ä» `intro h` å¼€å§‹ï¼ˆè®°ä½ `X â‰  Y` åªæ˜¯ `X = Y â†’ False` çš„ç¬¦å·è¡¨ç¤ºï¼‰ã€‚",
 "Start with `induction Â«{y}Â» with d hd`.": "ä»`induction Â«{y}Â» with d hd`å¼€å§‹ã€‚",
 "Start with `have h2 := mul_ne_zero a b`.":
 "ä» `have h2 := mul_ne_zero a b` å¼€å§‹ã€‚",
 "Start with `contrapose! h`, to change the goal into its\ncontrapositive, namely a hypothesis of `succ m = succ m` and a goal of `m = n`.":
 "ä» `contrapose! h` å¼€å§‹ï¼Œå°†ç›®æ ‡è½¬å˜ä¸ºå…¶é€†å¦å‘½é¢˜ï¼Œå³å‡è®¾ä¸º `succ m = succ m`ï¼Œç›®æ ‡ä¸º `m = n`ã€‚",
 "Start with `cases Â«{hxy}Â» with a ha`.": "ä» `cases Â«{hxy}Â» with a ha` å¼€å§‹ã€‚",
 "Start with `cases a with d` to do a case split on `a = 0` and `a = succ d`.":
 "ä»ç”¨ `cases a with d` å¼€å§‹ï¼Œå¯¹ `a = 0` å’Œ `a = succ d` è¿›è¡Œç±»è®¨è®ºã€‚",
 "Start with `apply succ_inj` to apply `succ_inj` to the *goal*.":
 "ä» `apply succ_inj` å¼€å§‹ï¼Œå°† `succ_inj` åº”ç”¨äº *goal* ï¼ˆç›®æ ‡ï¼‰ã€‚",
 "Start with `apply h2 at h1`. This will change `h1` to `y = 42`.":
 "ä» `apply h2 at h1` å¼€å§‹ã€‚è¿™å°†ä¼šæŠŠ `h1` æ”¹ä¸º `y = 42`ã€‚",
 "Start with `apply eq_succ_of_ne_zero at ha` and `... at hb`":
 "ä»¥`åœ¨ ha å¤„åº”ç”¨ eq_succ_of_ne_zero` å’Œ`......åœ¨ hb` å¼€å¤´",
 "Start by unravelling the `1`.": "ä»å±•å¼€ \"1 \"å¼€å§‹ã€‚",
 "Split into cases `c = 0` and `c = succ e` with `cases c with e`.":
 "ç”¨ `c cases c with e` åˆ†æˆ `c = 0` å’Œ `c = succ e` ä¸¤ç§æƒ…å†µè®¨è®ºã€‚",
 "Solve this level in one line with `simp only [add_assoc, add_left_comm, add_comm]`":
 "ç”¨ `simp only [add_assoc, add_left_comm, add_comm]` åœ¨ä¸€è¡Œä¸­è¯æ˜è¿™ä¸€å…³",
 "So that's the algorithm: now let's use automation to perform it\nautomatically.":
 "æ‰€ä»¥è¿™å°±æ˜¯ç®—æ³•ï¼šç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨æœºå™¨æ¥è‡ªåŠ¨æ‰§è¡Œå®ƒã€‚",
 "Similarly we have `mul_succ`\nbut we're going to need `succ_mul` (guess what it says -- maybe you\nare getting the hang of Lean's naming conventions).\n\nThe last level from addition world might help you in this level.\nIf you can't remember what it is, you can go back to the\nhome screen by clicking the house icon and then taking a look.\nYou won't lose any progress.":
 "åŒæ ·ï¼Œæˆ‘ä»¬æœ‰ `mul_succ`ï¼Œ\nä½†æˆ‘ä»¬éœ€è¦ `succ_mul`ï¼ˆçŒœçŒœå®ƒæ˜¯ä»€ä¹ˆæ„æ€ â€”â€” ä¹Ÿè®¸ä½ å·²ç»æŒæ¡äº† Lean çš„å‘½åèŒƒå¼ï¼‰ã€‚\n\nåŠ æ³•ä¸–ç•Œä¸­çš„æœ€åä¸€å…³ä¼šåœ¨è¿™ä¸ªå…³å¡ä¸­å¸®åŠ©ä½ ã€‚\nå¦‚æœä½ å¿˜è®°äº†å®ƒæ˜¯ä»€ä¹ˆï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡»æˆ¿å±‹å›¾æ ‡å›åˆ°ä¸»ç•Œé¢ï¼Œç„¶åçœ‹ä¸€çœ‹ã€‚\nä½ ä¸ä¼šå¤±å»ä»»ä½•è¿›å±•ã€‚",
 "See the new \"*\" tab in your lemmas, containing `mul_zero` and `mul_succ`.\nRight now these are the only facts we know about multiplication.\nLet's prove nine more.\n\nLet's start with a warm-up: no induction needed for this one,\nbecause we know `1` is a successor.":
 "æŸ¥çœ‹å¼•ç†åŒºä¸­çš„æ–°â€œ*â€æ ‡ç­¾ï¼ŒåŒ…å« `mul_zero` å’Œ `mul_succ`ã€‚\nç›®å‰è¿™äº›æ˜¯æˆ‘ä»¬å”¯ä¸€çŸ¥é“çš„å…³äºä¹˜æ³•çš„äº‹å®ã€‚\nè®©æˆ‘ä»¬å†è¯æ˜ä¹ä¸ªã€‚\n\nè®©æˆ‘ä»¬ä»ä¸€ä¸ªçƒ­èº«å¼€å§‹ï¼šè¿™ä¸ªä¸éœ€è¦å½’çº³ï¼Œ\nå› ä¸ºæˆ‘ä»¬çŸ¥é“ `1` æ˜¯ä¸€ä¸ªåç»§æ•°ã€‚",
 "See if you can take it from here. Look at the new lemmas and tactic\navailable on the right.":
 "çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä»è¿™é‡Œå¼€å§‹ã€‚æŸ¥çœ‹å³ä¾§å¯ç”¨çš„æ–°å¼•ç†å’Œç­–ç•¥ã€‚",
 "Remember, `x â‰  y` is *notation* for `x = y â†’ False`.":
 "è®°ä½ï¼Œ`x â‰  y` æ˜¯ `x = y â†’ False` çš„ *ç¬¦å·è¡¨ç¤º* ã€‚",
 "Remember that when Lean writes `a + b + c`, it means `(a + b) + c`.\nIf you are not sure where the brackets are in an expression, just hover\nyour cursor over it and look at what gets highlighted. For example,\nhover over both `+` symbols on the left hand side of the goal and\nyou'll see where the invisible brackets are.":
 "è®°ä½ï¼Œå½“ Lean å†™ä½œ `a + b + c` æ—¶ï¼Œå®ƒçš„æ„æ€æ˜¯ `(a + b) + c`ã€‚\nå¦‚æœä½ ä¸ç¡®å®šè¡¨è¾¾å¼ä¸­çš„æ‹¬å·åœ¨å“ªé‡Œï¼Œåªéœ€å°†å…‰æ ‡æ‚¬åœåœ¨å®ƒä¸Šé¢ï¼Œ\nçœ‹çœ‹ä»€ä¹ˆè¢«é«˜äº®æ˜¾ç¤ºã€‚ä¾‹å¦‚ï¼Œå°†å…‰æ ‡æ‚¬åœåœ¨ç›®æ ‡å·¦ä¾§çš„ä¸¤ä¸ª `+` ç¬¦å·ä¸Šï¼Œ\nä½ å°±ä¼šçœ‹åˆ°çœ‹ä¸è§çš„æ‹¬å·åœ¨å“ªé‡Œã€‚",
 "Remember that `h2` is a proof of `x = y â†’ False`. Try\n`apply`ing `h2` either `at h1` or directly to the goal.":
 "è®°ä½ï¼Œ`h2` æ˜¯ `x = y â†’ False` çš„è¯æ˜ã€‚å°è¯•å°† `h2` åº”ç”¨ï¼ˆ`apply`ï¼‰äº `h1` æˆ–ç›´æ¥åº”ç”¨äºç›®æ ‡ã€‚",
 "Reduce to the previous lemma with `nth_rewrite 2 [â† mul_one a] at h`":
 "ä½¿ç”¨ `nth_rewrite 2 [â† mul_one a] at h` å°†é—®é¢˜ç®€åŒ–ä¸ºä¹‹å‰çš„å¼•ç†ã€‚",
 "Ready for the boss level of this world?": "å‡†å¤‡å¥½è¿æ¥è¿™ä¸ªä¸–ç•Œçš„Bosså…³äº†å—ï¼Ÿ",
 "Proofs like $2+2=4$ and $a+b+c+d+e=e+d+c+b+a$ are very tedious to do by hand.\nIn Algorithm World we learn how to get the computer to do them for us.\n\nClick on \"Start\" to proceed.":
 "åƒ $2+2=4$ å’Œ $a+b+c+d+e=e+d+c+b+a$ è¿™æ ·çš„è¯æ˜å¦‚æœæ‰‹å·¥å®Œæˆä¼šéå¸¸ç¹çã€‚åœ¨ç®—æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è®©è®¡ç®—æœºå¸®æˆ‘ä»¬å®Œæˆå®ƒä»¬ã€‚\n\nç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚",
 "Precision rewriting": "ç²¾å‡†é‡å†™",
 "Power World": "å¹‚ä¸–ç•Œ",
 "Our next goal is \"left and right distributivity\",\nmeaning $a(b+c)=ab+ac$ and $(b+c)a=ba+ca$. Rather than\nthese slightly pompous names, the name of the proofs\nin Lean are descriptive. Let's start with\n`mul_add a b c`, the proof of `a * (b + c) = a * b + a * c`.\nNote that the left hand side contains a multiplication\nand then an addition.":
 "æˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯â€œå·¦å³åˆ†é…å¾‹â€ï¼Œ\næ„æ€æ˜¯ $a(b+c)=ab+ac$ å’Œ $(b+c)a=ba+ca$ã€‚\nè¿™æ ·çš„åå­—ç•¥æ˜¾æµ®å¤¸ã€‚åœ¨Leanä¸­è¯æ˜çš„åå­—ä¸€èˆ¬ä¸æ˜¯è¿™æ ·çš„ï¼Œå¤§éƒ½æ˜¯æè¿°æ€§çš„ã€‚\nè®©æˆ‘ä»¬ä»\n`mul_add a b c`ï¼Œä¹Ÿå°±æ˜¯ `a * (b + c) = a * b + a * c` å¼€å§‹è¯æ˜ã€‚\nè¯·æ³¨æ„ï¼Œå·¦ä¾§åŒ…å«ä¹˜æ³•\nç„¶åæ˜¯åŠ æ³•ã€‚",
 "Our first challenge is `mul_comm x y : x * y = y * x`,\nand we want to prove it by induction. The zero\ncase will need `mul_zero` (which we have)\nand `zero_mul` (which we don't), so let's\nstart with this.":
 "æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªæŒ‘æˆ˜æ˜¯`mul_comm x y : x * y = y * x`ï¼Œ\næˆ‘ä»¬æƒ³é€šè¿‡å½’çº³æ³•æ¥è¯æ˜è¿™ä¸€ç‚¹ã€‚åœ¨è¯æ˜0çš„ç›®æ ‡ä¸‹æˆ‘ä»¬éœ€è¦ `mul_zero` ï¼ˆæˆ‘ä»¬æœ‰ï¼‰\nå’Œ `zero_mul` ï¼ˆæˆ‘ä»¬æ²¡æœ‰ï¼‰ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬\nä»è¿™ä¸ªå¼€å§‹ã€‚",
 "One of the best named levels in the game, a savage `pow_pow`\nsub-boss appears as the music reaches a frenzy. What\nelse could there be to prove about powers after this?":
 "æ¸¸æˆä¸­æœ€åå‰¯å…¶å®çš„å…³å¡ä¹‹ä¸€ã€‚\néšç€éŸ³ä¹è¾¾åˆ°ç‹‚çƒ­ï¼Œä¸€ä¸ªå‡¶çŒ›çš„ `pow_pow` å°bosså‡ºç°äº†ã€‚\nåœ¨è¿™ä¹‹åï¼Œè¿˜æœ‰ä»€ä¹ˆå…³äºå¹‚çš„æ€§è´¨éœ€è¦è¯æ˜å‘¢ï¼Ÿ",
 "On the set of natural numbers, addition is commutative.\nIn other words, if `a` and `b` are arbitrary natural numbers, then\n$a + b = b + a$.":
 "åœ¨è‡ªç„¶æ•°é›†ä¸Šï¼ŒåŠ æ³•æ˜¯å¯äº¤æ¢çš„ã€‚\næ¢å¥è¯è¯´ï¼Œå¦‚æœ `a` å’Œ `b` æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ\n$a + b = b + a$ã€‚",
 "On the set of natural numbers, addition is associative.\nIn other words, if $a, b$ and $c$ are arbitrary natural numbers, we have\n$ (a + b) + c = a + (b + c). $":
 "åœ¨è‡ªç„¶æ•°é›†ä¸Šï¼ŒåŠ æ³•æœä»ç»“åˆå¾‹ã€‚\næ¢å¥è¯è¯´ï¼Œå¦‚æœ $a, b$ å’Œ $c$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n$ (a + b) + c = a + (b + c)$ ã€‚",
 "Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add a b`\nis the proof that `(succ a) + b = succ (a + b)` for `a` and `b` numbers.\nThis result is what's standing in the way of `x + y = y + x`. Again\nwe have the problem that we are adding `b` to things, so we need\nto use induction to split into the cases where `b = 0` and `b` is a successor.":
 "å“¦ä¸ï¼åœ¨å‰å¾€ `add_comm` çš„è·¯ä¸Šï¼Œä¸€ä¸ªé‡ç”Ÿçš„ `succ_add` å‡ºç°äº†ã€‚\n`succ_add a b` æ˜¯ `(succ a) + b = succ (a + b)` çš„è¯æ˜ï¼Œå¯¹äºæ•°å­— `a` å’Œ `b`ã€‚\nè¿™ä¸ªç»“æœæ˜¯è¯æ˜ `x + y = y + x` çš„ä¸­é—´æ­¥éª¤ã€‚è¿™é‡Œæˆ‘ä»¬å†æ¬¡é‡åˆ°äº†å‘äº‹ç‰©ä¸­åŠ å…¥ `b` çš„é—®é¢˜ï¼Œ\næ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨å½’çº³æ³•æ¥åˆ†è§£æˆ `b = 0` å’Œ `b` æ˜¯åç»§æ•°çš„æƒ…å†µã€‚",
 "Numbers": "æ•°å­—",
 "Now you need to figure out which number to `use`. See if you can take it from here.":
 "ç°åœ¨ä½ éœ€è¦å¼„æ¸…æ¥šä½¿ç”¨ï¼ˆ `use` ï¼‰å“ªä¸ªæ•°å­—ã€‚çœ‹çœ‹ä½ æ˜¯å¦å¯ä»¥ä»è¿™é‡Œç»§ç»­ã€‚",
 "Now you have two goals. Once you proved the first, you will jump to the second one.\nThis first goal is the base case $n = 0$.\n\nRecall that you can rewrite the proof of any lemma which is visible\nin your inventory, or of any assumption displayed above the goal,\nas long as it is of the form `X = Y`.":
 "ç°åœ¨ä½ æœ‰ä¸¤ä¸ªç›®æ ‡ã€‚ä¸€æ—¦ä½ è¯æ˜äº†ç¬¬ä¸€ä¸ªï¼Œä½ ä¼šè‡ªåŠ¨è·³åˆ°ç¬¬äºŒä¸ªã€‚\nç¬¬ä¸€ä¸ªç›®æ ‡æ˜¯åŸºç¡€æƒ…å½¢ $n = 0$ã€‚\n\nå›æƒ³ä¸€ä¸‹ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»»ä½•åœ¨ä½ çš„æ¸…å•ä¸­å¯è§çš„å¼•ç†çš„è¯æ˜ï¼Œæˆ–è€…ä»»ä½•æ˜¾ç¤ºåœ¨ç›®æ ‡ä¸Šæ–¹çš„å‡è®¾\nï¼ˆåªè¦å®ƒæ˜¯å½¢å¦‚ `X = Y` çš„å½¢å¼ï¼‰æ¥é‡å†™ç›®æ ‡ã€‚",
 "Now you could finish with `rw [Â«{h}Â»]` then `rfl`, but `exact Â«{h}Â»`\ndoes it in one line.":
 "ç°åœ¨ä½ å¯ä»¥ç”¨ `rw [\"{h}\"]` ç„¶å `rfl` æ¥å®Œæˆè¯æ˜ï¼Œä½† `exact \"{h}\"` å¯ä»¥åœ¨ä¸€è¡Œä¸­åšåˆ°åŒæ ·çš„äº‹ã€‚",
 "Now you can `rw [add_succ]`": "ç°åœ¨ï¼Œæ‚¨å¯ä»¥ `rw [add_succ]`",
 "Now you can `apply zero_ne_succ at h`.": "ç°åœ¨å¯ä»¥ä½¿ç”¨ `apply zero_ne_succ at h`ã€‚",
 "Now you can `apply le_mul_right at h2`.": "ç°åœ¨ï¼Œæ‚¨å¯ä»¥`apply le_mul_right at h2`ã€‚",
 "Now we can prove the `or` statement by proving the statement on the right,\nso use the `right` tactic.":
 "ç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡è¯æ˜å³è¾¹çš„å£°æ˜æ¥è¯æ˜ `or` å‘½é¢˜ï¼Œ\næ‰€ä»¥ä½¿ç”¨ `right` ç­–ç•¥ã€‚",
 "Now use `rw [add_left_comm b c]` to switch `b` and `c` on the left\nhand side.":
 "ç°åœ¨ä½¿ç”¨ `rw [add_left_comm b c]` å°†å·¦ä¾§çš„ `b` å’Œ `c` äº¤æ¢ã€‚",
 "Now the goal can be deduced from `h2` by pure logic, so use the `tauto`\ntactic.":
 "ç°åœ¨ï¼Œç›®æ ‡å¯ä»¥é€šè¿‡çº¯ç²¹çš„é€»è¾‘ä» `h2` æ¨å¯¼å‡ºæ¥ï¼Œæ‰€ä»¥ä½¿ç”¨ `tauto` ç­–ç•¥ã€‚",
 "Now take apart the existence statement with `cases ha with n hn`.":
 "ç°åœ¨ç”¨ `cases ha with n hn` åˆ†ç±»è®¨è®ºå­˜åœ¨æ€§å®šç†ã€‚",
 "Now rewrite `succ_eq_add_one` backwards at `h`\nto get the right hand side.":
 "ç°åœ¨åœ¨ `h` å¤„åå‘é‡å†™ `succ_eq_add_one` æ¥å¾—åˆ°å³è¾¹å¼å­ã€‚",
 "Now rewrite `four_eq_succ_three` backwards to make the goal\nequal to the hypothesis.":
 "ç°åœ¨åæ–¹å‘é‡å†™ `four_eq_succ_three` ä½¿ç›®æ ‡ç­‰äºå‡è®¾ã€‚",
 "Now let's `apply` our new theorem. Execute `apply succ_inj at h`\nto change `h` to a proof of `x = 3`.":
 "ç°åœ¨è®©æˆ‘ä»¬åº”ç”¨ï¼ˆ `apply` ï¼‰æˆ‘ä»¬çš„æ–°å®šç†ã€‚æ‰§è¡Œ `apply succ_inj at h` æ¥å°† `h` å˜ä¸ºè¯æ˜ `x = 3` çš„è¯æ®ã€‚",
 "Now for to the second goal. Here you have the induction hypothesis\n`Â«{hd}Â» : 0 + Â«{d}Â» = Â«{d}Â»`, and you need to prove that `0 + succ Â«{d}Â» = succ Â«{d}Â»`.":
 "ç°åœ¨æ¥åˆ°ç¬¬äºŒä¸ªç›®æ ‡ã€‚è¿™é‡Œä½ æœ‰å½’çº³å‡è®¾\n`Â«{hd}Â» : 0 + Â«{d}Â» = Â«{d}Â»`ï¼Œä½ éœ€è¦è¯æ˜ `0 + succ Â«{d}Â» = succ Â«{d}Â»`ã€‚",
 "Now finish using the `exact` tactic.": "ç°åœ¨ä½¿ç”¨ `exact` ç­–ç•¥å®Œæˆè¯æ˜ã€‚",
 "Now finish the job with `rfl`.": "ç°åœ¨ç”¨ `rfl` å®Œæˆè¯æ˜ã€‚",
 "Now finish in one line.": "ç°åœ¨å†ç”¨ä¸€è¡Œå®Œæˆè¯æ˜ã€‚",
 "Now change `1` to `succ 0` in `h`.": "ç°åœ¨å°† `h` ä¸­çš„ `1` æ”¹å†™ä¸º `succ 0`ã€‚",
 "Now `Â«{ha}Â»` is a proof that `Â«{y}Â» = Â«{x}Â» + Â«{a}Â»`, and `hxy` has vanished. Similarly, you can destruct\n`Â«{hyz}Â»` into its parts with `cases Â«{hyz}Â» with b hb`.":
 "ç°åœ¨ `Â«{ha}Â»` æ˜¯ `Â«{y}Â» = Â«{x}Â» + Â«{a}Â»`, çš„è¯æ˜ï¼Œè€Œ `hxy` å·²ç»æ¶ˆå¤±äº†ã€‚åŒæ ·ï¼Œä½ å¯ä»¥é€šè¿‡ `cases Â«{hyz}Â» with b hb` å°† `Â«{hyz}Â»` åˆ†è§£ã€‚",
 "Now `rw [â† two_eq_succ_one]` will change `succ 1` into `2`.":
 "ç°åœ¨ `rw [â† two_eq_succ_one]` ä¼šæŠŠ `succ 1` æ”¹ä¸º `2`ã€‚",
 "Now `rw [h]` then `rfl` works, but `exact h` is quicker.":
 "ç°åœ¨ `rw [h]` å’Œ `rfl` å¯ä»¥å®Œæˆè¯æ˜ï¼Œä½† `exact h` æ›´å¿«ã€‚",
 "Now `rw [h] at h2` so you can `apply le_one at hx`.":
 "ç°åœ¨`rw [h] at h2`ï¼Œè¿™æ ·å°±å¯ä»¥`apply le_one at hx`ã€‚",
 "Now `rw [add_zero]` will change `c + 0` into `c`.":
 "ç°åœ¨ï¼Œ`rw [add_zero]` ä¼šæŠŠ `c + 0` æ”¹ä¸º `c`ã€‚",
 "Now `rfl` will work.": "ç°åœ¨å¯ä»¥ç”¨ `rfl` äº†ã€‚",
 "Now `repeat rw [â† succ_eq_add_one] at h` is the quickest way to\nchange `succ x = succ y`.":
 "ç°åœ¨ `repeat rw [â† succ_eq_add_one] at h` æ˜¯æ”¹å†™ `succ x = succ y` çš„æœ€å¿«æ–¹æ³•ã€‚",
 "Now `exact h` finishes the job.": "ç°åœ¨ï¼Œç”¨ `exact h ` å®Œæˆè¯æ˜ã€‚",
 "Now `cases Â«{h2}Â» with e he`.": "ç°åœ¨ä½¿ç”¨ `cases Â«{h2}Â» with e he`ã€‚",
 "Now `cases h2 with h0 h1` and deal with the two\ncases separately.":
 "ç°åœ¨ä½¿ç”¨ `cases h2 with h0 h1` aï¼Œå¹¶åˆ†ç±»è®¨è®ºè¿™ä¸¤ç§æƒ…å†µã€‚",
 "Now `apply succ_inj at h` to cancel the `succ`s.":
 "ç°åœ¨ä½¿ç”¨ `apply succ_inj at h` æ¥æ¶ˆå» `succ`ã€‚",
 "Now `apply h` and you can probably take it from here.":
 "ç°åœ¨ä½¿ç”¨ `apply h`ï¼Œä½ ä¹Ÿè®¸å¯ä»¥ä»è¿™é‡Œå¼€å§‹è¯æ˜ã€‚",
 "Note: this lemma will be useful for the final boss!":
 "æ³¨æ„ï¼šè¿™ä¸ªå¼•ç†å¯¹äºè§£å†³æœ€ç»ˆçš„ Boss å¾ˆæœ‰ç”¨ï¼",
 "Note that you can do `rw [two_eq_succ_one, one_eq_succ_zero]`\nand then `rfl` to solve this level in two lines.":
 "è¯·æ³¨æ„ï¼Œæ‚¨å¯ä»¥å…ˆä½¿ç”¨ `rw [two_eq_succ_one, one_eq_succ_zero]`\nç„¶åå†ç”¨ `rfl` æ¥å¿«é€Ÿé€šè¿‡è¿™å…³ã€‚",
 "Note that `succ a + Â«{d}Â»` means `(succ a) + Â«{d}Â»`. Put your cursor\non any `succ` in the goal or assumptions to see what exactly it's eating.":
 "è¯·æ³¨æ„ï¼Œ`succ a + Â«{d}Â»` çš„æ„æ€æ˜¯ `(succ a) + Â«{d}Â»`ã€‚å°†ä½ çš„å…‰æ ‡æ”¾åœ¨ç›®æ ‡æˆ–å‡è®¾ä¸­çš„ä»»ä½• `succ` ä¸Šï¼Œä»¥æŸ¥çœ‹å®ƒç¡®åˆ‡çš„å«ä¹‰ã€‚",
 "Nice! You've proved `succ_inj`!\nLet's now prove Peano's other axiom, that successors can't be $0$.":
 "å¥½çš„ï¼æ‚¨å·²ç»è¯æ˜äº† `succ_inj`ï¼\nç°åœ¨è®©æˆ‘ä»¬è¯æ˜çš®äºšè¯ºçš„å¦ä¸€ä¸ªå…¬ç†ï¼Œåç»§æ•°ä¸å¯èƒ½æ˜¯ $0$ã€‚",
 "Nice!\n\nThe next step in the development of order theory is to develop\nthe theory of the interplay between `â‰¤` and multiplication.\nIf you've already done Multiplication World, you're now ready for\nAdvanced Multiplication World. Click on \"Leave World\" to access it.":
 "å¾ˆæ£’ï¼\n\nå‘å±•åºç†è®ºçš„ä¸‹ä¸€æ­¥æ˜¯å‘å±• `â‰¤` ä¸ä¹˜æ³•ä¹‹é—´ç›¸äº’ä½œç”¨çš„ç†è®ºã€‚\nå¦‚æœä½ å·²ç»å®Œæˆäº†ä¹˜æ³•ä¸–ç•Œï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›å…¥é«˜çº§ä¹˜æ³•ä¸–ç•Œã€‚ç‚¹å‡» \"ç¦»å¼€ä¸–ç•Œ \"è¿›å…¥ã€‚",
 "Nice!": "å¥½çš„ï¼",
 "Next turn `1` into `succ 0` with `rw [one_eq_succ_zero]`.":
 "æ¥ä¸‹æ¥ç”¨ `rw [one_eq_succ_zero]` æŠŠ `1` å˜æˆ `succ 0'ã€‚",
 "Natural Number Game": "è‡ªç„¶æ•°æ¸¸æˆ",
 "My proof:\n```\ncases h with d hd\nuse d * t\nrw [hd, add_mul]\nrfl\n```":
 "æˆ‘çš„è¯æ˜ï¼š\n```\ncases h with d hd\nuse d * t\nrw [hd, add_mul]\nrfl\n```",
 "Multiplication usually makes a number bigger, but multiplication by zero can make\nit smaller. Thus many lemmas about inequalities and multiplication need the\nhypothesis `a â‰  0`. Here is a key lemma enables us to use this hypothesis.\nTo help us with the proof, we can use the `tauto` tactic. Click on the tactic's name\non the right to see what it does.":
 "ä¹˜æ³•é€šå¸¸ä¼šä½¿ä¸€ä¸ªæ•°å­—å˜å¤§ï¼Œä½†æ˜¯ä¹˜ä»¥é›¶å¯ä»¥ä½¿å®ƒå˜å°ã€‚å› æ­¤ï¼Œå…³äºä¸ç­‰å¼å’Œä¹˜æ³•çš„è®¸å¤šå¼•ç†éœ€è¦å‡è®¾ `a â‰  0`ã€‚\nè¿™é‡Œæœ‰ä¸€ä¸ªå…³é”®çš„å¼•ç†ä½¿æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨è¿™ä¸ªå‡è®¾ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `tauto` ç­–ç•¥å¸®åŠ©æˆ‘ä»¬è¿›è¡Œè¯æ˜ã€‚ç‚¹å‡»å³ä¾§çš„ç­–ç•¥åç§°æŸ¥çœ‹å®ƒçš„ä½œç”¨ã€‚",
 "Multiplication is distributive over addition on the left.\nIn other words, for all natural numbers $a$, $b$ and $c$, we have\n$a(b + c) = ab + ac$.":
 "ä¹˜æ³•å¯¹å·¦è¾¹çš„åŠ æ³•å…·æœ‰åˆ†é…æ€§ã€‚\næ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œæˆ‘ä»¬æœ‰\n$a(b + c) = ab + ac$ã€‚",
 "Multiplication is commutative.": "ä¹˜æ³•æ˜¯å¯äº¤æ¢çš„ã€‚",
 "Multiplication is associative.\nIn other words, for all natural numbers $a$, $b$ and $c$, we have\n$(ab)c = a(bc)$.":
 "ä¹˜æ³•æœä»ç»“åˆå¾‹ã€‚\næ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œæˆ‘ä»¬æœ‰\n$(ab)c = a(bc)$ã€‚",
 "Multiplication distributes\nover addition on the left.\n\n`mul_add a b c` is the proof that `a * (b + c) = a * b + a * c`.":
 "ä¹˜æ³•åœ¨å·¦ä¾§å¯¹åŠ æ³•å…·æœ‰åˆ†é…æ€§ã€‚\n\n`mul_add a b c` æ˜¯ `a * (b + c) = a * b + a * c` çš„è¯æ˜ã€‚",
 "Multiplication World": "ä¹˜æ³•ä¸–ç•Œ",
 "Mathematicians sometimes debate what `0 ^ 0` is;\nthe answer depends, of course, on your definitions. In this\ngame, `0 ^ 0 = 1`. See if you can prove it.\n\nCheck out the *Pow* tab in your list of theorems\nto see the new proofs which are available.":
 "æ•°å­¦å®¶ä»¬æœ‰æ—¶ä¼šäº‰è®º `0 ^ 0` æ˜¯ä»€ä¹ˆï¼›\nç­”æ¡ˆå½“ç„¶å–å†³äºä½ çš„å®šä¹‰ã€‚åœ¨è¿™ä¸ª\næ¸¸æˆä¸­ï¼Œ`0 ^ 0 = 1`ã€‚çœ‹çœ‹ä½ èƒ½å¦è¯æ˜è¿™ä¸€ç‚¹ã€‚\n\næŸ¥çœ‹å®šç†åˆ—è¡¨ä¸­çš„ *Pow* é€‰é¡¹å¡\næ ‡ç­¾ï¼ŒæŸ¥çœ‹å¯ç”¨çš„æ–°è¯æ˜ã€‚",
 "Mathematicians sometimes argue that `0 ^ 0 = 0` is also\na good convention. But it is not a good convention in this\ngame; all the later levels come out beautifully with the\nconvention that `0 ^ 0 = 1`.":
 "æ•°å­¦å®¶æœ‰æ—¶ä¼šäº‰è®ºè¯´ 0 ^ 0 = 0 ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„çº¦å®šã€‚\nä½†åœ¨æœ¬æ¸¸æˆä¸­ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¥½çš„çº¦å®šï¼›æ‰€æœ‰åé¢çš„å…³å¡ä¹Ÿå…¨éƒ½éµå¾ª 0 ^ 0 = 1 çš„çº¦å®šã€‚",
 "Many people find `apply t at h` easy, but some find `apply t` confusing.\nIf you find it confusing, then just argue forwards.\n\nYou can read more about the `apply` tactic in its documentation, which you can view by\nclicking on the tactic in the list on the right.":
 "è®¸å¤šäººè§‰å¾— `apply t at h` å¾ˆå®¹æ˜“ï¼Œä½†æœ‰äº›äººè§‰å¾— `apply t` ä»¤äººå›°æƒ‘ã€‚\nå¦‚æœä½ è§‰å¾—å¾ˆå›°æƒ‘ï¼Œé‚£å°±ç”¨å‰ä¸€ç§å§ã€‚\n\næ‚¨å¯ä»¥åœ¨å…¶æ–‡æ¡£ä¸­é˜…è¯»æœ‰å…³ `apply` ç­–ç•¥çš„æ›´å¤šä¿¡æ¯ï¼Œæ‚¨å¯ä»¥é€šè¿‡\nå•å‡»å³ä¾§åˆ—è¡¨ä¸­çš„ç­–ç•¥çš„æ–¹å¼æŸ¥çœ‹ã€‚",
 "Let's warm up with an easy one, which works even if `t = 0`.":
 "è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„é—®é¢˜æ¥çƒ­çƒ­èº«ï¼Œå³ä½¿ `t = 0` ä¹Ÿå¯ä»¥ã€‚",
 "Let's see if you can use the tactics we've learnt to prove $x+1=y+1\\implies x=y$.\nTry this one by yourself; if you need help then click on \"Show more help!\".":
 "è®©æˆ‘ä»¬çœ‹çœ‹æ‚¨èƒ½å¦åˆ©ç”¨æˆ‘ä»¬å­¦åˆ°çš„ç­–ç•¥æ¥è¯æ˜ $x+1=y+1\\implies x=y$ã€‚\nå¦‚æœæ‚¨éœ€è¦å¸®åŠ©ï¼Œè¯·ç‚¹å‡» \"æ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼\"ã€‚",
 "Let's now move on to a more efficient approach to questions\ninvolving numerals, such as `20 + 20 = 40`.":
 "ç°åœ¨è®©æˆ‘ä»¬è½¬å‘æ›´æœ‰æ•ˆçš„\næ¶‰åŠæ•°å­—é—®é¢˜çš„æ–¹æ³•ï¼Œä¾‹å¦‚è¯æ˜ `20 + 20 = 40`ã€‚",
 "Let's now make our own tactic to do this.": "ç°åœ¨è®©æˆ‘ä»¬åˆ¶å®šè‡ªå·±çš„ç­–ç•¥æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚",
 "Let's now learn about Peano's second axiom for addition, `add_succ`.":
 "ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å­¦ä¹ çš®äºšè¯ºåŠ æ³•çš„ç¬¬äºŒæ¡å…¬ç†â€”â€”`add_succ`ã€‚",
 "Let's now begin our approach to the final boss,\nby proving some more subtle facts about powers.":
 "ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹é€šè¿‡è¯æ˜ä¸€äº›å…³äºå¹‚çš„æ›´å¾®å¦™çš„äº‹å®æ¥æ¥è¿‘æœ€ç»ˆçš„bossã€‚",
 "Let's first get `h` into the form `succ x = succ 3` so we can\napply `succ_inj`. First execute `rw [four_eq_succ_three] at h`\nto change the 4 on the right hand side.":
 "é¦–å…ˆè®© `h` å˜ä¸º `succ x = succ 3` çš„å½¢å¼ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åº”ç”¨ `succ_inj`ã€‚é¦–å…ˆæ‰§è¡Œ `rw [four_eq_succ_three] at h` æ¥æ”¹å˜å³æ‰‹è¾¹çš„4ã€‚",
 "Lean's simplifier, `simp`, is \"`rw` on steroids\". It will rewrite every lemma\ntagged with `simp` and every lemma fed to it by the user, as much as it can.\n\nThis level is not a level which you want to solve by hand.\nGet the simplifier to solve it for you.":
 "Lean çš„ç®€åŒ–å™¨ `simp` æ˜¯åŠ å¼ºç‰ˆçš„ `rw` ã€‚å®ƒå°†ç”¨æ¯ä¸ªç”¨æˆ·æä¾›ç»™å®ƒçš„å¼•ç†\nä»¥åŠæ‰€æœ‰æ ‡è®°ä¸º `simp` çš„å¼•ç†é‡å†™ç›®æ ‡ã€‚\n\nè¿™ä¸ªå…³å¡ä¸æ˜¯èƒ½è½»æ¾æ‰‹åŠ¨è§£å†³çš„å…³å¡ã€‚\nä½¿ç”¨ç®€åŒ–å™¨æ¥ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ã€‚",
 "It's all over! You have proved a theorem which has tripped up\nschoolkids for generations (some of them think $(a+b)^2=a^2+b^2$:\nthis is \"the freshman's dream\").\n\nHow many rewrites did you use? I can do it in 12.\n\nBut wait! This boss is stirring...and mutating into a second more powerful form!":
 "ä¸€åˆ‡éƒ½ç»“æŸäº†ï¼ä½ å·²ç»è¯æ˜äº†ä¸€ä¸ªå›°æ‰°äº†å‡ ä»£å­¦ç”Ÿçš„å®šç†\nï¼ˆä»–ä»¬ä¸­çš„ä¸€äº›äººè®¤ä¸º $(a+b)^2=a^2+b^2$ ï¼šè¿™å°±æ˜¯â€œæ–°ç”Ÿçš„é”™è§‰â€ï¼‰ã€‚\n\nä½ ç”¨äº†å¤šå°‘æ¬¡é‡å†™ï¼Ÿæˆ‘å¯ä»¥ç”¨12æ¬¡åšåˆ°ã€‚\n\nä½†ç­‰ç­‰ï¼è¿™ä¸ªBossè¢«æ¿€æ€’äº†â€¦â€¦å¹¶ä¸”å˜å¼‚æˆç¬¬äºŒç§æ›´å¼ºå¤§çš„å½¢å¼ï¼",
 "It's \"intuitively obvious\" that there are no numbers less than zero,\nbut to prove it you will need a result which you showed in advanced\naddition world.":
 "æ²¡æœ‰å°äºé›¶çš„æ•°ï¼Œè¿™æ˜¯ \"ç›´è§‰ä¸Šæ˜¾è€Œæ˜“è§çš„\"ã€\nä½†æ˜¯åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œè¦ä½ éœ€è¦è¯æ˜è¿™ä¸€ç‚¹ã€‚",
 "Induction on `a` will not work here. You are still stuck with an `+ b`.\nI suggest you delete this line and try a different approach.":
 "å¯¹ `a` çš„å½’çº³åœ¨è¿™é‡Œä¸èµ·ä½œç”¨ã€‚ä½ ä»ç„¶å¡åœ¨ `+ b` ä¸Šã€‚\næˆ‘å»ºè®®ä½ åˆ é™¤è¿™ä¸€è¡Œï¼Œæ¢ä¸€ç§æ–¹æ³•ã€‚",
 "Induction on `a` or `b` -- it's all the same in this one.":
 "å¯¹ `a` æˆ– `b` è¿›è¡Œå½’çº³è¯æ˜ â€”â€” å®ƒä»¬éƒ½æ˜¯ç›¸åŒçš„ã€‚",
 "Induction on `a` is the most troublesome, then `b`,\nand `c` is the easiest.":
 "å¯¹ `a` çš„å½’çº³æœ€éº»çƒ¦ï¼Œç„¶åæ˜¯ `b`ã€\nè€Œ `c` æ˜¯æœ€ç®€å•çš„ã€‚",
 "In this world we'll learn how to prove theorems of the form $P\\implies Q$.\nIn other words, how to prove theorems of the form \"if $P$ is true, then $Q$ is true.\"\nTo do that we need to learn some more tactics.\n\nThe `exact` tactic can be used to close a goal which is exactly one of\nthe hypotheses.":
 "åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è¯æ˜å½¢å¼ä¸º $P\\implies Q$ çš„å®šç†ã€‚\næ¢å¥è¯è¯´ï¼Œå°±æ˜¯å¦‚ä½•è¯æ˜â€œå¦‚æœ $P$ ä¸ºçœŸï¼Œåˆ™ $Q$ ä¹Ÿä¸ºçœŸâ€çš„å½¢å¼çš„å®šç†ã€‚\nä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å­¦ä¹ ä¸€äº›æ›´å¤šçš„ç­–ç•¥ã€‚\n\n`exact` ç­–ç•¥å¯ä»¥ç”¨æ¥è§£å†³ä¸€ä¸ªå­˜åœ¨äºå‡è®¾ä¸­çš„ç›®æ ‡ã€‚",
 "In this world we define `a â‰¤ b` and prove standard facts\nabout it, such as \"if `a â‰¤ b` and `b â‰¤ c` then `a â‰¤ c`.\"\n\nThe definition of `a â‰¤ b` is \"there exists a number `c`\nsuch that `b = a + c`. \" So we're going to have to learn\na tactic to prove \"exists\" theorems, and another one\nto use \"exists\" hypotheses.\n\nClick on \"Start\" to proceed.":
 "åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å®šä¹‰ `a â‰¤ b` å¹¶è¯æ˜å…³äºå®ƒçš„ä¸€äº›äº‹å®ï¼Œä¾‹å¦‚â€œå¦‚æœ `a â‰¤ b` ä¸” `b â‰¤ c` é‚£ä¹ˆ `a â‰¤ c`ã€‚â€\n\n`a â‰¤ b` çš„å®šä¹‰æ˜¯â€œå­˜åœ¨ä¸€ä¸ªæ•°å­— `c` ä½¿å¾— `b = a + c`ã€‚â€æ‰€ä»¥æˆ‘ä»¬å°†ä¸å¾—ä¸å­¦ä¹ ä¸€ç§ç­–ç•¥æ¥è¯æ˜â€œå­˜åœ¨â€å®šç†ï¼Œä»¥åŠå¦ä¸€ç§ç­–ç•¥æ¥ä½¿ç”¨â€œå­˜åœ¨â€å‡è®¾ã€‚\n\nç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚",
 "In this world I will mostly leave you on your own.\n\n`add_right_cancel a b n` is the theorem that $a+n=b+n\\implies a=b$.":
 "åœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæ¢é™©å°†ä¸»è¦ç”±æ‚¨ç‹¬è‡ªå®Œæˆã€‚\n\n`add_right_cancel a b n` æ˜¯å®šç† $a+n=b+n\\implies a=b$ã€‚",
 "In this level, we see inequalities as *hypotheses*. We have not seen this before.\nThe `cases` tactic can be used to take `hxy` apart.":
 "åœ¨æœ¬å…³ï¼Œæˆ‘ä»¬å°†ä¸ç­‰è§†ä¸º *å‡è®¾* ã€‚æˆ‘ä»¬ä»¥å‰æ²¡æœ‰è§è¿‡è¿™ä¸ªã€‚\n`cases` ç­–ç•¥å¯ç”¨äºæ‹†è§£ `hxy` å‡è®¾ã€‚",
 "In this level we're going to prove that $0+n=n$, where $n$ is a secret natural number.\n\nWait, don't we already know that? No! We know that $n+0=n$, but that's `add_zero`.\nThis is `zero_add`, which is different.\n\nThe difficulty with proving `0 + n = n` is that we do not have a *formula* for\n`0 + n` in general, we can only use `add_zero` and `add_succ` once\nwe know whether `n` is `0` or a successor. The `induction` tactic splits into these two cases.\n\nThe base case will require us to prove `0 + 0 = 0`, and the inductive step\nwill ask us to show that if `0 + d = d` then `0 + succ d = succ d`. Because\n`0` and successor are the only way to make numbers, this will cover all the cases.\n\nSee if you can do your first induction proof in Lean.\n\n(By the way, if you are still in the \"Editor mode\" from the last world, you can swap\nback to \"Typewriter mode\" by clicking the `>_` button in the top right.)":
 "åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ $0+n=n$ï¼Œå…¶ä¸­ $n$ æ˜¯ä¸€ä¸ªæœªçŸ¥çš„è‡ªç„¶æ•°ã€‚\n\nç­‰ç­‰ï¼Œæˆ‘ä»¬ä¸æ˜¯å·²ç»çŸ¥é“è¿™ä¸ªäº†å—ï¼Ÿä¸ï¼æˆ‘ä»¬çŸ¥é“çš„æ˜¯ $n+0=n$ï¼Œä½†é‚£æ˜¯ `add_zero`ã€‚è¿™é‡Œçš„ `zero_add` æ˜¯ä¸åŒçš„ã€‚\n\nè¯æ˜ `0 + n = n` çš„éš¾ç‚¹åœ¨äºæˆ‘ä»¬æ²¡æœ‰ä¸€ä¸ªä¸€èˆ¬çš„*å…¬å¼*æ¥è¡¨ç¤º `0 + n`ï¼Œæˆ‘ä»¬åªèƒ½åœ¨çŸ¥é“ `n` æ˜¯ `0` è¿˜æ˜¯åç»§æ•°åï¼Œä½¿ç”¨ `add_zero` å’Œ `add_succ`ã€‚`induction` ï¼ˆå½’çº³ï¼‰ç­–ç•¥ä¼šæŠŠç›®æ ‡åˆ†è§£æˆè¿™ä¸¤ç§æƒ…å†µã€‚\n\nåŸºç¡€æƒ…å†µå°†è¦æ±‚æˆ‘ä»¬è¯æ˜ `0 + 0 = 0`ï¼Œå½’çº³æ­¥éª¤å°†è¦æ±‚æˆ‘ä»¬è¯æ˜å¦‚æœ `0 + d = d` é‚£ä¹ˆ `0 + succ d = succ d`ã€‚å› ä¸º `0` å’Œåç»§æ•°æ˜¯æ„é€ æ•°å­—çš„å”¯ä¸€æ–¹å¼ï¼Œè¿™å°†æ¶µç›–æ‰€æœ‰æƒ…å†µã€‚\n\nçœ‹çœ‹ä½ æ˜¯å¦èƒ½åœ¨ Lean ä¸­å®Œæˆä½ çš„ç¬¬ä¸€ä¸ªå½’çº³è¯æ˜ã€‚\n\n(é¡ºä¾¿è¯´ä¸€å¥ï¼Œå¦‚æœä½ è¿˜åœ¨ä¸Šä¸€ä¸ªä¸–ç•Œçš„ \"ç¼–è¾‘å™¨æ¨¡å¼ \"ä¸‹ï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡» \"ç¼–è¾‘å™¨æ¨¡å¼ \"ä¸‹çš„\nç‚¹å‡»å³ä¸Šè§’çš„ `>_` æŒ‰é’®æ¢å› \"æ¨¡å¼\"ï¼‰ã€‚",
 "In this level we prove that if `a * b = a * c` and `a â‰  0` then `b = c`. It is tricky, for\nseveral reasons. One of these is that\nwe need to introduce a new idea: we will need to understand the concept of\nmathematical induction a little better.\n\nStarting with `induction b with d hd` is too naive, because in the inductive step\nthe hypothesis is `a * d = a * c â†’ d = c` but what we know is `a * succ d = a * c`,\nso the induction hypothesis does not apply!\n\nAssume `a â‰  0` is fixed. The actual statement we want to prove by induction on `b` is\n\"for all `c`, if `a * b = a * c` then `b = c`. This *can* be proved by induction,\nbecause we now have the flexibility to change `c`.\"":
 "åœ¨è¿™ä¸ªå…³å¡ä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†å¦‚æœ `a * b = a * c` ä¸” `a â‰  0` é‚£ä¹ˆ `b = c`ã€‚è¿™æ˜¯æœ‰äº›éš¾çš„ï¼Œå› ä¸ºå‡ ä¸ªåŸå› ã€‚å…¶ä¸­ä¹‹ä¸€æ˜¯æˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªæ–°çš„æƒ³æ³•ï¼šæˆ‘ä»¬éœ€è¦æ›´å¥½åœ°ç†è§£æ•°å­¦å½’çº³æ³•çš„æ¦‚å¿µã€‚\n\nä» `induction b with d hd` å¼€å§‹å¤ªå¤©çœŸäº†ï¼Œå› ä¸ºåœ¨å½’çº³æ­¥éª¤ä¸­ï¼Œå‡è®¾æ˜¯ `a * d = a * c â†’ d = c`ï¼Œä½†æˆ‘ä»¬æ‰€çŸ¥çš„æ˜¯ `a * succ d = a * c`ï¼Œæ‰€ä»¥å½’çº³å‡è®¾ä¸é€‚ç”¨ï¼\n\nç°åœ¨å‡è®¾ `a â‰  0` æ˜¯å›ºå®šçš„ã€‚æˆ‘ä»¬æƒ³è¦é€šè¿‡å¯¹ `b` è¿›è¡Œå½’çº³æ¥è¯æ˜â€œå¯¹äºæ‰€æœ‰çš„ `c`ï¼Œå¦‚æœ `a * b = a * c` é‚£ä¹ˆ `b = c`ã€‚è¿™*å¯ä»¥*é€šè¿‡å½’çº³æ¥è¯æ˜ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨æœ‰äº†æ”¹å˜ `c` çš„çµæ´»æ€§ã€‚â€",
 "In this level the *goal* is $2y=2(x+7)$ but to help us we\nhave an *assumption* `h` saying that $y = x + 7$. Check that you can see `h` in\nyour list of assumptions. Lean thinks of `h` as being a secret proof of the\nassumption, rather like `x` is a secret number.\n\nBefore we can use `rfl`, we have to \"substitute in for $y$\".\nWe do this in Lean by *rewriting* the proof `h`,\nusing the `rw` tactic.":
 "åœ¨è¿™ä¸ªå…³å¡é‡Œï¼Œ*ç›®æ ‡*æ˜¯è¯æ˜ $2y=2(x+7)$ã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€æ¡*å‡è®¾* `h`ï¼Œå®ƒæŒ‡å‡º $y = x + 7$ã€‚è¯·æ£€æŸ¥å‡è®¾åˆ—è¡¨ä¸­æ˜¯å¦åŒ…å«äº† `h`ã€‚åœ¨ Lean ä¸­ï¼Œ`h` è¢«è§†ä¸ºä¸€ç§å‡è®¾å­˜åœ¨çš„è¯æ®ï¼Œè¿™æœ‰ç‚¹åƒ `x` æ˜¯ä¸€ä¸ªæœªçŸ¥çš„å…·ä½“æ•°å€¼ã€‚\n\nè¦æƒ³ä½¿ç”¨ `rfl` å®Œæˆè¯æ˜ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å¯¹ $y$ è¿›è¡Œæ›¿æ¢ã€‚åœ¨ Lean ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡*é‡å†™*è¯æ˜ `h` æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œå³ä½¿ç”¨ `rw` ç­–ç•¥ã€‚",
 "In this level one of our hypotheses is an *implication*. We can use this\nhypothesis with the `apply` tactic.":
 "åœ¨è¿™ä¸ªå±‚çº§ä¸­ï¼Œæˆ‘ä»¬çš„ä¸€ä¸ªå‡è®¾æ˜¯ä¸€ä¸ª*è•´å«å¼*ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `apply` ç­–ç•¥æ¥åˆ©ç”¨è¿™ä¸ªå‡è®¾ã€‚",
 "In this game you recreate the natural numbers $\\mathbb{N}$ from the Peano axioms,\nlearning the basics about theorem proving in Lean.\n\nThis is a good first introduction to Lean!":
 "åœ¨è¿™ä¸ªæ¸¸æˆä¸­ï¼Œä½ å°†æ ¹æ®çš®äºšè¯ºå…¬ç†é‡æ–°æ„å»ºè‡ªç„¶æ•°é›† $\\mathbb{N}$ï¼Œå­¦ä¹ åœ¨ Lean ä¸­è¯æ˜å®šç†çš„åŸºç¡€çŸ¥è¯†ã€‚\n\nè¿™æ˜¯å¯¹ Lean çš„ä¸€ä¸ªå¾ˆå¥½çš„åˆæ­¥ä»‹ç»ï¼",
 "In the next level, we'll do the same proof but backwards.":
 "åœ¨ä¸‹ä¸€çº§åˆ«ä¸­ï¼Œæˆ‘ä»¬å°†è¿›è¡Œç›¸åŒçš„è¯æ˜ï¼Œä½†è¦ä»åå¾€å‰è¯ã€‚",
 "In the last level, we manipulated the hypothesis `x + 1 = 4`\n  until it became the goal `x = 3`. In this level we'll manipulate\n  the goal until it becomes our hypothesis! In other words, we\n  will \"argue backwards\". The `apply` tactic can do this too.\n  Again I will walk you through this one (assuming you're in\n  command line mode).":
 "åœ¨æœ€åä¸€å…³ï¼Œæˆ‘ä»¬æ“çºµäº†å‡è®¾ `x + 1 = 4`\n  ç›´åˆ°æˆä¸ºç›®æ ‡ `x = 3` ã€‚åœ¨è¿™ä¸€å…³æˆ‘ä»¬å°†æ”¹å†™\n  ç›®æ ‡ï¼Œç›´åˆ°å®ƒæˆä¸ºæˆ‘ä»¬çš„å‡è®¾ï¼æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬\n  ä¼šâ€œä»åå‘å‰â€è¯æ˜ã€‚ `apply` ç­–ç•¥ä¹Ÿå¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ã€‚\n  æˆ‘å°†å†æ¬¡å¼•å¯¼æ‚¨å®Œæˆè¿™ä¸€è¿‡ç¨‹ï¼ˆå‡è®¾æ‚¨åœ¨\n  å‘½ä»¤è¡Œæ¨¡å¼ï¼‰ã€‚",
 "In the \"base case\" we have a hypothesis `ha : 0 â‰  0`, and you can deduce anything\nfrom a false statement. The `tauto` tactic will close this goal.":
 "åœ¨â€œåŸºç¡€æƒ…å½¢â€ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå‡è®¾ `ha : 0 â‰  0`ï¼Œä½ å¯ä»¥ä»ä¸€ä¸ªå‡å‘½é¢˜ä¸­æ¨å¯¼å‡ºä»»ä½•ä¸œè¥¿ã€‚`tauto` ç­–ç•¥å°†è¯æ˜è¿™ä¸ªç›®æ ‡ã€‚",
 "In some later worlds, we're going to see some much nastier levels,\nlike `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`.\nBrackets need to be moved around, and variables need to be swapped.\n\nIn this level, `(a + b) + (c + d) = ((a + c) + d) + b`,\nlet's forget about the brackets and just think about\nthe variable order.\nTo turn `a+b+c+d` into `a+c+d+b` we need to swap `b` and `c`,\nand then swap `b` and `d`. But this is easier than you\nthink with `add_left_comm`.":
 "åœ¨ä¸€äº›åç»­çš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ä¸€äº›æ›´æ£˜æ‰‹çš„å±‚çº§ï¼Œæ¯”å¦‚ `(a + a + 1) + (b + b + 1) = (a + b + 1) + (a + b + 1)`ã€‚éœ€è¦ç§»åŠ¨æ‹¬å·ï¼Œè¿˜éœ€è¦äº¤æ¢å˜é‡ã€‚\n\nåœ¨è¿™ä¸ªå±‚çº§ä¸­ï¼Œ`(a + b) + (c + d) = ((a + c) + d) + b`ï¼Œè®©æˆ‘ä»¬å¿˜æ‰æ‹¬å·ï¼Œåªè€ƒè™‘å˜é‡çš„é¡ºåºã€‚\nè¦å°† `a+b+c+d` è½¬æ¢æˆ `a+c+d+b`ï¼Œæˆ‘ä»¬éœ€è¦äº¤æ¢ `b` å’Œ `c`ï¼Œç„¶åäº¤æ¢ `b` å’Œ `d`ã€‚ä½†æ˜¯ä½¿ç”¨ `add_left_comm` æ¯”ä½ æƒ³è±¡çš„è¦ç®€å•ã€‚",
 "In order to use the tactic `rfl` you can enter it in the text box\nunder the goal and hit \"Execute\".":
 "è¦ä½¿ç”¨ç­–ç•¥ \"rfl\"ï¼Œæ‚¨å¯ä»¥åœ¨ç›®æ ‡ä¸‹çš„æ–‡æœ¬æ¡†ä¸­è¾“å…¥å®ƒï¼Œç„¶åç‚¹å‡» \"æ‰§è¡Œ\"ã€‚",
 "In Prime Number World we will be proving that $2$ is prime.\nTo do this, we will have to rule out things like $2 â‰  37 Ã— 42.$\nWe will do this by proving that any factor of $2$ is at most $2$,\nwhich we will do using this lemma. The proof I have in mind manipulates the hypothesis\nuntil it becomes the goal, using pretty much everything which we've proved in this world so far.":
 "åœ¨è´¨æ•°ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ $2$ æ˜¯è´¨æ•°ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¿…é¡»æ’é™¤åƒ $2 â‰  37 Ã— 42$ è¿™æ ·çš„æƒ…å†µã€‚\næˆ‘ä»¬å°†é€šè¿‡è¯æ˜ $2$ çš„ä»»ä½•å› æ•°æœ€å¤šæ˜¯ $2$ æ¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªå¼•ç†æ¥å®ç°ã€‚\næˆ‘è„‘æµ·ä¸­çš„è¯æ˜ä¼šæ“ä½œå‡è®¾ï¼Œç›´åˆ°å®ƒå˜æˆç›®æ ‡ï¼Œå‡ ä¹ä½¿ç”¨æˆ‘ä»¬åˆ°ç›®å‰ä¸ºæ­¢åœ¨è¿™ä¸ªä¸–ç•Œä¸­å·²ç»è¯æ˜çš„æ‰€æœ‰å†…å®¹ã€‚",
 "In Advanced Addition World we will prove some basic\naddition facts such as $x+y=x\\implies y=0$. The theorems\nproved in this world will be used to build\na theory of inequalities in `â‰¤` World.\n\nClick on \"Start\" to proceed.":
 "åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬å°†è¯æ˜ä¸€äº›åŸºæœ¬çš„åŠ æ³•äº‹å®ï¼Œå¦‚ $x+y=x\\implies y=0$ã€‚åœ¨è¿™ä¸ªä¸–ç•Œä¸­è¯æ˜çš„å®šç†å°†è¢«ç”¨æ¥åœ¨ `â‰¤` ä¸–ç•Œä¸­æ„å»ºä¸ç­‰å¼ç†è®ºã€‚\n\nç‚¹å‡»â€œå¼€å§‹â€ç»§ç»­ã€‚",
 "Implication World": "è•´å«ä¸–ç•Œ",
 "Implementing the algorithm for equality of naturals, and the proof that it is correct,\nlooks like this:\n\n```\ninstance instDecidableEq : DecidableEq â„•\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m â‰  0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 â‰  succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m â‰  n) => isFalse <| by\n    show succ m â‰  succ n\n    exact succ_ne_succ m n h\n```\n\nThis Lean code is a formally verified algorithm for deciding equality\nbetween two naturals. I've typed it in already, behind the scenes.\nBecause the algorithm is formally verified to be correct, we can\nuse it in Lean proofs. You can run the algorithm with the `decide` tactic.":
 "å®ç°è‡ªç„¶æ•°ç­‰å¼çš„ç®—æ³•ï¼Œä»¥åŠè¯æ˜å®ƒæ˜¯æ­£ç¡®çš„ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·ï¼š\n\n```\ninstance instDecidableEq : DecidableEq â„•\n| 0, 0 => isTrue <| by\n  show 0 = 0\n  rfl\n| succ m, 0 => isFalse <| by\n  show succ m â‰  0\n  exact succ_ne_zero m\n| 0, succ n => isFalse <| by\n  show 0 â‰  succ n\n  exact zero_ne_succ n\n| succ m, succ n =>\n  match instDecidableEq m n with\n  | isTrue (h : m = n) => isTrue <| by\n    show succ m = succ n\n    rw [h]\n    rfl\n  | isFalse (h : m â‰  n) => isFalse <| by\n    show succ m â‰  succ n\n    exact succ_ne_succ m n h\n```\n\nè¿™æ®µ Lean ä»£ç æ˜¯ä¸€ä¸ªç”¨äºåˆ¤æ–­ä¸¤ä¸ªè‡ªç„¶æ•°ä¹‹é—´ç­‰å¼çš„æ­£å¼éªŒè¯ç®—æ³•ã€‚\næˆ‘å·²ç»åœ¨æ¸¸æˆå¹•åè¾“å…¥äº†å®ƒã€‚å› ä¸ºè¿™ä¸ªç®—æ³•å·²ç»æ­£å¼éªŒè¯ä¸ºæ­£ç¡®ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ Lean è¯æ˜ä¸­ä½¿ç”¨å®ƒã€‚\nä½ å¯ä»¥ç”¨ `decide` ç­–ç•¥è¿è¡Œè¿™ä¸ªç®—æ³•ã€‚",
 "If you have completed Algorithm World then you can use the `contrapose!` tactic\nhere. If not then I'll talk you through a manual approach.":
 "å¦‚æœä½ å·²ç»å®Œæˆäº†ç®—æ³•ä¸–ç•Œï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ `contrapose!` ç­–ç•¥ã€‚\nå¦‚æœæ²¡æœ‰ï¼Œé‚£ä¹ˆæˆ‘ä¼šæŒ‡å¯¼ä½ ä½¿ç”¨ä¸€ç§æ‰‹åŠ¨æ–¹æ³•ã€‚",
 "If you `use` the wrong number, you get stuck with a goal you can't prove.\nWhat number will you `use` here?":
 "å¦‚æœä½ ä½¿ç”¨é”™è¯¯çš„æ•°å­—ï¼Œä½ å°†å¡åœ¨ä¸€ä¸ªæ— æ³•è¯æ˜çš„ç›®æ ‡ä¸­ã€‚\nä½ å°†åœ¨è¿™é‡Œä½¿ç”¨å“ªä¸ªæ•°å­—ï¼Ÿ",
 "If the goal is not *exactly* a hypothesis, we can sometimes\nuse rewrites to fix things up.":
 "å¦‚æœç›®æ ‡å¹¶ä¸ *å®Œå…¨* æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œæˆ‘ä»¬æœ‰æ—¶å¯ä»¥ä½¿ç”¨é‡å†™æ¥è°ƒæ•´ã€‚",
 "If `h` is a proof of `X = Y` then `rw [h]` will\nturn `X`s into `Y`s. But what if we want to\nturn `Y`s into `X`s? To tell the `rw` tactic\nwe want this, we use a left arrow `â†`. Type\n`\\l` and then hit the space bar to get this arrow.\n\nLet's prove that $2$ is the number after the number\nafter $0$ again, this time by changing `succ (succ 0)`\ninto `2`.":
 "å¦‚æœ `h` æ˜¯ `X = Y` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†\n `X` è½¬æ¢ä¸º `Y`sã€‚ä½†å¦‚æœæˆ‘ä»¬æƒ³è¦\nå°† `Y`s è½¬æ¢ä¸º `X`sæ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬ä½¿ç”¨å·¦ç®­å¤´ `â†` æ¥å‘Šè¯‰`rw`ç­–ç•¥\næˆ‘ä»¬æƒ³è¦è¿™ä¸ªã€‚è¾“å…¥\n`\\l` ç„¶åæŒ‰ç©ºæ ¼é”®æ¥è¾“å…¥è¿™ä¸ªç®­å¤´ã€‚\n\næˆ‘ä»¬æ¥è¯æ˜ä¸€ä¸‹ $2$ å°±æ˜¯ $0$ ä¹‹åå†ä¹‹åçš„æ•°å­—ã€‚è¯·å°†`succ (succ 0)`\né‡å†™ä¸º `2`ã€‚",
 "If `a` and `b` are numbers, then `succ_inj a b` is a proof\nthat `succ a = succ b` implies `a = b`. Click on this theorem in the *Peano*\ntab for more information.\n\nPeano had this theorem as an axiom, but in Algorithm World\nwe will show how to prove it in Lean. Right now let's just assume it,\nand let's prove $x+1=4 \\implies x=3$ using it. Again, we will proceed\nby manipulating our hypothesis until it becomes the goal. I will\nwalk you through this level.":
 "å¦‚æœ `a` å’Œ `b` æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ `succ_inj a b` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨æ˜ `succ a = succ b` æ„å‘³ç€ `a = b`ã€‚ç‚¹å‡» *Peano* æ ‡ç­¾ä¸­çš„è¿™ä¸ªå®šç†ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚\n\nçš®äºšè¯ºå°†è¿™ä¸ªå®šç†ä½œä¸ºä¸€ä¸ªå…¬ç†ï¼Œä½†åœ¨ç®—æ³•ä¸–ç•Œä¸­æˆ‘ä»¬å°†å±•ç¤ºå¦‚ä½•åœ¨ Lean ä¸­è¯æ˜å®ƒã€‚\nç°åœ¨è®©æˆ‘ä»¬å…ˆå‡è®¾å®ƒï¼Œç„¶åè®©æˆ‘ä»¬ä½¿ç”¨å®ƒè¯æ˜ $x+1=4 \\implies x=3$ã€‚å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°†é€šè¿‡æ“çºµæˆ‘ä»¬çš„å‡è®¾ç›´åˆ°å®ƒå˜æˆç›®æ ‡æ¥è¿›è¡Œã€‚æˆ‘å°†å¼•å¯¼ä½ é€šè¿‡è¿™ä¸ªå±‚çº§ã€‚",
 "If $x=y$ and $x \\neq y$ then we can deduce a contradiction.":
 "å¦‚æœ $x=y$ ä¸” $x \\neq y$ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨å‡ºçŸ›ç›¾ã€‚",
 "If $x=37$ or $y=42$, then $y=42$ or $x=37$.":
 "å¦‚æœ $x=37$ æˆ– $y=42$ï¼Œé‚£ä¹ˆ $y=42$ æˆ– $x=37$ã€‚",
 "If $x=37$ and we know that $x=37\\implies y=42$ then we can deduce $y=42$.":
 "å¦‚æœ $x=37$ å¹¶ä¸”æˆ‘ä»¬çŸ¥é“ $x=37 \\implies y=42$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨å¯¼å‡º $y=42$ã€‚",
 "If $x+1=4$ then $x=3$.": "å¦‚æœ $x+1=4$ åˆ™ $x=3$ã€‚",
 "If $x$ is a number, then $x \\le x$.": "å¦‚æœ $x$ æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ $x \\le x$ã€‚",
 "If $x$ is a number, then $x \\le \\operatorname{succ}(x)$.":
 "å¦‚æœ $x$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $x \\le \\operatorname{succ}(x)$ã€‚",
 "If $x$ is a number, then $0 \\le x$.": "å¦‚æœ $x$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $0 \\le x$ã€‚",
 "If $x$ and $y$ are numbers, then either $x \\leq y$ or $y \\leq x$.":
 "å¦‚æœ $x$ å’Œ $y$ æ˜¯è‡ªç„¶æ•°ï¼Œåˆ™ $x \\leq y$ æˆ– $y \\leq x$ã€‚",
 "If $x$ and $y$ are natural numbers, and $y = x + 7$, then $2y = 2(x + 7)$.":
 "å¦‚æœ $x$ å’Œ $y$ æ˜¯è‡ªç„¶æ•°ï¼Œå¹¶ä¸” $y = x + 7$ï¼Œé‚£ä¹ˆ $2y = 2(x + 7)$ã€‚",
 "If $x$ and $q$ are arbitrary natural numbers, then $37x+q=37x+q.$":
 "å¦‚æœ $x$ å’Œ $q$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ $37x+q=37x+q$ ã€‚",
 "If $x \\leq y$ and $y \\leq z$, then $x \\leq z$.":
 "å¦‚æœ $x \\leq y$ ä¸” $y \\leq z$ï¼Œé‚£ä¹ˆ $x \\leq z$ã€‚",
 "If $x \\leq y$ and $y \\leq x$, then $x = y$.":
 "å¦‚æœ $x \\leq y$ ä¸” $y \\leq x$ï¼Œåˆ™ $x = y$ã€‚",
 "If $x \\leq 2$ then $x = 0$ or $1$ or $2$.":
 "å¦‚æœæ˜¯ $x \\leq 2$ï¼Œé‚£ä¹ˆ $x = 0$ æˆ– $1$ æˆ– $2$ã€‚",
 "If $x \\leq 1$ then either $x = 0$ or $x = 1$.":
 "å¦‚æœ $x \\leq 1$ é‚£ä¹ˆ $x = 0$ æˆ– $x = 1$ã€‚",
 "If $x \\leq 0$, then $x=0$.": "å¦‚æœæ˜¯ $x \\leq 0$ï¼Œé‚£ä¹ˆ $x=0$ã€‚",
 "If $a, b,\\ldots h$ are arbitrary natural numbers, we have\n$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$.":
 "å¦‚æœ $a, b,\\ldots h$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n$(d + f) + (h + (a + c)) + (g + e + b) = a + b + c + d + e + f + g + h$ã€‚",
 "If $a, b, c$ are numbers, then $a+(b+c)=b+(a+c)$.":
 "å¦‚æœ $a, b, c$ æ˜¯è‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ $a+(b+c)=b+(a+c)$ã€‚",
 "If $a, b$, $c$ and $d$ are numbers, we have\n$(a + b) + (c + d) = ((a + c) + d) + b.$":
 "å¦‚æœ $a, b$ã€$c$ å’Œ $d$ æ˜¯è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n$(a + b) + (c + d) = ((a + c) + d) + b.$",
 "If $a, b$ and $c$ are arbitrary natural numbers, we have\n$(a + b) + c = (a + c) + b$.":
 "å¦‚æœ $a, b$ å’Œ $c$ æ˜¯ä»»æ„è‡ªç„¶æ•°ï¼Œæˆ‘ä»¬æœ‰\n$(a + b) + c = (a + c) + b$ã€‚",
 "If $a+b=0$ then $b=0$.": "å¦‚æœ $a+b=0$ é‚£ä¹ˆ $b=0$ã€‚",
 "If $a+b=0$ then $a=0$.": "å¦‚æœ $a+b=0$ é‚£ä¹ˆ $a=0$ã€‚",
 "If $a \\neq b$ then $\\operatorname{succ}(a) \\neq\\operatorname{succ}(b)$.":
 "å¦‚æœ $a \neq b$ï¼Œé‚£ä¹ˆ $\\operatorname{succ}(a) \neq\\operatorname{succ}(b)$ã€‚",
 "If $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ then $x \\leq y$.":
 "å¦‚æœ $\\operatorname{succ}(x) \\leq \\operatorname{succ}(y)$ é‚£ä¹ˆ $x \\leq y$ã€‚",
 "If $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ then $a=b$.":
 "å¦‚æœ $\\operatorname{succ}(a)=\\operatorname{succ}(b)$ é‚£ä¹ˆ $a=b$ã€‚",
 "How should we define `37 * x`? Just like addition, we need to give definitions\nwhen $x=0$ and when $x$ is a successor.\n\nThe zero case is easy: we define `37 * 0` to be `0`. Now say we know\n`37 * d`. What should `37 * succ d` be? Well, that's $(d+1)$ $37$s,\nso it should be `37 * d + 37`.\n\nHere are the definitions in Lean.\n\n  * `mul_zero a : a * 0 = 0`\n  * `mul_succ a d : a * succ d = a * d + a`\n\nIn this world, we must not only prove facts about multiplication like `a * b = b * a`,\nwe must also prove facts about how multiplication interacts with addition, like `a * (b + c) = a * b + a * c`.\nLet's get started.":
 "æˆ‘ä»¬åº”è¯¥å¦‚ä½•å®šä¹‰ `37 * x`ï¼Ÿå°±åƒåŠ æ³•ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ $x=0$ å’Œ $x$ æ˜¯åç»§æ•°æ—¶ç»™å‡ºå®šä¹‰ã€‚\n\n0çš„æƒ…å†µå¾ˆç®€å•ï¼šæˆ‘ä»¬å®šä¹‰ `37 * 0` ä¸º `0`ã€‚ç°åœ¨å‡è®¾æˆ‘ä»¬çŸ¥é“ `37 * d`ã€‚`37 * succ d` åº”è¯¥æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå—¯ï¼Œé‚£æ˜¯ $d+1$ ä¸ª $37$ï¼Œå®ƒåº”è¯¥æ˜¯ `37 * d + 37`ã€‚\n\nä»¥ä¸‹æ˜¯ Lean ä¸­çš„å®šä¹‰ã€‚\n\n  * `mul_zero a : a * 0 = 0`\n  * `mul_succ a d : a * succ d = a * d + a`\n\nåœ¨è¿™ä¸ªä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬ä¸ä»…è¦è¯æ˜å…³äºä¹˜æ³•çš„äº‹å®ï¼Œå¦‚ `a * b = b * a`ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»è¯æ˜ä¹˜æ³•ä¸åŠ æ³•ç›¸äº’ä½œç”¨çš„äº‹å®ï¼Œå¦‚ `a * (b + c) = a * b + a * c`ã€‚\nè®©æˆ‘ä»¬å¼€å§‹å§ã€‚",
 "How about this for a proof:\n```\nrepeat rw [add_comm n]\nexact add_right_cancel a b n\n```":
 "ä¸‹é¢è¿™ä¸ªè¯æ˜æ€ä¹ˆæ ·ï¼š\n```\nrepeat rw [add_comm n]\nexact add_right_cancel a b n\n```",
 "How about this for a proof:\n\n```\nrw [add_comm]\nexact add_right_eq_zero b a\n```\n\nThat's the end of Advanced Addition World! You'll need these theorems\nfor the next world, `â‰¤` World. Click on \"Leave World\" to access it.":
 "è¿™ä¸ªè¯æ˜æ€ä¹ˆæ ·ï¼š\n\n```\nrw [add_comm]\nexact add_right_eq_zero b a\n```\n\nè¿™é‡Œå°±æ˜¯é«˜çº§åŠ æ³•ä¸–ç•Œçš„ç»“å°¾äº†ï¼ä½ å°†å¸¦ç€è¿™äº›å®šç†\nè¿›å…¥ä¸‹ä¸€ä¸ªä¸–ç•Œï¼Œ`â‰¤` ä¸–ç•Œã€‚ç‚¹å‡»â€œç¦»å¼€ä¸–ç•Œâ€æ¥è®¿é—®å®ƒã€‚",
 "Here's what I was thinking of:\n```\napply mul_left_ne_zero at h\napply one_le_of_ne_zero at h\napply mul_le_mul_right 1 b a at h\nrw [one_mul, mul_comm] at h\nexact h\n```":
 "æˆ‘æ˜¯è¿™ä¹ˆæƒ³çš„ï¼š\n```\napply mul_left_ne_zero at h\napply one_le_of_ne_zero at h\napply mul_le_mul_right 1 b a at h\nrw [one_mul, mul_comm] at h\nexact h\n```",
 "Here's my solution:\n```\nrw [two_eq_succ_one, succ_mul, one_mul]\nrfl\n```":
 "è¿™æ˜¯æˆ‘çš„è§£æ³•ï¼š\n```\nrw [two_eq_succ_one, succ_mul, one_mul]\nrfl\n```",
 "Here's my solution:\n```\nrw [mul_comm, mul_one]\nrfl\n```":
 "è¿™æ˜¯æˆ‘çš„è§£æ³•ï¼š\n```\nrw [mul_comm, mul_one]\nrfl\n```",
 "Here's my solution:\n```\ninduction c with d hd\nrw [add_zero, mul_zero, add_zero]\nrfl\nrw [add_succ, mul_succ, hd, mul_succ, add_assoc]\nrfl\n```\n\nInducting on `a` or `b` also works, but might take longer.":
 "è¿™æ˜¯ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼Œä¸å”¯ä¸€ï¼š\n```\ninduction c with d hd\nrw [add_zero, mul_zero, add_zero]\nrfl\nrw [add_succ, mul_succ, hd, mul_succ, add_assoc]\nrfl\n```\n\nåœ¨ `a` æˆ– `b` ä¸Šè¿›è¡Œæ•°å­¦å½’çº³ä¹Ÿå¯ä»¥ï¼Œä½†éœ€è¦å¤šæ­¥éª¤ã€‚",
 "Here's my proof:\n```\nrw [mul_comm, mul_add]\nrepeat rw [mul_comm c]\nrfl\n```":
 "è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n```\nrw [mul_comm, mul_add]\nrepeat rw [mul_comm c]\nrfl\n```",
 "Here's my proof:\n```\nintro h\nrw [add_succ, add_succ, add_zero] at h\nrepeat apply succ_inj at h\napply zero_ne_succ at h\nexact h\n```\n\nEven though Lean is a theorem prover, right now it's pretty clear that we have not\ndeveloped enough material to make it an adequate calculator. In Algorithm\nWorld, a more computer-sciency world, we will develop machinery which makes\nquestions like this much easier, and goals like $20 + 20 â‰  41$ feasible.\nAlternatively you can do more mathematics in Advanced Addition World, where we prove\nthe lemmas needed to get a working theory of inequalities. Click \"Leave World\" and\ndecide your route.":
 "è¿™æ˜¯ä¸€ä¸ªè¯æ˜ï¼š\n```\nintro h\nrw [add_succ, add_succ, add_zero] at h\nrepeat apply succ_inj at h\napply zero_ne_succ at h\nexact h\n```\n\n\nå°½ç®¡ Lean æ˜¯ä¸€ä¸ªå®šç†è¯æ˜å™¨ï¼Œä½†ç›®å‰å¾ˆæ˜æ˜¾æˆ‘ä»¬è¿˜æ²¡æœ‰å‘å±•è¶³å¤Ÿçš„ç´ æä½¿å…¶æˆä¸ºä¸€ä¸ªè¶³å¤Ÿçš„è®¡ç®—å™¨ã€‚\nåœ¨ç®—æ³•ä¸–ç•Œä¸­ï¼Œä¸€ä¸ªæ›´åå‘è®¡ç®—æœºç§‘å­¦çš„ä¸–ç•Œï¼Œæˆ‘ä»¬å°†å¼€å‘ä½¿è¿™ç±»é—®é¢˜å˜å¾—æ›´å®¹æ˜“çš„æœºåˆ¶ã€‚\nè¯æ˜åƒ $20 + 20 â‰  41$ è¿™æ ·çš„ç›®æ ‡ä¼šå˜å¾—å¾ˆå®¹æ˜“ã€‚\næˆ–è€…ä½ å¯ä»¥åœ¨é«˜çº§åŠ æ³•ä¸–ç•Œä¸­åšæ›´å¤šæ•°å­¦ï¼Œ\næˆ‘ä»¬åœ¨é‚£é‡Œè¯æ˜äº†å»ºç«‹ä¸ç­‰å¼ç†è®ºæ‰€éœ€çš„å¼•ç†ã€‚ç‚¹å‡»â€œç¦»å¼€ä¸–ç•Œâ€å¹¶å†³å®šä½ çš„è·¯çº¿ã€‚",
 "Here's my proof:\n```\ncases x with y\nleft\nrfl\nrw [one_eq_succ_zero] at hx âŠ¢\napply succ_le_succ at hx\napply le_zero at hx\nrw [hx]\nright\nrfl\n```\n\nIf you solved this level then you should be fine with the next level!":
 "è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n```\ncases x with y\nleft\nrfl\nrw [one_eq_succ_zero] at hx âŠ¢\napply succ_le_succ at hx\napply le_zero at hx\nrw [hx]\nright\nrfl\n```\n\nå¦‚æœä½ è§£å†³äº†è¿™ä¸ªå…³å¡ï¼Œé‚£ä¹ˆä½ åº”è¯¥å¯ä»¥é¡ºåˆ©è¿›å…¥ä¸‹ä¸€ä¸ªå…³å¡ï¼",
 "Here's my proof:\n```\ncases hxy with a ha\ncases hyx with b hb\nrw [ha]\nrw [ha, add_assoc] at hb\nsymm at hb\napply add_right_eq_self at hb\napply add_right_eq_zero at hb\nrw [hb, add_zero]\nrfl\n```\n\nA passing mathematician remarks that with antisymmetry as well,\nyou have proved that `â‰¤` is a *partial order* on `â„•`.\n\nThe boss level of this world is to prove\nthat `â‰¤` is a total order. Let's learn two more easy tactics\nfirst.":
 "è¿™æ˜¯æˆ‘çš„è¯æ˜ï¼š\n```\ncases hxy with a ha\ncases hyx with b hb\nrw [ha]\nrw [ha, add_assoc] at hb\nsymm at hb\napply add_right_eq_self at hb\napply add_right_eq_zero at hb\nrw [hb, add_zero]\nrfl\n```\n\n\nä¸€ä½è·¯è¿‡çš„æ•°å­¦å®¶è¯„è®ºè¯´ï¼Œä½ å·²ç»è¿ç”¨â€œåå¯¹ç§°æ€§â€è¯æ˜äº† `â‰¤` åœ¨ `â„•` ä¸Šæ˜¯ä¸€ä¸ª*ååº*ã€‚\n\nè¿™ä¸ªä¸–ç•Œä¸­çš„ Boss å…³å¡æ˜¯è¯æ˜ `â‰¤` æ˜¯ä¸€ä¸ªå…¨åºã€‚æˆ‘ä»¬å…ˆå­¦ä¹ ä¸¤ä¸ªæ›´ç®€å•çš„ç­–ç•¥ã€‚",
 "Here's my proof:\n```\ncases hx with d hd\nuse d\nrw [succ_add] at hd\napply succ_inj at hd\nexact hd\n```":
 "è¿™æ˜¯ä¸€ä¸ªè¯æ˜ï¼ˆä¸å”¯ä¸€ï¼‰ï¼š\n```\ncases hx with d hd\nuse d\nrw [succ_add] at hd\napply succ_inj at hd\nexact hd\n```",
 "Here's a two-liner:\n```\nuse 1\nexact succ_eq_add_one x\n```\n\nThis works because `succ_eq_add_one x` is a proof of `succ x = x + 1`.":
 "è¿™æ˜¯ä¸¤è¡Œçš„è¯æ˜ï¼š\n```\nuse 1\nexact succ_eq_add_one x\n```\n\nè¿™æ˜¯æœ‰æ•ˆçš„ï¼Œå› ä¸º `succ_eq_add_one x` æ˜¯ `succ x = x + 1` çš„è¯æ˜ã€‚",
 "Here's a two-line proof:\n```\nrepeat rw [zero_add] at h\nexact h\n```":
 "è¿™æ˜¯ä¸€ä¸ªä¸¤è¡Œè¯æ˜ï¼š\n```\nrepeat rw [zero_add] at h\nexact h\n```",
 "Here's a proof using `add_left_eq_self`:\n```\nrw [add_comm]\nintro h\napply add_left_eq_self at h\nexact h\n```\n\nand here's an even shorter one using the same idea:\n```\nrw [add_comm]\nexact add_left_eq_self y x\n```\n\nAlternatively you can just prove it by induction on `x`\n(the dots in the proof just indicate the two goals and\ncan be omitted):\n\n```\n  induction x with d hd\n  Â· intro h\n    rw [zero_add] at h\n    assumption\n  Â· intro h\n    rw [succ_add] at h\n    apply succ_inj at h\n    apply hd at h\n    assumption\n```":
 "è¿™é‡Œæ˜¯ä½¿ç”¨ `add_left_eq_self` çš„ä¸€ä¸ªè¯æ˜ï¼š\n```\nrw [add_comm]\nintro h\napply add_left_eq_self at h\nexact h\n```\n\nè¿™é‡Œæ˜¯ä¸€ä¸ªä½¿ç”¨ç›¸åŒæ€è·¯çš„æ›´çŸ­çš„è¯æ˜ï¼š\n```\nrw [add_comm]\nexact add_left_eq_self y x\n```\n\næˆ–è€…ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡å¯¹ `x` è¿›è¡Œå½’çº³æ¥è¯æ˜å®ƒ\nï¼ˆè¯æ˜ä¸­çš„ `.` åªæ˜¯è¡¨ç¤ºä¸¤ä¸ªç›®æ ‡ï¼Œ\nå¯ä»¥çœç•¥ï¼‰ï¼š\n\n```\n  induction x with d hd\n  Â· intro h\n    rw [zero_add] at h\n    assumption\n  Â· intro h\n    rw [succ_add] at h\n    apply succ_inj at h\n    apply hd at h\n    assumption\n```",
 "Here's a completely backwards proof:\n```\nintro h\napply succ_inj\nrepeat rw [succ_eq_add_one]\nexact h\n```":
 "è¿™æ˜¯ä¸€ä¸ªå®Œå…¨é€†å‘çš„è¯æ˜è¿‡ç¨‹ï¼š\n```\nintro h\napply succ_inj\nrepeat rw [succ_eq_add_one]\nexact h\n```",
 "Here we want to deal with the cases `b = 0` and `b â‰  0` separately,\nso start with `cases b with d`.":
 "åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬æƒ³è¦åˆ†åˆ«å¤„ç† `b = 0` å’Œ `b â‰  0` çš„æƒ…å†µï¼Œ\næ‰€ä»¥ä» `cases b with d` å¼€å§‹ã€‚",
 "Here we begin to\ndevelop an algorithm which, given two naturals `a` and `b`, returns the answer\nto \"does `a = b`?\"\n\nHere is the algorithm. First note that `a` and `b` are numbers, and hence\nare either `0` or successors.\n\n*) If `a` and `b` are both `0`, return \"yes\".\n\n*) If one is `0` and the other is `succ n`, return \"no\".\n\n*) If `a = succ m` and `b = succ n`, then return the answer to \"does `m = n`?\"\n\nOur job now is to *prove* that this algorithm always gives the correct answer. The proof that\n`0 = 0` is `rfl`. The proof that `0 â‰  succ n` is `zero_ne_succ n`, and the proof\nthat `succ m â‰  0` is `succ_ne_zero m`. The proof that if `h : m = n` then\n`succ m = succ n` is `rw [h]` and then `rfl`. This level is a proof of the one\nremaining job we have to do: if `a â‰  b` then `succ a â‰  succ b`.":
 "æˆ‘ä»¬å¼€å§‹å¼€å‘ä¸€ä¸ªç®—æ³•ï¼Œç»™å®šä¸¤ä¸ªè‡ªç„¶æ•° `a` å’Œ `b`ï¼Œè¿”å›å¯¹â€œ`a = b`ï¼Ÿâ€çš„å›ç­”ã€‚\n\nè¿™æ˜¯ç®—æ³•ã€‚é¦–å…ˆæ³¨æ„åˆ° `a` å’Œ `b` æ˜¯æ•°å­—ï¼Œå› æ­¤è¦ä¹ˆæ˜¯ `0` è¦ä¹ˆæ˜¯åç»§è€…ã€‚\n\n*) å¦‚æœ `a` å’Œ `b` éƒ½æ˜¯ `0`ï¼Œè¿”å›â€œæ˜¯â€ã€‚\n\n*) å¦‚æœä¸€ä¸ªæ˜¯ `0` è€Œå¦ä¸€ä¸ªæ˜¯ `succ n`ï¼Œè¿”å›â€œå¦â€ã€‚\n\n*) å¦‚æœ `a = succ m` ä¸” `b = succ n`ï¼Œé‚£ä¹ˆè¿”å›å¯¹â€œ`m = n`ï¼Ÿâ€çš„ç­”æ¡ˆã€‚\n\nç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯*è¯æ˜*è¿™ä¸ªç®—æ³•æ€»èƒ½ç»™å‡ºæ­£ç¡®çš„ç­”æ¡ˆã€‚è¯æ˜ `0 = 0` æ˜¯ `rfl`ã€‚è¯æ˜ `0 â‰  succ n` çš„æ˜¯ `zero_ne_succ n`ï¼Œè¯æ˜ `succ m â‰  0` çš„æ˜¯ `succ_ne_zero m`ã€‚å¦‚æœæœ‰å‡è®¾ `h : m = n`ï¼Œé‚£ä¹ˆè¯æ˜ `succ m = succ n` å¯ä»¥ä½¿ç”¨ `rw [h]` ç„¶å `rfl`ã€‚è¿™ä¸€å…³æ˜¯è¯æ˜æˆ‘ä»¬è¦åšçš„å‰©ä½™å·¥ä½œä¹‹ä¸€ï¼šå¦‚æœ `a â‰  b`ï¼Œé‚£ä¹ˆ `succ a â‰  succ b`ã€‚",
 "Here is an example proof of 2+2=4 showing off various techniques.\n\n```lean\nnth_rewrite 2 [two_eq_succ_one] -- only change the second `2` to `succ 1`.\nrw [add_succ]\nrw [one_eq_succ_zero]\nrw [add_succ, add_zero] -- two rewrites at once\nrw [â† three_eq_succ_two] -- change `succ 2` to `3`\nrw [â† four_eq_succ_three]\nrfl\n```\n\nOptional extra: you can run this proof yourself. Switch the game into \"Editor mode\" by clicking\non the `</>` button in the top right. You can now see your proof\nwritten as several lines of code. Move your cursor between lines to see\nthe goal state at any point. Now cut and paste your code elsewhere if you\nwant to save it, and paste the above proof in instead. Move your cursor\naround to investigate. When you've finished, click the `>_` button in the top right to\nmove back into \"Typewriter mode\".\n\nYou have finished tutorial world!\nClick \"Leave World\" to go back to the\noverworld, and select Addition World, where you will learn\nabout the `induction` tactic.":
 "ä¸‹é¢æ˜¯ä¸€ä¸ªè¯æ˜ 2+2=4 çš„ä¾‹å­ï¼Œå±•ç¤ºäº†å„ç§æŠ€å·§ã€‚\n\n```lean\nnth_rewrite 2 [two_eq_succ_one] -- åªå°†ç¬¬äºŒä¸ª `2 ` æ”¹ä¸º `succ 1` ã€‚\nrw [add_succï¼½\nrw [one_eq_succ_zero]\nrw [add_succ, add_zero] -- ä¸€æ¬¡æ”¹å†™ä¸¤ä¸ªå†…å®¹\nrw [â† three_eq_succ_two] -- å°† `succ 2` æ”¹ä¸º `3`\nrw [â† four_eq_succ_three] ã€‚\nrfl\n```\n\nå¯é€‰é™„åŠ åŠŸèƒ½ï¼šä½ å¯ä»¥è‡ªå·±è¿è¡Œè¿™ä¸ªè¯æ˜ã€‚ç‚¹å‡»å³ä¸Šè§’çš„\nå³ä¸Šè§’çš„ `</>` æŒ‰é’®ï¼Œå°†æ¸¸æˆåˆ‡æ¢åˆ° \"ç¼–è¾‘å™¨æ¨¡å¼\"ã€‚ç°åœ¨ä½ å¯ä»¥çœ‹åˆ°ä½ çš„è¯æ˜\nè¢«å†™æˆäº†å‡ è¡Œä»£ç ã€‚åœ¨å„è¡Œä»£ç ä¹‹é—´ç§»åŠ¨å…‰æ ‡ï¼Œå³å¯æŸ¥çœ‹\nç›®æ ‡çŠ¶æ€ã€‚ç°åœ¨ï¼Œå¦‚æœæƒ³ä¿å­˜ä»£ç ï¼Œä½ å°±è¦å°†ä»£ç å‰ªåˆ‡å¹¶ç²˜è´´åˆ°å…¶ä»–åœ°æ–¹\nï¼Œè¯·å°†ä¸Šè¿°è¯æ˜ç²˜è´´è¿›å»ã€‚ç§»åŠ¨å…‰æ ‡\nè¿›è¡Œç ”ç©¶ã€‚å®Œæˆåï¼Œç‚¹å‡»å³ä¸Šè§’çš„ `>_` æŒ‰é’®ï¼Œå›åˆ° \"æ‰“å­—æœºæ¨¡å¼\"ã€‚\nå›åˆ° \"æ‰“å­—æœºæ¨¡å¼\"ã€‚\n\næ‚¨å·²ç»å®Œæˆäº† \"æ•™ç¨‹ä¸–ç•Œ\"ï¼\nç‚¹å‡» \"ç¦»å¼€ä¸–ç•Œ \"å›åˆ°ä¸–ç•Œé€‰æ‹©ç•Œé¢\né€‰æ‹© \"åŠ æ³•ä¸–ç•Œ\"ï¼Œåœ¨è¿™é‡Œæ‚¨å°†å­¦ä¹ \n`induction ` ç­–ç•¥ã€‚",
 "Having to rearrange variables manually using commutativity and\nassociativity is very tedious. We start by reminding you of this. `add_left_comm`\nis a key component in the first algorithm which we'll explain, but we need\nto prove it manually.\n\nRemember that you can do precision commutativity rewriting\nwith things like `rw [add_comm b c]`. And remember that\n`a + b + c` means `(a + b) + c`.":
 "æˆ‘ä»¬é¦–å…ˆæé†’æ‚¨ä¸€ç‚¹ï¼Œæ‰‹åŠ¨ä½¿ç”¨äº¤æ¢å¾‹å’Œç»“åˆå¾‹æ¥é‡æ–°æ’åˆ—å˜é‡æ˜¯éå¸¸ç¹ççš„ã€‚\n`add_left_comm` æ˜¯æˆ‘ä»¬å°†è¦è§£é‡Šçš„ç¬¬ä¸€ä¸ªç®—æ³•ä¸­çš„å…³é”®ç»„ä»¶ï¼Œä½†æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è¯æ˜å®ƒã€‚\n\nè¯·è®°ä½ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `rw [add_comm b c]` ä¹‹ç±»çš„å‘½ä»¤è¿›è¡Œç²¾ç¡®çš„äº¤æ¢å¾‹é‡å†™ã€‚å¹¶è®°ä½ `a + b + c` è¡¨ç¤º `(a + b) + c`ã€‚",
 "Good luck!\n\n  One last hint. If `h : X = Y` then `rw [h]` will change *all* `X`s into `Y`s.\n  If you only want to change one of them, say the 3rd one, then use\n  `nth_rewrite 3 [h]`.":
 "ç¥ä½ å¥½è¿ï¼\n\næœ€åä¸€ä¸ªæç¤ºã€‚å¦‚æœ `h : X = Y`ï¼Œé‚£ä¹ˆ `rw [h]` ä¼šå°† *æ‰€æœ‰* çš„ `X` æ›¿æ¢ä¸º `Y`ã€‚å¦‚æœä½ åªæƒ³æ›¿æ¢å…¶ä¸­ä¸€ä¸ªï¼Œæ¯”å¦‚ç¬¬ 3 ä¸ªï¼Œé‚£ä¹ˆè¯·ä½¿ç”¨ `nth_rewrite 3 [h]`ã€‚",
 "For any natural number $m$, we have $ m \\times 1 = m$.":
 "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ m \\times 1 = m$ã€‚",
 "For any natural number $m$, we have $ 2 \\times m = m+m$.":
 "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 2 \\times m = m+m$ã€‚",
 "For any natural number $m$, we have $ 1 \\times m = m$.":
 "å¯¹äºä»»ä½•è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 1 \\times m = m$ã€‚",
 "For all numbers $m$, $0 ^{\\operatorname{succ} (m)} = 0$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ã€$0 ^{\\operatorname{succ} (m)} = 0$ã€‚",
 "For all numbers $a$ and $b$, we have\n$$(a+b)^2=a^2+b^2+2ab.$$":
 "å¯¹äºæ‰€æœ‰æ•°å­— $a$ å’Œ $b$ï¼Œæˆ‘ä»¬æœ‰\n$$(a+b)^2=a^2+b^2+2ab.$$",
 "For all naturals $m$, $1 ^ m = 1$.": "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ã€$1 ^ m = 1$ã€‚",
 "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$m$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $a^{m + n} = a ^ m  a ^ n$ ã€‚",
 "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$.":
 "å¯¹äºæ‰€æœ‰å¤©ç„¶ $a$ã€$m$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $(a ^ m) ^ n = a ^ {mn}$ã€‚",
 "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$.":
 "å¯¹äºæ‰€æœ‰çš„è‡ªç„¶æ•° $a$ã€$b$ã€$n$ï¼Œæˆ‘ä»¬æœ‰ $(ab) ^ n = a ^ nb ^ n$ã€‚",
 "For all naturals $a$, $a ^ 2 = a \\times a$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$a ^ 2 = a \\times a$ã€‚",
 "For all naturals $a$, $a ^ 1 = a$.": "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$a ^ 1 = a$ã€‚",
 "For all naturals $a$ $b$ $c$ and $n$, we have\n$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ $b$ $c$ å’Œ $n$ï¼Œæˆ‘ä»¬æœ‰\n$$(a+1)^{n+3}+(b+1)^{n+3}\\not=(c+1)^{n+3}.$$",
 "For all natural numbers $n$, we have $0 + n = n$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $n$ï¼Œæˆ‘ä»¬æœ‰ $0 + n = n$ã€‚",
 "For all natural numbers $m$, we have $ 0 \\times m = 0$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $m$ï¼Œæˆ‘ä»¬æœ‰ $ 0 \\times m = 0$ã€‚",
 "For all natural numbers $a, b$, we have\n$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a, b$ï¼Œæˆ‘ä»¬æœ‰\n$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b)$ã€‚",
 "For all natural numbers $a$, we have $\\operatorname{succ}(a) = a+1$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ï¼Œæˆ‘ä»¬æœ‰ $\\operatorname{succ}(a) = a+1$ ã€‚",
 "For all natural numbers $a$ and $b$, we have\n$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$.":
 "å¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ å’Œ $b$ï¼Œæˆ‘ä»¬æœ‰\n$(\\operatorname{succ}\\ a) \\times b = a\\times b + b$ã€‚",
 "First execute `rw [h]` to replace the `y` with `x + 7`.":
 "é¦–å…ˆæ‰§è¡Œ `rw [h]` å°† `y` æ›¿æ¢ä¸º `x + 7`ã€‚",
 "Finally use a targetted `add_comm` to switch `b` and `d`":
 "æœ€åï¼Œä½¿ç”¨æœ‰é’ˆå¯¹æ€§çš„ `add_comm` æ¥äº¤æ¢ `b` å’Œ `d",
 "Fermat's Last Theorem": "è´¹é©¬å¤§å®šç†",
 "Every number in Lean is either $0$ or a successor. We know how to add $0$,\nbut we need to figure out how to add successors. Let's say we already know\nthat `37 + d = q`. What should the answer to `37 + succ d` be? Well,\n`succ d` is one bigger than `d`, so `37 + succ d` should be `succ q`,\nthe number one bigger than `q`. More generally `x + succ d` should\nbe `succ (x + d)`. Let's add this as a lemma.\n\n* `add_succ x d : x + succ d = succ (x + d)`\n\nIf you ever see `... + succ ...` in your goal, `rw [add_succ]` is\nnormally a good idea.\n\nLet's now prove that `succ n = n + 1`. Figure out how to get `+ succ` into\nthe picture, and then `rw [add_succ]`. Switch between the `+` (addition) and\n`012` (numerals) tabs under \"Theorems\" on the right to\nsee which proofs you can rewrite.":
 "Lean ä¸­çš„æ¯ä¸ªæ•°å­—è¦ä¹ˆæ˜¯ $0$ è¦ä¹ˆæ˜¯åç»§æ•°ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•åŠ  $0$ï¼Œ\næˆ‘ä»¬è¿˜éœ€è¦å¼„æ¸…æ¥šå¦‚ä½•æ·»åŠ åç»§æ•°ã€‚å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“\n`37 + d = q`ã€‚ `37 + succ d` çš„ç­”æ¡ˆåº”è¯¥æ˜¯ä»€ä¹ˆï¼Ÿ\n`succ d` æ¯” `d` å¤§1ï¼Œå› æ­¤ `37 + succ d` åº”è¯¥æ˜¯ `succ q`ï¼Œ\nä¹Ÿå°±æ˜¯æ¯” `q` å¤§1ã€‚æ›´ä¸€èˆ¬åœ°è¯´ï¼Œ`x + succ d` åº”è¯¥\nä¸º `succ (x + d)`ã€‚è®©æˆ‘ä»¬å°†å…¶æ·»åŠ ä¸ºå®šç†ã€‚\n\n* `add_succ x d : x + succ d = succ (x + d)`\n\nå¦‚æœæ‚¨åœ¨è¯æ˜ç›®æ ‡ä¸­çœ‹åˆ° `... + succ ...`ï¼Œé‚£ä¹ˆç”¨ `rw [add_succ]` æ”¹å†™\né€šå¸¸æ˜¯ä¸ªå¥½ä¸»æ„ã€‚\n\nç°åœ¨è®©æˆ‘ä»¬è¯æ˜ `succ n = n + 1`ã€‚å¼„æ¸…æ¥šå¦‚ä½•å¼•å…¥ `+ succ` \nï¼Œç„¶åå† `rw [add_succ]`ã€‚åœ¨å³ä¾§â€œå®šç†â€ä¸‹çš„ `+`ï¼ˆåŠ æ³•ï¼‰å’Œ\n `012`ï¼ˆæ•°å­—ï¼‰é€‰é¡¹å¡é‡Œ\nçœ‹çœ‹ä½ å¯ä»¥ç”¨å“ªäº›è¯æ˜é‡å†™ç›®æ ‡ã€‚\n\nåœ¨ Lean ä¸­ï¼Œæ¯ä¸ªæ•°å­—è¦ä¹ˆæ˜¯ $0$ï¼Œè¦ä¹ˆæ˜¯æŸä¸ªæ•°å­—çš„åç»§æ•°ã€‚æˆ‘ä»¬å·²ç»æŒæ¡äº†å¦‚ä½•åŠ ä¸Š $0$ï¼Œä¸‹ä¸€æ­¥éœ€è¦æ˜ç™½å¦‚ä½•åŠ ä¸Šåç»§æ•°ã€‚è®¾æƒ³æˆ‘ä»¬å·²ç»çŸ¥é“ `37 + d = q`ã€‚é‚£ä¹ˆ `37 + succ d` åº”è¯¥æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿç”±äº `succ d` æ¯” `d` å¤š $1$ï¼Œæ‰€ä»¥ `37 + succ d` åº”è¯¥ç­‰äº `succ q`ï¼Œä¹Ÿå°±æ˜¯ `q` åŠ  $1$ã€‚æ›´ä¸€èˆ¬åœ°ï¼Œ`x + succ d` åº”ç­‰äº `succ (x + d)`ã€‚æˆ‘ä»¬æŠŠè¿™ä¸ªè§„åˆ™åŠ ä¸ºä¸€ä¸ªå¼•ç†ï¼š\n\n- `add_succ x d : x + succ d = succ (x + d)`\n\nå½“ä½ åœ¨è¯æ˜ç›®æ ‡ä¸­é‡åˆ° `... + succ ...` å½¢å¼æ—¶ï¼Œä½¿ç”¨ `rw [add_succ]` æ¥é‡å†™é€šå¸¸æ˜¯ä¸€ä¸ªå¥½ç­–ç•¥ã€‚\n\nç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥è¯æ˜ `succ n = n + 1`ã€‚æ€è€ƒå¦‚ä½•å…ˆå¼•å…¥ `+ succ` å½¢å¼ï¼Œç„¶åå†åº”ç”¨ `rw [add_succ]` ç­–ç•¥ã€‚è¯·åœ¨å³ä¾§â€œå®šç†â€éƒ¨åˆ†çš„ `+`ï¼ˆä»£è¡¨åŠ æ³•ï¼‰å’Œ `012`ï¼ˆä»£è¡¨æ•°å­—ï¼‰æ ‡ç­¾é¡µä¸­æŸ¥æ‰¾å¯ä»¥ç”¨æ¥é‡å†™ç›®æ ‡çš„å®šç†ã€‚",
 "Do that again!\n\n`rw [zero_add] at Â«{h}Â»` tries to fill in\nthe arguments to `zero_add` (finding `Â«{x}Â»`) then it replaces all occurences of\n`0 + Â«{x}Â»` it finds. Therefor, it did not rewrite `0 + Â«{y}Â»`, yet.":
 "å†åšä¸€æ¬¡ï¼\n\n`rw [zero_add] at Â«{h}Â»` è¯•å›¾å¡«å…… `zero_add` çš„å‚æ•°ï¼ˆæ‰¾åˆ° `Â«{x}Â»`ï¼‰ï¼Œç„¶åæ›¿æ¢å®ƒæ‰¾åˆ°çš„æ‰€æœ‰ `0 + Â«{x}Â»` å‡ºç°çš„åœ°æ–¹ã€‚å› æ­¤ï¼Œ`0 + Â«{y}Â»`è¿˜æ²¡æœ‰è¢«é‡å†™ ã€‚",
 "Did you use induction on `y`?\nHere's a two-line proof of `add_left_eq_self` which uses `add_right_cancel`.\nIf you want to inspect it, you can go into editor mode by clicking `</>` in the top right\nand then just cut and paste the proof and move your cursor around it\nto see the hypotheses and goal at any given point\n(although you'll lose your own proof this way). Click `>_` to get\nback to command line mode.\n```\nnth_rewrite 2 [â† zero_add y]\nexact add_right_cancel x 0 y\n```":
 "ä½ æ˜¯å¦å¯¹ `y` ä½¿ç”¨äº†å½’çº³æ³•ï¼Ÿ\nè¿™é‡Œæœ‰ä¸€ä¸ªä½¿ç”¨ `add_right_cancel` è¯æ˜ `add_left_eq_self`çš„ä¸¤è¡Œè¯æ˜ã€‚å¦‚æœä½ æƒ³æŸ¥çœ‹å®ƒï¼Œä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å³ä¸Šè§’çš„ `</>` è¿›å…¥ç¼–è¾‘å™¨æ¨¡å¼ï¼Œç„¶ååªéœ€å‰ªåˆ‡å’Œç²˜è´´è¯æ˜ï¼Œå¹¶åœ¨å…¶å‘¨å›´ç§»åŠ¨ä½ çš„å…‰æ ‡ï¼Œä»¥æŸ¥çœ‹åœ¨ä»»ä½•ç»™å®šç‚¹çš„å‡è®¾å’Œç›®æ ‡ï¼ˆå°½ç®¡è¿™æ ·åšä½ ä¼šå¤±å»è‡ªå·±çš„è¯æ˜ï¼‰ã€‚ç‚¹å‡» `>_` è¿”å›å‘½ä»¤è¡Œæ¨¡å¼ã€‚\n```\nnth_rewrite 2 [â† zero_add y]\nexact add_right_cancel x 0 y\n```",
 "Dealing with `or`": "å¤„ç† `or`",
 "Congratulations! You've finished Algorithm World. These algorithms\nwill be helpful for you in Even-Odd World.":
 "æ­å–œï¼æ‚¨å·²ç»å®Œæˆäº†ã€Šç®—æ³•ä¸–ç•Œã€‹ã€‚è¿™äº›ç®—æ³•\nå°†å¯¹æ‚¨åœ¨å¥‡å¶ä¸–ç•Œä¸­æœ‰æ‰€å¸®åŠ©ã€‚",
 "Congratulations! You have proved Fermat's Last Theorem!\n\nEither that, or you used magic...":
 "æ­å–œï¼æ‚¨å·²ç»è¯æ˜äº†è´¹é©¬å¤§å®šç†ï¼\n\nè¦ä¹ˆå°±æ˜¯ï¼Œè¦ä¹ˆä½ ä½¿ç”¨äº†é­”æ³•â€¦â€¦",
 "Congratulations! You completed your first verified proof!\n\nRemember that `rfl` is a *tactic*. If you ever want information about the `rfl` tactic,\nyou can click on `rfl` in the list of tactics on the right.\n\nNow click on \"Next\" to learn about the `rw` tactic.":
 "æ­å–œä½ ï¼ä½ å·²ç»å®Œæˆäº†ç¬¬ä¸€ä¸ªè¯æ˜ï¼\n\nè¯·è®°å¾—ï¼Œ`rfl` æ˜¯ä¸€ç§*ç­–ç•¥*ã€‚å¦‚æœä½ å¯¹ `rfl` ç­–ç•¥æœ‰æ›´å¤šçš„å…´è¶£æƒ³è¦æ·±å…¥äº†è§£ï¼Œå¯ä»¥å°è¯•ç‚¹å‡»å³ä¾§ç­–ç•¥åˆ—è¡¨ä¸­çš„ `rfl` æŸ¥çœ‹è¯¦æƒ…ã€‚\n\nç°åœ¨ï¼Œè¯·ç‚¹å‡»â€œä¸‹ä¸€å…³â€ï¼Œç»§ç»­å­¦ä¹  `rw`ï¼ˆé‡å†™ï¼‰ç­–ç•¥ã€‚",
 "Concretely: `rw [â† succ_eq_add_one] at h`.":
 "å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯ï¼š`rw [â† succ_eq_add_one] at h`ã€‚",
 "Can you take it from here? Click on \"Show more help!\" if you need a hint.":
 "ä½ èƒ½ä»è¿™é‡Œå¼€å§‹å—ï¼Ÿå¦‚æœæ‚¨éœ€è¦æç¤ºï¼Œè¯·ç‚¹å‡» \"æ˜¾ç¤ºæ›´å¤šå¸®åŠ©ï¼\"ã€‚",
 "Can you take it from here? (note: if you try `contrapose! h` again, it will\ntake you back to where you started!)":
 "ä½ èƒ½å¤„ç†æ¥ä¸‹æ¥çš„è¯æ˜å—ï¼Ÿï¼ˆæ³¨æ„ï¼šå¦‚æœä½ å†æ¬¡å°è¯• `contrapose! h`ï¼Œå®ƒä¼šæŠŠä½ å¸¦å›åˆ°å¼€å§‹çš„åœ°æ–¹ï¼ï¼‰",
 "Can you take it from here?": "ä½ èƒ½ä»è¿™é‡Œæ¥æ‰‹å—ï¼Ÿ",
 "Can you now change the goal into `2 = 2`?": "ä½ ç°åœ¨èƒ½å°†ç›®æ ‡æ”¹ä¸º \"2 = 2 \"å—ï¼Ÿ",
 "At this point you see the term `0 + Â«{d}Â»`, so you can use the\ninduction hypothesis with `rw [Â«{hd}Â»]`.":
 "åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ çœ‹åˆ°äº†é¡¹ `0 + Â«{d}Â»`ï¼Œæ‰€ä»¥ä½ å¯ä»¥é€šè¿‡ `rw [Â«{hd}Â»]` æ¥ä½¿ç”¨å½’çº³å‡è®¾ã€‚",
 "Assuming $x+y=37$ and $3x+z=42$, we have $x+y=37$.":
 "å‡è®¾ $x+y=37$ å’Œ $3x+z=42$ï¼Œæˆ‘ä»¬æœ‰ $x+y=37$ã€‚",
 "Assuming $0+x=(0+y)+2$, we have $x=y+2$.": "å‡è®¾ $0+x=(0+y)+2$ï¼Œæˆ‘ä»¬æœ‰ $x=y+2$ã€‚",
 "As warm-up for `2 + 2 â‰  5` let's prove `0 â‰  1`. To do this we need to\nintroduce Peano's last axiom `zero_ne_succ n`, a proof that `0 â‰  succ n`.\nTo learn about this result, click on it in the list of lemmas on the right.":
 "ä½œä¸º `2 + 2 â‰  5` çš„çƒ­èº«ï¼Œæˆ‘ä»¬æ¥è¯æ˜ `0 â‰  1`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦\nä»‹ç»ä¸€ä¸‹Peanoçš„æœ€åä¸€ä¸ªå…¬ç†`zero_ne_succ n`ï¼Œè¯æ˜`0 â‰  succ n`ã€‚\nè¦äº†è§£æ­¤ç»“è®ºï¼Œè¯·åœ¨å³ä¾§çš„å¼•ç†åˆ—è¡¨ä¸­å•å‡»å®ƒã€‚",
 "Arguing backwards": "ä»åå‘å‰è¯æ˜",
 "Applying a proof of $P\\implies Q$ to the *goal* changes $Q$ to $P$.\nNow try `rw [succ_eq_add_one]` to make the goal more like the hypothesis.":
 "åº”ç”¨ä¸€ä¸ª $P\\implies Q$ çš„è¯æ˜åˆ°*ç›®æ ‡*ä¸Šï¼Œä¼šå°† $Q$ å˜ä¸º $P$ã€‚\nç°åœ¨å°è¯•ä½¿ç”¨ `rw [succ_eq_add_one]` æ¥ä½¿ç›®æ ‡æ›´åƒå‡è®¾ã€‚",
 "And now we've deduced what we wanted to prove: the goal is one of our assumptions.\nFinish the level with `exact h`.":
 "ç°åœ¨æˆ‘ä»¬å·²ç»æ¨å¯¼å‡ºäº†æˆ‘ä»¬æƒ³è¦è¯æ˜çš„äº†ï¼šç›®æ ‡æ˜¯æˆ‘ä»¬çš„å‡è®¾ä¹‹ä¸€ã€‚\nç”¨ `exact h` å®Œæˆæœ¬å…³ã€‚",
 "And now `rw [add_zero]`": "ç°åœ¨ä½¿ç”¨`rw [add_zero]`",
 "And finally `rfl`.": "æœ€åæ˜¯ `rfl`ã€‚",
 "An algorithm for equality": "ç”¨äºè¯æ˜ç­‰ä»·çš„ç®—æ³•",
 "Although $0^0=1$ in this game, $0^n=0$ if $n>0$, i.e., if\n$n$ is a successor.":
 "è™½ç„¶åœ¨è¿™ä¸ªæ¸¸æˆä¸­ $0^0=1$ï¼Œä½†å¦‚æœ $n>0$ï¼Œå³å¦‚æœ $n$ æ˜¯åç»§æ•°ï¼Œé‚£ä¹ˆ $0^n=0$ã€‚",
 "Algorithm World": "ç®—æ³•ä¸–ç•Œ",
 "Advanced Multiplication World": "é«˜çº§ä¹˜æ³•ä¸–ç•Œ",
 "Advanced Addition World": "é«˜çº§åŠ æ³•ä¸–ç•Œ",
 "Advanced *Addition* World proved various implications\ninvolving addition, such as `x + y = 0 â†’ x = 0` and `x + y = x â†’ y = 0`.\nThese lemmas were used to prove basic facts about â‰¤ in â‰¤ World.\n\nIn Advanced Multiplication World we prove analogous\nfacts about multiplication, such as `x * y = 1 â†’ x = 1`, and\n`x * y = x â†’ y = 1` (assuming `x â‰  0` in the latter result). This will prepare\nus for Divisibility World.\n\nMultiplication World is more complex than Addition World. In the same\nway, Advanced Multiplication world is more complex than Advanced Addition\nWorld. One reason for this is that certain intermediate results are only\ntrue under the additional hypothesis that one of the variables is non-zero.\nThis causes some unexpected extra twists.":
 "é«˜çº§ *åŠ æ³•* ä¸–ç•Œè¯æ˜äº†æ¶‰åŠåŠ æ³•çš„å„ç§å¼•ç†ï¼Œä¾‹å¦‚ `x + y = 0 â†’ x = 0` å’Œ `x + y = x â†’ y = 0`ã€‚è¿™äº›å¼•ç†è¢«ç”¨æ¥è¯æ˜ â‰¤ ä¸–ç•Œä¸­å…³äº â‰¤ çš„åŸºæœ¬äº‹å®ã€‚\n\nåœ¨é«˜çº§ä¹˜æ³•ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬è¯æ˜äº†å…³äºä¹˜æ³•çš„ç±»ä¼¼äº‹å®ï¼Œä¾‹å¦‚ `x * y = 1 â†’ x = 1`ï¼Œä»¥åŠ `x * y = x â†’ y = 1`ï¼ˆåœ¨åä¸€ä¸ªç»“æœä¸­å‡è®¾ `x â‰  0`ï¼‰ã€‚è¿™å°†ä¸ºæˆ‘ä»¬è¿›å…¥å¯é™¤æ€§ä¸–ç•Œåšå‡†å¤‡ã€‚\n\nä¹˜æ³•ä¸–ç•Œæ¯”åŠ æ³•ä¸–ç•Œæ›´ä¸ºå¤æ‚ã€‚åŒæ ·ï¼Œé«˜çº§ä¹˜æ³•ä¸–ç•Œæ¯”é«˜çº§åŠ æ³•ä¸–ç•Œæ›´ä¸ºå¤æ‚ã€‚å…¶ä¸­ä¸€ä¸ªåŸå› æ˜¯æŸäº›ä¸­é—´ç»“æœåªåœ¨é¢å¤–å‡è®¾ä¸‹ä¸ºçœŸï¼Œå³å˜é‡ä¹‹ä¸€éé›¶ã€‚è¿™å¯¼è‡´äº†ä¸€äº›æ„æƒ³ä¸åˆ°çš„é¢å¤–è½¬æŠ˜ã€‚",
 "Addition is distributive over multiplication.\nIn other words, for all natural numbers $a$, $b$ and $c$, we have\n$(a + b) \\times c = ac + bc$.":
 "åŠ æ³•å’Œä¹˜æ³•æœ‰åˆ†é…å¾‹ã€‚æ¢å¥è¯è¯´ï¼Œå¯¹äºæ‰€æœ‰è‡ªç„¶æ•° $a$ã€$b$ å’Œ $c$ï¼Œ\næˆ‘ä»¬æœ‰ $(a + b) \\times c = ac + bc$ã€‚",
 "Addition World": "åŠ æ³•ä¸–ç•Œ",
 "Adding zero": "åŠ é›¶",
 "A two-line proof is\n\n```\nnth_rewrite 2 [â† mul_one a] at h\nexact mul_left_cancel a b 1 ha h\n```\n\nWe now have all the tools necessary to set up the basic theory of divisibility of naturals.":
 "è¿™é‡Œæœ‰ä¸ªä¸¤è¡Œçš„è¯æ˜\n\n```\nnth_rewrite 2 [â† mul_one a] at h\nexact mul_left_cancel a b 1 ha h\n```\n\nç°åœ¨æˆ‘ä»¬æ‹¥æœ‰äº†å»ºç«‹è‡ªç„¶æ•°å¯é™¤æ€§åŸºæœ¬ç†è®ºæ‰€éœ€çš„æ‰€æœ‰å·¥å…·ã€‚",
 "A proof that $a+b=0 \\implies b=0$.": "ä¸€ä¸ª$a+b=0 \\implies b=0$çš„è¯æ˜ã€‚",
 "A proof that $a+b=0 \\implies a=0$.": "ä¸€ä¸ª $a+b=0 \\implies a=0$ çš„è¯æ˜ã€‚",
 "A passing mathematician remarks that with reflexivity and transitivity out of the way,\nyou have proved that `â‰¤` is a *preorder* on `â„•`.":
 "ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶æŒ‡å‡ºï¼Œéšç€è‡ªåæ€§å’Œä¼ é€’æ€§çš„è§£å†³ï¼Œä½ å·²ç»è¯æ˜äº† `â‰¤` æ˜¯ `â„•` ä¸Šçš„ä¸€ä¸ª*é¢„åº*ã€‚",
 "A passing mathematician notes that you've proved\nthat the natural numbers are a commutative semiring.\n\nIf you want to begin your journey to the final boss, head for Power World.":
 "ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶æŒ‡å‡ºï¼Œä½ å·²ç»è¯æ˜äº†è‡ªç„¶æ•°æ˜¯ä¸€ä¸ªäº¤æ¢åŠç¯ã€‚\n\nå¦‚æœä½ æƒ³å¼€å§‹é€šå¾€æœ€ç»ˆBossçš„æ—…ç¨‹ï¼Œé‚£å°±å‰å¾€å¹‚ä¸–ç•Œã€‚",
 "A passing mathematician congratulates you on proving that naturals\nare an additive commutative monoid.\n\nLet's practice using `add_assoc` and `add_comm` in one more level,\nbefore we leave addition world.":
 "ä¸€ä¸ªè·¯è¿‡çš„æ•°å­¦å®¶ç¥è´ºä½ è¯æ˜äº†è‡ªç„¶æ•°æ˜¯ä¸€ä¸ªåŠ æ³•äº¤æ¢å¹ºåŠç¾¤ã€‚\n\nåœ¨æˆ‘ä»¬ç¦»å¼€åŠ æ³•ä¸–ç•Œä¹‹å‰ï¼Œè®©æˆ‘ä»¬åœ¨å¦ä¸€å…³é‡Œç»ƒä¹ ä½¿ç”¨ `add_assoc` å’Œ `add_comm`ã€‚",
 "2+2=4": "2+2=4",
 "2 + 2 â‰  5 is boring to prove in full, given only the tools we have currently.\nTo make it a bit less painful, I have unfolded all of the numerals for you.\nSee if you can use `zero_ne_succ` and `succ_inj` to prove this.":
 "ä»…å‡­æˆ‘ä»¬ç›®å‰æ‹¥æœ‰çš„å·¥å…·ï¼Œå®Œæ•´è¯æ˜ 2 + 2 â‰  5 æ˜¯å¾ˆæ— èŠçš„ã€‚\nä¸ºäº†å‡è½»æ‚¨çš„ç—›è‹¦ï¼Œæˆ‘ä¸ºæ‚¨å±•å¼€äº†æ‰€æœ‰æ•°å­—ã€‚\nçœ‹çœ‹æ˜¯å¦å¯ä»¥ä½¿ç”¨ `zero_ne_succ` å’Œ `succ_inj` æ¥è¯æ˜å®ƒã€‚",
 "2 + 2 â‰  5": "2 + 2 â‰  5",
 "1 â‰  0": "1 â‰  0",
 "0 â‰¤ x": "0 â‰¤ x",
 "*Game version: 4.2*\n\n*Recent additions: Inequality world, algorithm world*\n\n## Progress saving\n\nThe game stores your progress in your local browser storage.\nIf you delete it, your progress will be lost!\n\nWarning: In most browsers, deleting cookies will also clear the local storage\n(or \"local site data\"). Make sure to download your game progress first!\n\n## Credits\n\n* **Creators:** Kevin Buzzard, Jon Eugster\n* **Original Lean3-version:** Kevin Buzzard, Mohammad Pedramfar\n* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n* **Additional levels:** Sian Carey, Ivan Farabella, Archie Browne.\n* **Additional thanks:** All the student beta testers, all the schools\nwho invited Kevin to speak, and all the schoolkids who asked him questions\nabout the material.\n\n## Resources\n\n* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n* [Original Lean3 version](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/) (no longer maintained)\n\n## Problems?\n\nPlease ask any questions about this game in the\n[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\nthe stream \"New Members\". The community will happily help. Note that\nthe Lean Zulip chat is a professional research forum.\nPlease use your full real name there, stay on topic, and be nice. If you're\nlooking for somewhere less formal (e.g. you want to post natural number\ngame memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n\nAlternatively, if you experience issues / bugs you can also open github issues:\n\n* For issues with the game engine, please open an\n[issue at the lean4game](https://github.com/leanprover-community/lean4game/issues) repo.\n* For issues about the game's content, please open an\n[issue at the NNG](https://github.com/hhu-adam/NNG4/issues) repo.":
 "*æ¸¸æˆç‰ˆæœ¬ï¼š4.2*\n\n*æœ€è¿‘æ–°å¢ï¼šä¸ç­‰å¼ä¸–ç•Œï¼Œç®—æ³•ä¸–ç•Œ*\n\n## è¿›åº¦ä¿å­˜\n\næ¸¸æˆä¼šå°†ä½ çš„è¿›åº¦å­˜å‚¨åœ¨æœ¬åœ°æµè§ˆå™¨å­˜å‚¨ä¸­ã€‚\nå¦‚æœä½ åˆ é™¤å®ƒï¼Œä½ çš„è¿›åº¦å°†ä¼šä¸¢å¤±ï¼\n\nè­¦å‘Šï¼šåœ¨å¤§å¤šæ•°æµè§ˆå™¨ä¸­ï¼Œåˆ é™¤ cookie ä¹Ÿä¼šæ¸…é™¤æœ¬åœ°å­˜å‚¨ï¼ˆæˆ–â€œæœ¬åœ°ç½‘ç«™æ•°æ®â€ï¼‰ã€‚ç¡®ä¿é¦–å…ˆä¸‹è½½ä½ çš„æ¸¸æˆè¿›åº¦ï¼\n\n## è‡´è°¢\n\n* **åˆ›å»ºè€…ï¼š** Kevin Buzzard, Jon Eugster\n* **åŸå§‹ Lean3 ç‰ˆæœ¬ï¼š** Kevin Buzzard, Mohammad Pedramfar\n* **æ¸¸æˆå¼•æ“ï¼š** Alexander Bentkamp, Jon Eugster, Patrick Massot\n* **é¢å¤–å…³å¡ï¼š** Sian Carey, Ivan Farabella, Archie Browne.\n* **ç‰¹åˆ«æ„Ÿè°¢ï¼š** æ‰€æœ‰å­¦ç”Ÿæµ‹è¯•è€…ï¼Œæ‰€æœ‰é‚€è¯· Kevin å‘è¡¨æ¼”è®²çš„å­¦æ ¡ï¼Œä»¥åŠå‘ä»–æå‡ºå…³äºææ–™é—®é¢˜çš„æ‰€æœ‰å­¦ç”Ÿã€‚\n\n## èµ„æº\n\n* [Lean Zulip èŠå¤©](https://leanprover.zulipchat.com/) è®ºå›\n* [åŸå§‹ Lean3 ç‰ˆæœ¬](https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/)ï¼ˆä¸å†ç»´æŠ¤ï¼‰\n\n## æœ‰é—®é¢˜å—ï¼Ÿ\n\nè¯·åœ¨ [Lean Zulip èŠå¤©](https://leanprover.zulipchat.com/) è®ºå›æå‡ºå…³äºè¿™ä¸ªæ¸¸æˆçš„ä»»ä½•é—®é¢˜ï¼Œä¾‹å¦‚åœ¨ â€œæ–°æˆå‘˜â€ æµä¸­ã€‚ç¤¾åŒºä¼šä¹æ„å¸®å¿™ã€‚è¯·æ³¨æ„ï¼ŒLean Zulip èŠå¤©æ˜¯ä¸€ä¸ªä¸“ä¸šç ”ç©¶è®ºå›ã€‚è¯·ä½¿ç”¨æ‚¨çš„å…¨åï¼Œä¿æŒè¯é¢˜ç›¸å…³ï¼Œä¸”å‹å¥½ã€‚å¦‚æœä½ æ­£åœ¨å¯»æ‰¾ä¸€ä¸ªä¸é‚£ä¹ˆæ­£å¼çš„åœ°æ–¹ï¼ˆä¾‹å¦‚ï¼Œä½ æƒ³å‘å¸ƒè‡ªç„¶æ•°æ¸¸æˆçš„è¡¨æƒ…åŒ…ï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥å‰å¾€ [Lean Discord](https://discord.gg/WZ9bs9UCvx)ã€‚\n\nå¦å¤–ï¼Œå¦‚æœä½ é‡åˆ°é—®é¢˜/æ¼æ´ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨ github ä¸Šæå‡ºé—®é¢˜ï¼š\n\n* å¯¹äºæ¸¸æˆå¼•æ“çš„é—®é¢˜ï¼Œè¯·åœ¨ [lean4game](https://github.com/leanprover-community/lean4game/issues) ä»“åº“æå‡ºé—®é¢˜ã€‚\n* å¯¹äºæ¸¸æˆå†…å®¹çš„é—®é¢˜ï¼Œè¯·åœ¨ [NNG](https://github.com/hhu-adam/NNG4/issues) ä»“åº“æå‡ºé—®é¢˜ã€‚",
 "$x=37\\implies x=37$.": "$x=37\\implies x=37$ ã€‚",
 "$x+y=x\\implies y=0$.": "$x+y=x\\implies y=0$.",
 "$x+1=y+1 \\implies x=y$.": "$x+1=y+1\\implies x=y$ã€‚",
 "$x + y = y\\implies x=0.$": "$x + y = y\\implies x=0$ ã€‚",
 "$n+a=n+b\\implies a=b$.": "$n+a=n+b\\implies a=b$ ã€‚",
 "$a+n=b+n\\implies a=b$.": "$a+n=b+n\\implies a=b$ã€‚",
 "$a+(b+0)+(c+0)=a+b+c.$": "$a+(b+0)+(c+0)=a+b+c$ ã€‚",
 "$\\operatorname{succ}(a) \\neq 0$.": "$\\operatorname{succ}(a) \\neq 0$.",
 "$20+20=40$.": "$20+20=40$.",
 "$2+2â‰ 5$.": "$2+2â‰ 5$.",
 "$2+2=4$.": "$2+2=4$ã€‚",
 "$2+2 \\neq 5.$": "$2+2 \\neq 5.$",
 "$2$ is the number after the number after $0$.": "$2$ æ˜¯ $0$ ä¹‹åå†ä¹‹åçš„æ•°å­—ã€‚",
 "$1\\neq0$.": "$1\\neq0$ ã€‚",
 "$0\\neq1$.": "$0\\neq1$ ã€‚",
 "$0 ^ 0 = 1$": "$0 ^ 0 = 1$",
 "## The birth of number.\n\nNumbers in Lean are defined by two rules.\n\n* `0` is a number.\n* If `n` is a number, then the *successor* `succ n` of `n` is a number.\n\nThe successor of `n` means the number after `n`. Let's learn to\ncount, and name a few small numbers.\n\n## Counting to four.\n\n`0` is a number, so `succ 0` is a number. Let's call this new number `1`.\nSimilarly let's define `2 = succ 1`, `3 = succ 2` and `4 = succ 3`.\nThis gives us plenty of numbers to be getting along with.\n\nThe *proof* that `2 = succ 1` is called `two_eq_succ_one`.\nCheck out the \"012\" tab in the list of lemmas on the right\nfor this and other proofs.\n\nLet's prove that $2$ is the number after the number after zero.":
 "## è‡ªç„¶æ•°çš„å®šä¹‰\n\nåœ¨ Lean ä¸­ï¼Œè‡ªç„¶æ•°çš„å®šä¹‰åŸºäºä¸¤ä¸ªç®€å•çš„è§„åˆ™ï¼š\n\n* `0` è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n* å¦‚æœ `n` æ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œé‚£ä¹ˆ `n` çš„*åç»§æ•°* `succ n` ä¹Ÿæ˜¯ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n\nè¿™é‡Œï¼Œ`n`çš„åç»§æ•°æŒ‡çš„æ˜¯ç´§è·Ÿåœ¨ `n` ä¹‹åçš„è‡ªç„¶æ•°ã€‚è®©æˆ‘ä»¬é€šè¿‡è¿™ç§æ–¹å¼æ¥è®¡æ•°ï¼Œå¹¶ä¸ºä¸€äº›å°æ•°å­—å‘½åã€‚\n\n## è®¡æ•°è‡³å››\n\nç”±äº `0` æ˜¯è‡ªç„¶æ•°ï¼Œå› æ­¤ `succ 0`ï¼ˆ`0`çš„åç»§æ•°ï¼‰ä¹Ÿæ˜¯è‡ªç„¶æ•°ã€‚æˆ‘ä»¬å°†è¿™ä¸ªæ–°çš„è‡ªç„¶æ•°å‘½åä¸º `1`ã€‚\nåŒæ ·çš„é€»è¾‘ï¼Œæˆ‘ä»¬å®šä¹‰ `2 = succ 1`ã€`3 = succ 2` å’Œ `4 = succ 3`ã€‚\nè¿™æ ·ï¼Œæˆ‘ä»¬å°±æ‹¥æœ‰äº†è¶³å¤Ÿçš„æ•°å­—å»åº”å¯¹æ¥ä¸‹æ¥çš„æŒ‘æˆ˜ã€‚\n\nè¯æ˜ `2 = succ 1` çš„å®šç†è¢«ç§°ä¸º `two_eq_succ_one`ã€‚\nè¯·æŸ¥é˜…å³ä¾§å®šç†åˆ—è¡¨ä¸­çš„â€œ012â€æ ‡ç­¾ï¼Œä»¥äº†è§£è¿™ä¸ªè¯æ˜åŠå…¶ä»–ç›¸å…³çš„è¯æ˜ã€‚\n\nç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥è¯æ˜ $2$ æ˜¯ä»é›¶å¼€å§‹åçš„ç¬¬äºŒä¸ªæ•°å­—ã€‚",
 "## Summary\n\n`rfl` proves goals of the form `X = X`.\n\nIn other words, the `rfl` tactic will close any goal of the\nform `A = B` if `A` and `B` are *identical*.\n\n`rfl` is short for \\\"reflexivity (of equality)\\\".\n\n## Example:\n\nIf the goal looks like this:\n\n```\nx + 37 = x + 37\n```\n\nthen `rfl` will close it. But if it looks like `0 + x = x` then `rfl` won't work, because even\nthough $0+x$ and $x$ are always equal as *numbers*, they are not equal as *terms*.\nThe only term which is identical to `0 + x` is `0 + x`.\n\n## Details\n\n`rfl` is short for \\\"reflexivity of equality\\\".\n\n## Game Implementation\n\n*Note that our `rfl` is weaker than the version used in core Lean and `mathlib`,\nfor pedagogical purposes; mathematicians do not distinguish between propositional\nand definitional equality because they think about definitions in a different way\nto type theorists (`zero_add` and `add_zero` are both \\\"facts\\\" as far\nas mathematicians are concerned, and who cares what the definition of addition is).*":
 "## æ‘˜è¦\n\n`rfl` è¯æ˜å½¢å¦‚ `X = X` çš„ç›®æ ‡ã€‚\n\næ¢å¥è¯è¯´ï¼Œå¦‚æœ `A` å’Œ `B` *å®Œå…¨ç›¸åŒ*ï¼Œ`rfl` ç­–ç•¥å°†è¯æ˜å½¢å¦‚ `A = B` çš„ç›®æ ‡ã€‚\n\n`rfl` æ˜¯ â€œreflexivityï¼ˆç­‰ä»·å…³ç³»çš„åèº«æ€§ï¼‰â€çš„ç¼©å†™ã€‚\n\n## ç¤ºä¾‹ï¼š\n\nå¦‚æœç›®æ ‡å¦‚ä¸‹ï¼š\n\n```\nx + 37 = x + 37\n```\n\né‚£ä¹ˆ `rfl` å°†è¯æ˜å®ƒã€‚ä½†å¦‚æœå®ƒçœ‹èµ·æ¥åƒ `0 + x = x`ï¼Œé‚£ä¹ˆ `rfl` å°†æ— æ³•å·¥ä½œï¼Œå› ä¸ºå³ä½¿ $0+x$ å’Œ $x$ ä½œä¸º*æ•°å­—*æ€»æ˜¯ç›¸ç­‰ï¼Œä½†å®ƒä»¬ä½œä¸º*é¡¹*å¹¶ä¸ç›¸ç­‰ã€‚å”¯ä¸€ä¸ `0 + x` ç›¸åŒçš„é¡¹æ˜¯ `0 + x`ã€‚\n\n\n## è¯¦ç»†ä¿¡æ¯\n\n`rfl` æ˜¯ â€œreflexivity of equalityï¼ˆç­‰ä»·å…³ç³»çš„åèº«æ€§ï¼‰â€çš„ç¼©å†™ã€‚\n\n## æ¸¸æˆå®ç°\n\n*è¯·æ³¨æ„ï¼Œå‡ºäºæ•™å­¦ç›®çš„ï¼Œæˆ‘ä»¬çš„ `rfl` æ¯”æ ¸å¿ƒ Lean å’Œ `mathlib` ä¸­ä½¿ç”¨çš„ç‰ˆæœ¬å¼±ä¸€äº›ï¼›æ•°å­¦å®¶ä¸åŒºåˆ†å‘½é¢˜ç­‰ä»·å’Œå®šä¹‰ç­‰ä»·ï¼Œå› ä¸ºä»–ä»¬ä»¥ä¸åŒäºç±»å‹ç†è®ºå®¶çš„æ–¹å¼æ€è€ƒå®šä¹‰ï¼ˆå°±æ•°å­¦å®¶è€Œè¨€ï¼Œ`zero_add` å’Œ `add_zero` éƒ½æ˜¯ â€œäº‹å®â€ï¼Œè°ä¼šåœ¨ä¹åŠ æ³•çš„å®šä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼‰ã€‚*\nï¼ˆè¯‘æ³¨ï¼šå› ä¸º `add_zero` æ˜¯åŠ æ³•å®šä¹‰çš„ä¸€éƒ¨åˆ†ï¼Œè€Œå®šä¹‰ç­‰ä»·æ˜¯å¯ä»¥ç›´æ¥ç”¨ `rfl` è¯æ˜çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ `x + 0 = x` å¯ä»¥ç”¨ `rfl` è¯æ˜ã€‚æ‰€ä»¥ä½œè€…å¤šäº†ä¸€å˜´ï¼Œä½†å®é™…ä¸Šå› ä¸ºå¾ˆå°‘æœ‰äººçŸ¥é“ç±»å‹ç†è®ºå®¶æ€ä¹ˆæ€è€ƒï¼Œæ‰€ä»¥è¿™ä¸ªæ³¨è§£çœ‹èµ·æ¥ä¼šæœ‰äº›å¥‡æ€ªã€‚ï¼‰",
 "## Summary\n\n`repeat t` repeatedly applies the tactic `t`\nto the goal. You don't need to use this\ntactic, it just speeds things up sometimes.\n\n## Example\n\n`repeat rw [add_zero]` will turn the goal\n`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\ninto the goal\n`a = b`.\n\"\n\nTacticDoc nth_rewrite \"\n## Summary\n\nIf `h : X = Y` and there are several `X`s in the goal, then\n`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n\n## Example\n\nIf the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\nwill change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\nwill change the goal to `succ 1 + succ 1 = 4`.":
 "## å°ç»“\n\n`repeat t` åå¤åº”ç”¨ç­–ç•¥ `t` åˆ°ç›®æ ‡ä¸Šã€‚è¿™ä¸ªæ˜¯ä¸ªå¯é€‰ç­–ç•¥ï¼Œå®ƒåªæ˜¯æœ‰æ—¶å¯ä»¥èŠ‚çœæ­¥éª¤ã€‚\n\n## ç¤ºä¾‹\n\n`repeat rw [add_zero]` ä¼šå°†ç›®æ ‡\n`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\nå˜ä¸º\n`a = b`ã€‚",
 "## Summary\n\n`repeat t` repeatedly applies the tactic `t`\nto the goal. You don't need to use this\ntactic, it just speeds things up sometimes.\n\n## Example\n\n`repeat rw [add_zero]` will turn the goal\n`a + 0 + (0 + (0 + 0)) = b + 0 + 0`\ninto the goal\n`a = b`.":
 "## å°ç»“\n\n`repeat t` ä¼šé‡å¤åº”ç”¨ç­–ç•¥ `t` åˆ°ç›®æ ‡ä¸Šã€‚ä½ ä¸ä¸€å®šè¦ä½¿ç”¨è¿™ä¸ªç­–ç•¥ï¼Œå®ƒæœ‰æ—¶åªæ˜¯åŠ å¿«äº†é€Ÿåº¦ã€‚\n\n## ç¤ºä¾‹\n\n`repeat rw [add_zero]` ä¼šå°†ç›®æ ‡ `a + 0 + (0 + (0 + 0)) = b + 0 + 0` è½¬å˜ä¸ºç›®æ ‡ `a = b`ã€‚",
 "## Summary\n\nThe `use` tactic makes progress with goals which claim something *exists*.\nIf the goal claims that some `x` exists with some property, and you know\nthat `x = 37` will work, then `use 37` will make progress.\n\nBecause `a â‰¤ b` is notation for \\\"there exists `c` such that `b = a + c`\\\",\nyou can make progress on goals of the form `a â‰¤ b` by `use`ing the\nnumber which is morally `b - a`.":
 "## å°ç»“\n\n`use` ç­–ç•¥èƒ½ç”¨åœ¨å£°ç§°æŸäº›ä¸œè¥¿ *å­˜åœ¨* çš„ç›®æ ‡ä¸Šã€‚\nå¦‚æœç›®æ ‡å£°ç§°æŸäº› `x` å­˜åœ¨å¹¶å…·æœ‰æŸäº›å±æ€§ï¼Œå¹¶ä¸”æ‚¨çŸ¥é“\n`x = 37` å°†èµ·ä½œç”¨ï¼Œé‚£ä¹ˆä½¿ç”¨ `use 37` æ¥æ”¹å†™ç›®æ ‡ã€‚\n\nå› ä¸º `a â‰¤ b` æ˜¯ç”¨ â€œå­˜åœ¨ `c` ä½¿å¾— `b = a + c`â€ å®šä¹‰çš„ï¼Œ\næ‰€ä»¥å¯ä»¥é€šè¿‡`use (b - a)` åœ¨ `a â‰¤ b` å½¢å¼çš„ç›®æ ‡ä¸Šå–å¾—è¿›å±•ã€‚",
 "## Summary\n\nThe `symm` tactic will change a goal or hypothesis of\nthe form `X = Y` to `Y = X`. It will also work on `X â‰  Y`\nand on `X â†” Y`.\n\n### Example\n\nIf the goal is `2 + 2 = 4` then `symm` will change it to `4 = 2 + 2`.\n\n### Example\n\nIf `h : 2 + 2 â‰  5` then `symm at h` will change `h` to `5 â‰  2 + 2`.":
 "## å°ç»“\n\n`symm` ç­–ç•¥ä¼šå°†å½¢å¦‚ `X = Y` çš„ç›®æ ‡æˆ–å‡è®¾è½¬æ¢ä¸º `Y = X`ã€‚å®ƒä¹Ÿé€‚ç”¨äº `X â‰  Y` å’Œ `X â†” Y`ã€‚\n\n### ä¾‹å­\n\nå¦‚æœç›®æ ‡æ˜¯ `2 + 2 = 4`ï¼Œé‚£ä¹ˆ `symm` ä¼šå°†å…¶è½¬æ¢ä¸º `4 = 2 + 2`ã€‚\n\n### ä¾‹å­\n\nå¦‚æœ `h : 2 + 2 â‰  5`ï¼Œé‚£ä¹ˆ `symm at h` ä¼šå°† `h` è½¬æ¢ä¸º `5 â‰  2 + 2`ã€‚",
 "## Summary\n\nIf the goal is a statement `P`, then `exact h` will close the goal if `h` is a proof of `P`.\n\n### Example\n\nIf the goal is `x = 37` and you have a hypothesis `h : x = 37`\nthen `exact h` will solve the goal.\n\n### Example\n\nIf the goal is `x + 0 = x` then `exact add_zero x` will close the goal.\n\n### Exact needs to be exactly right\n\nNote that `exact add_zero` will *not work* in the previous example;\nfor `exact h` to work, `h` has to be *exactly* a proof of the goal.\n`add_zero` is a proof of `âˆ€ n, n + 0 = n` or, if you like,\na proof of `? + 0 = ?` where `?` needs to be supplied by the user.\nThis is in contrast to `rw` and `apply`, which will \\\"guess the inputs\\\"\nif necessary. If the goal is `x + 0 = x` then `rw [add_zero]`\nand `rw [add_zero x]` will both change the goal to `x = x`,\nbecause `rw` guesses the input to the function `add_zero`.":
 "## å°ç»“\n\nå¦‚æœç›®æ ‡æ˜¯ `P`ï¼Œé‚£ä¹ˆå¦‚æœ `h` æ˜¯ `P` çš„è¯æ˜ï¼Œ`exact h` å°†è¯æ˜ç›®æ ‡ã€‚\n\n#### ç¤ºä¾‹\n\nå¦‚æœç›®æ ‡æ˜¯ `x = 37`ï¼Œå‡è®¾æ˜¯ `h : x = 37`\nåˆ™ `exact h` å°†è§£å†³ç›®æ ‡ã€‚\n\n### ç¤ºä¾‹\n\nå¦‚æœç›®æ ‡æ˜¯ `x + 0 = x`ï¼Œé‚£ä¹ˆ `exact add_zero x` å°†è¯æ˜ç›®æ ‡ã€‚\n\n### ç²¾ç¡®éœ€è¦å®Œå…¨æ­£ç¡®\n\nè¯·æ³¨æ„ï¼Œ`exact add_zero` åœ¨ä¸Šä¾‹ä¸­ *ä¸èµ·ä½œç”¨*ï¼›\nè¦è®© `exact h` èµ·ä½œç”¨ï¼Œ`h` å¿…é¡»*å®Œå…¨*æ˜¯ç›®æ ‡çš„è¯æ˜ã€‚\n`add_zero` æ˜¯ `âˆ€ n, n + 0 = n` çš„è¯æ˜ï¼Œæˆ–è€…ï¼Œå¦‚æœä½ æ„¿æ„çš„è¯ã€\n`? + 0 = ?` çš„è¯æ˜ï¼Œå…¶ä¸­ `?` éœ€è¦ç”±ç”¨æˆ·æä¾›ã€‚\nè¿™ä¸ `rw` å’Œ `apply` ä¸åŒï¼Œå®ƒä»¬ä¼šåœ¨å¿…è¦æ—¶ \"çŒœæµ‹è¾“å…¥\"ã€‚\nå¦‚æœéœ€è¦çš„è¯ã€‚å¦‚æœç›®æ ‡æ˜¯ `x + 0 = x`ï¼Œé‚£ä¹ˆ `rw [add_zero]`\nå’Œ `rw [add_zero x]` éƒ½ä¼šå°†ç›®æ ‡æ”¹ä¸º `x = x`ã€\nå› ä¸º `rw` çŒœåˆ°äº†å‡½æ•° `add_zero` çš„è¾“å…¥ã€‚",
 "## Summary\n\nIf the goal is `P â†’ Q`, then `intro h` will introduce `h : P` as a hypothesis,\nand change the goal to `Q`. Mathematically, it says that to prove $P \\implies Q$,\nwe can assume $P$ and then prove $Q$.\n\n### Example:\n\nIf your goal is `x + 1 = y + 1 â†’ x = y` (the way Lean writes $x+1=y+1 \\implies x=y$)\nthen `intro h` will give you a hypothesis $x+1=y+1$ named `h`, and the goal\nwill change to $x=y$.":
 "## å°ç»“\n\nå¦‚æœç›®æ ‡æ˜¯ `P â†’ Q`ï¼Œé‚£ä¹ˆ `intro h` å°†å¼•å…¥ `h : P` ä½œä¸ºå‡è®¾ï¼Œ\nå¹¶å°†ç›®æ ‡æ›´æ”¹ä¸º `Q`ã€‚ä»æ•°å­¦ä¸Šè®²ï¼Œè¦è¯æ˜ $P\\implies Q$ï¼Œ\næˆ‘ä»¬å¯ä»¥å‡è®¾ $P$ ï¼Œç„¶åè¯æ˜ $Q$ ã€‚\n\n### ä¾‹å­ï¼š\n\nå¦‚æœæ‚¨çš„ç›®æ ‡æ˜¯ `x + 1 = y + 1 â†’ x = y` ï¼ˆåœ¨Leanä¸­è¿™è¡¨ç¤º $x+1=y+1\\implies x=y$ ï¼‰\né‚£ä¹ˆ `intro h` ä¼šç»™ä½ ä¸€ä¸ªåä¸º `h` çš„å‡è®¾ $x+1=y+1$ ï¼Œç›®æ ‡\nä¹ŸåŒæ—¶æ›´æ”¹ä¸º $x=y$ã€‚",
 "## Summary\n\nIf `t : P â†’ Q` is a proof that $P \\implies Q$, and `h : P` is a proof of `P`,\nthen `apply t at h` will change `h` to a proof of `Q`. The idea is that if\nyou know `P` is true, then you can deduce from `t` that `Q` is true.\n\nIf the *goal* is `Q`, then `apply t` will \\\"argue backwards\\\" and change the\ngoal to `P`. The idea here is that if you want to prove `Q`, then by `t`\nit suffices to prove `P`, so you can reduce the goal to proving `P`.\n\n### Example:\n\n`succ_inj x y` is a proof that `succ x = succ y â†’ x = y`.\n\nSo if you have a hypothesis `h : succ (a + 37) = succ (b + 42)`\nthen `apply succ_inj at h` will change `h` to `a + 37 = b + 42`.\nYou could write `apply succ_inj (a + 37) (b + 42) at h`\nbut Lean is smart enough to figure out the inputs to `succ_inj`.\n\n### Example\n\nIf the goal is `a * b = 7`, then `apply succ_inj` will turn the\ngoal into `succ (a * b) = succ 7`.":
 "## å°ç»“\n\nå¦‚æœ `t : P â†’ Q` æ˜¯ä¸€ä¸ª $P\\implies Q$ çš„è¯æ˜ï¼Œè€Œ `h : P` æ˜¯ä¸€ä¸ª `P` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `apply t at h` ä¼šå°† `h` è½¬æ¢ä¸ºè¯æ˜ `Q`ã€‚å…¶åŸç†æ˜¯ï¼Œå¦‚æœæ‚¨çŸ¥é“ `P` ä¸ºçœŸï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥ä» `t` æ¨æ–­å‡º `Q` ä¸ºçœŸã€‚\n\nå¦‚æœ*ç›®æ ‡*æ˜¯ `Q`ï¼Œé‚£ä¹ˆ `apply t` ä¼šâ€œé€†å‘æ¨ç†â€å¹¶å°†ç›®æ ‡è½¬æ¢ä¸º `P`ã€‚åœ¨è¿™é‡Œï¼Œå¦‚æœæ‚¨æƒ³è¯æ˜ `Q`ï¼Œé‚£ä¹ˆæ ¹æ® `t`ï¼Œåªéœ€è¯æ˜ `P` å³å¯ï¼Œå› æ­¤æ‚¨å¯ä»¥å°†ç›®æ ‡ç®€åŒ–ä¸ºè¯æ˜ `P`ã€‚\n\n### ç¤ºä¾‹ï¼š\n\n`succ_inj x y` æ˜¯ä¸€ä¸ª `succ x = succ y â†’ x = y` çš„è¯æ˜ã€‚\n\nå› æ­¤ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ªå‡è®¾ `h : succ (a + 37) = succ (b + 42)`ï¼Œé‚£ä¹ˆ `apply succ_inj at h` ä¼šå°† `h` è½¬æ¢ä¸º `a + 37 = b + 42`ã€‚æ‚¨å¯ä»¥å†™ `apply succ_inj (a + 37) (b + 42) at h`ï¼Œä½† Lean è¶³å¤Ÿèªæ˜ï¼Œå¯ä»¥è‡ªè¡Œæ¨æ–­å‡º `succ_inj` çš„è¾“å…¥ã€‚\n\n### ç¤ºä¾‹ï¼š\n\nå¦‚æœç›®æ ‡æ˜¯ `a * b = 7`ï¼Œé‚£ä¹ˆ `apply succ_inj` ä¼šå°†ç›®æ ‡è½¬æ¢ä¸º `succ (a * b) = succ 7`ã€‚",
 "## Summary\n\nIf `n` is a number, then `cases n with d` will break the goal into two goals,\none with `n = 0` and the other with `n = succ d`.\n\nIf `h` is a proof (for example a hypothesis), then `cases h with...` will break the\nproof up into the pieces used to prove it.\n\n## Example\n\nIf `n : â„•` is a number, then `cases n with d` will break the goal into two goals,\none with `n` replaced by 0 and the other with `n` replaced by `succ d`. This\ncorresponds to the mathematical idea that every natural number is either `0`\nor a successor.\n\n## Example\n\nIf `h : P âˆ¨ Q` is a hypothesis, then `cases h with hp hq` will turn one goal\ninto two goals, one with a hypothesis `hp : P` and the other with a\nhypothesis `hq : Q`.\n\n## Example\n\nIf `h : False` is a hypothesis, then `cases h` will turn one goal into no goals,\nbecause there are no ways to make a proof of `False`! And if you have no goals left,\nyou have finished the level.\n\n## Example\n\nIf `h : a â‰¤ b` is a hypothesis, then `cases h with c hc` will create a new number `c`\nand a proof `hc : b = a + c`. This is because the *definition* of `a â‰¤ b` is\n`âˆƒ c, b = a + c`.":
 "## å°ç»“\n\nå¦‚æœ `n` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases n with d` ä¼šå°†ç›®æ ‡åˆ†è§£æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `n = 0`ï¼Œå¦ä¸€ä¸ªæ˜¯ `n = succ d`ã€‚\n\nå¦‚æœ `h` æ˜¯ä¸€ä¸ªè¯æ˜ï¼ˆä¾‹å¦‚ä¸€ä¸ªå‡è®¾ï¼‰ï¼Œé‚£ä¹ˆ `cases h with...` ä¼šå°†è¯æ˜åˆ†è§£æˆç”¨æ¥è¯æ˜å®ƒçš„å„ä¸ªéƒ¨åˆ†ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœ `n : â„•` æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆ `cases n with d` ä¼šå°†ç›®æ ‡åˆ†è§£æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæ˜¯ `n` è¢«æ›¿æ¢ä¸º 0ï¼Œå¦ä¸€ä¸ªæ˜¯ `n` è¢«æ›¿æ¢ä¸º `succ d`ã€‚è¿™å¯¹åº”äºæ•°å­¦ä¸Šçš„è§‚ç‚¹ï¼Œå³æ¯ä¸ªè‡ªç„¶æ•°è¦ä¹ˆæ˜¯ `0`ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªåç»§æ•°ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœ `h : P âˆ¨ Q` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h with hp hq` ä¼šå°†ä¸€ä¸ªç›®æ ‡å˜æˆä¸¤ä¸ªç›®æ ‡ï¼Œä¸€ä¸ªæœ‰å‡è®¾ `hp : P`ï¼Œå¦ä¸€ä¸ªæœ‰å‡è®¾ `hq : Q`ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœ `h : False` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h` ä¼šå°†ä¸€ä¸ªç›®æ ‡å˜æˆæ²¡æœ‰ç›®æ ‡ï¼Œå› ä¸ºæ²¡æœ‰æ–¹æ³•å¯ä»¥è¯æ˜ `False`ï¼å¦‚æœä½ æ²¡æœ‰å‰©ä½™çš„ç›®æ ‡ï¼Œä½ å°±å®Œæˆäº†è¿™ä¸ªå…³å¡ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœ `h : a â‰¤ b` æ˜¯ä¸€ä¸ªå‡è®¾ï¼Œé‚£ä¹ˆ `cases h with c hc` ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ•°å­— `c` å’Œä¸€ä¸ªè¯æ˜ `hc : b = a + c`ã€‚è¿™æ˜¯å› ä¸º `a â‰¤ b` çš„*å®šä¹‰*æ˜¯ `âˆƒ c, b = a + c`ã€‚",
 "## Summary\n\nIf `n : â„•` is an object, and the goal mentions `n`, then `induction n with d hd`\nattempts to prove the goal by induction on `n`, with the inductive\nvariable in the successor case being `d`, and the inductive hypothesis being `hd`.\n\n### Example:\nIf the goal is\n```\n0 + n = n\n```\n\nthen\n\n`induction n with d hd`\n\nwill turn it into two goals. The first is `0 + 0 = 0`;\nthe second has an assumption `hd : 0 + d = d` and goal\n`0 + succ d = succ d`.\n\nNote that you must prove the first\ngoal before you can access the second one.":
 "## æ‘˜è¦\n\nå¦‚æœ `n : â„•` æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”ç›®æ ‡æåˆ°äº† `n`ï¼Œé‚£ä¹ˆ `induction n with d hd`\nå°è¯•é€šè¿‡å¯¹ `n` è¿›è¡Œå½’çº³æ¥è¯æ˜ç›®æ ‡ï¼Œå…¶ä¸­åç»§æ•°æƒ…å†µä¸‹çš„å½’çº³å˜é‡æ˜¯ `d`ï¼Œå½’çº³å‡è®¾æ˜¯ `hd`ã€‚\n\n### ä¾‹å­:\nå¦‚æœç›®æ ‡æ˜¯\n```\n0 + n = n\n```\n\né‚£ä¹ˆ\n\n`induction n with d hd`\n\nå°†æŠŠå®ƒå˜æˆä¸¤ä¸ªç›®æ ‡ã€‚ç¬¬ä¸€ä¸ªæ˜¯ `0 + 0 = 0`ï¼›\nç¬¬äºŒä¸ªæœ‰ä¸€ä¸ªå‡è®¾ `hd : 0 + d = d` å’Œç›®æ ‡\n`0 + succ d = succ d` ã€‚\n\næ³¨æ„ä½ å¿…é¡»å…ˆè¯æ˜ç¬¬ä¸€ä¸ªç„¶åæ‰èƒ½è¯ç¬¬äºŒä¸ªã€‚",
 "## Summary\n\nIf `h` is a proof of an equality `X = Y`, then `rw [h]` will change\nall `X`s in the goal to `Y`s. It's the way to \\\"substitute in\\\".\n\n## Variants\n\n* `rw [â† h]` (changes `Y`s to `X`s; get the back arrow by typing `\\left ` or `\\l`.)\n\n* `rw [h1, h2]` (a sequence of rewrites)\n\n* `rw [h] at h2` (changes `X`s to `Y`s in hypothesis `h2`)\n\n* `rw [h] at h1 h2 âŠ¢` (changes `X`s to `Y`s in two hypotheses and the goal;\nget the `âŠ¢` symbol with `\\|-`.)\n\n* `repeat rw [add_zero]` will keep changing `? + 0` to `?`\nuntil there are no more matches for `? + 0`.\n\n* `nth_rewrite 2 [h]` will change only the second `X` in the goal to `Y`.\n\n### Example:\n\nIf you have the assumption `h : x = y + y` and your goal is\n```\nsucc (x + 0) = succ (y + y)\n```\n\nthen\n\n`rw [add_zero]`\n\nwill change the goal into `succ x = succ (y + y)`, and then\n\n`rw [h]`\n\nwill change the goal into `succ (y + y) = succ (y + y)`, which\ncan be solved with `rfl`.\n\n### Example:\n\nYou can use `rw` to change a hypothesis as well.\nFor example, if you have two hypotheses\n```\nh1 : x = y + 3\nh2 : 2 * y = x\n```\nthen `rw [h1] at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n\n## Common errors\n\n* You need the square brackets. `rw h` is never correct.\n\n* If `h` is not a *proof* of an *equality* (a statement of the form `A = B`),\nfor example if `h` is a function or an implication,\nthen `rw` is not the tactic you want to use. For example,\n`rw [P = Q]` is never correct: `P = Q` is the theorem *statement*,\nnot the proof. If `h : P = Q` is the proof, then `rw [h]` will work.\n\n## Details\n\nThe `rw` tactic is a way to do \\\"substituting in\\\". There\nare two distinct situations where you can use this tactic.\n\n1) Basic usage: if `h : A = B` is an assumption or\nthe proof of a theorem, and if the goal contains one or more `A`s, then `rw [h]`\nwill change them all to `B`'s. The tactic will error\nif there are no `A`s in the goal.\n\n2) Advanced usage: Assumptions coming from theorem proofs\noften have missing pieces. For example `add_zero`\nis a proof that `? + 0 = ?` because `add_zero` really is a function,\nand `?` is the input. In this situation `rw` will look through the goal\nfor any subterm of the form `x + 0`, and the moment it\nfinds one it fixes `?` to be `x` then changes all `x + 0`s to `x`s.\n\nExercise: think about why `rw [add_zero]` changes the term\n`(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` to\n`0 + (x + 0) + 0 + (x + 0)`\n\nIf you can't remember the name of the proof of an equality, look it up in\nthe list of lemmas on the right.\n\n## Targetted usage\n\nIf your goal is `b + c + a = b + (a + c)` and you want to rewrite `a + c`\nto `c + a`, then `rw [add_comm]` will not work because Lean finds another\naddition first and swaps those inputs instead. Use `rw [add_comm a c]` to\nguarantee that Lean rewrites `a + c` to `c + a`. This works because\n`add_comm` is a proof that `?1 + ?2 = ?2 + ?1`, `add_comm a` is a proof\nthat `a + ? = ? + a`, and `add_comm a c` is a proof that `a + c = c + a`.\n\nIf `h : X = Y` then `rw [h]` will turn all `X`s into `Y`s.\nIf you only want to change the 37th occurrence of `X`\nto `Y` then do `nth_rewrite 37 [h]`.":
 "## æ‘˜è¦\n\nå¦‚æœ `h` æ˜¯ä¸€ä¸ªç­‰å¼ `X = Y` çš„è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šæŠŠç›®æ ‡ä¸­æ‰€æœ‰çš„ `X` æ”¹ä¸º `Y`ã€‚è¿™æ˜¯ä¸€ç§â€œä»£å…¥â€çš„æ–¹å¼ã€‚\n\n## å˜ä½“\n\n* `rw [â† h]`ï¼ˆå°† `Y` æ”¹ä¸º `X`ï¼›é€šè¿‡è¾“å…¥ `\\left ` æˆ– `\\l` è·å–åå‘ç®­å¤´ã€‚ï¼‰\n\n* `rw [h1, h2]`ï¼ˆä¸€ç³»åˆ—é‡å†™ï¼‰\n\n* `rw [h] at h2`ï¼ˆåœ¨å‡è®¾ `h2` ä¸­å°† `X` æ”¹ä¸º `Y`ï¼‰\n\n* `rw [h] at h1 h2 âŠ¢`ï¼ˆåœ¨ä¸¤ä¸ªå‡è®¾å’Œç›®æ ‡ä¸­å°† `X` æ”¹ä¸º `Y`ï¼›é€šè¿‡è¾“å…¥ `\\|-` è·å– `âŠ¢` ç¬¦å·ã€‚ï¼‰\n\n* `repeat rw [add_zero]` å°†ä¼šä¸æ–­åœ°æŠŠ `? + 0` æ”¹ä¸º `?`ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šçš„ `? + 0` åŒ¹é…ä¸ºæ­¢ã€‚\n\n* `nth_rewrite 2 [h]` åªä¼šæŠŠç›®æ ‡ä¸­çš„ç¬¬äºŒä¸ª `X` æ”¹ä¸º `Y`ã€‚\n\n### ç¤ºä¾‹ï¼š\n\nå¦‚æœä½ æœ‰å‡è®¾ `h : x = y + y` å¹¶ä¸”ä½ çš„ç›®æ ‡æ˜¯\n```\nsucc (x + 0) = succ (y + y)\n```\n\né‚£ä¹ˆ\n\n`rw [add_zero]`\n\nå°†ä¼šæŠŠç›®æ ‡æ”¹ä¸º `succ x = succ (y + y)`ï¼Œç„¶å\n\n`rw [h]`\n\nå°†ä¼šæŠŠç›®æ ‡æ”¹ä¸º `succ (y + y) = succ (y + y)`ï¼Œè¿™ä¸ªå¯ä»¥é€šè¿‡ `rfl` è§£å†³ã€‚\n\n### ç¤ºä¾‹ï¼š\n\nä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ `rw` æ¥æ”¹å˜ä¸€ä¸ªå‡è®¾ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾\n```\nh1 : x = y + 3\nh2 : 2 * y = x\n```\né‚£ä¹ˆ `rw [h1] at h2` å°†ä¼šæŠŠ `h2` å˜ä¸º `h2 : 2 * y = y + 3`ã€‚\n\n## å¸¸è§é”™è¯¯\n\n* ä½ éœ€è¦æ–¹æ‹¬å·ã€‚`rw h` æ˜¯ä¸æ­£ç¡®çš„ã€‚\n\n* å¦‚æœ `h` ä¸æ˜¯ä¸€ä¸ª*ç­‰å¼*çš„*è¯æ˜*ï¼ˆå½¢å¼ä¸º `A = B` çš„å£°æ˜ï¼‰ï¼Œä¾‹å¦‚å¦‚æœ `h` æ˜¯ä¸€ä¸ªå‡½æ•°æˆ–è•´å«ï¼Œé‚£ä¹ˆ `rw` ä¸æ˜¯ä½ æƒ³è¦ä½¿ç”¨çš„ç­–ç•¥ã€‚ä¾‹å¦‚ï¼Œ`rw [P = Q]` æ°¸è¿œä¸æ­£ç¡®ï¼Œ å› ä¸º`P = Q` æ˜¯å®šç†çš„*é™ˆè¿°*ï¼Œè€Œä¸æ˜¯è¯æ˜ã€‚ä½†å¦‚æœ `h : P = Q` æ˜¯è¯æ˜ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šèµ·ä½œç”¨ã€‚\n\n## è¯¦æƒ…\n\n`rw` ç­–ç•¥æ˜¯ä¸€ç§è¿›è¡Œâ€œä»£å…¥â€çš„æ–¹å¼ã€‚æœ‰ä¸¤ç§ä¸åŒçš„æƒ…å†µä½ å¯ä»¥ä½¿ç”¨è¿™ä¸ªç­–ç•¥ã€‚\n\n1) åŸºæœ¬ä½¿ç”¨ï¼šå¦‚æœ `h : A = B` æ˜¯ä¸€ä¸ªå‡è®¾æˆ–å®šç†çš„è¯æ˜ï¼Œå¹¶ä¸”ç›®æ ‡ä¸­åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ª `A`ï¼Œé‚£ä¹ˆ `rw [h]` ä¼šæŠŠå®ƒä»¬å…¨éƒ¨æ”¹ä¸º `B`ã€‚å¦‚æœç›®æ ‡ä¸­æ²¡æœ‰ `A`ï¼Œç­–ç•¥ä¼šæŠ¥é”™ã€‚\n\n2) é«˜çº§ä½¿ç”¨ï¼šæ¥è‡ªå®šç†è¯æ˜çš„å‡è®¾ç»å¸¸æœ‰ç¼ºå¤±çš„éƒ¨åˆ†ã€‚ä¾‹å¦‚ `add_zero` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `? + 0 = ?`ï¼Œå› ä¸º `add_zero` å®é™…ä¸Šæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œè€Œ `?` æ˜¯è¾“å…¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`rw` ä¼šåœ¨ç›®æ ‡ä¸­æŸ¥æ‰¾ä»»ä½•å½¢å¼ä¸º `x + 0` çš„å­é¡¹ï¼Œä¸€æ—¦æ‰¾åˆ°ï¼Œå®ƒå°±å°† `?` å®šä½ä¸º `x`ï¼Œç„¶åæŠŠæ‰€æœ‰çš„ `x + 0` æ”¹ä¸º `x`ã€‚\n\nç»ƒä¹ ï¼šæ€è€ƒä¸ºä»€ä¹ˆ `rw [add_zero]` ä¼šæŠŠé¡¹ `(0 + 0) + (x + 0) + (0 + 0) + (x + 0)` æ”¹ä¸º `0 + (x + 0) + 0 + (x + 0)`\n\nå¦‚æœä½ ä¸èƒ½è®°ä½ç­‰å¼è¯æ˜çš„åç§°ï¼Œè¯·åœ¨å³ä¾§çš„å®šç†åˆ—è¡¨ä¸­æŸ¥æ‰¾ã€‚\n\n## é’ˆå¯¹æ€§ä½¿ç”¨\n\nå¦‚æœä½ çš„ç›®æ ‡æ˜¯ `b + c + a = b + (a + c)` å¹¶ä¸”ä½ æƒ³æŠŠ `a + c` é‡å†™ä¸º `c + a`ï¼Œé‚£ä¹ˆ `rw [add_comm]` å°†ä¸èµ·ä½œç”¨ï¼Œå› ä¸º Lean ä¼šå…ˆæ‰¾åˆ°å¦ä¸€ä¸ªåŠ æ³•å¹¶äº¤æ¢å®ƒã€‚ä½¿ç”¨ `rw [add_comm a c]` æ¥ä¿è¯ Lean å°† `a + c` é‡å†™ä¸º `c + a`ã€‚è¿™æ˜¯å› ä¸º `add_comm` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `?1 + ?2 = ?2 + ?1`ï¼Œ`add_comm a` æ˜¯ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `a + ? = ? + a`ï¼Œè€Œ `add_comm a c` æ˜¯å¦ä¸€ä¸ªè¯æ˜ï¼Œè¡¨ç¤º `a + c = c + a`ã€‚\n\nå¦‚æœ `h : X = Y`ï¼Œé‚£ä¹ˆ `rw [h]` å°†ä¼šæŠŠæ‰€æœ‰çš„ `X` å˜ä¸º `Y`ã€‚å¦‚æœä½ åªæƒ³æ”¹å˜ç¬¬37æ¬¡å‡ºç°çš„ `X` ä¸º `Y`ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ `nth_rewrite 37 [h]`ã€‚",
 "## Summary\n\nIf `h : X = Y` and there are several `X`s in the goal, then\n`nth_rewrite 3 [h]` will just change the third `X` to a `Y`.\n\n## Example\n\nIf the goal is `2 + 2 = 4` then `nth_rewrite 2 [two_eq_succ_one]`\nwill change the goal to `2 + succ 1 = 4`. In contrast, `rw [two_eq_succ_one]`\nwill change the goal to `succ 1 + succ 1 = 4`.":
 "## å°ç»“\n\nå¦‚æœ `h : X = Y` å¹¶ä¸”åœ¨ç›®æ ‡ä¸­æœ‰å¤šä¸ª `X`ï¼Œé‚£ä¹ˆ `nth_rewrite 3 [h]` å°†ä»…æ›´æ”¹ç¬¬ä¸‰ä¸ª `X` ä¸º `Y`ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœç›®æ ‡æ˜¯ `2 + 2 = 4`ï¼Œé‚£ä¹ˆ `nth_rewrite 2 [two_eq_succ_one]` å°†ç›®æ ‡æ›´æ”¹ä¸º `2 + succ 1 = 4`ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`rw [two_eq_succ_one]` å°†ç›®æ ‡æ›´æ”¹ä¸º `succ 1 + succ 1 = 4`ã€‚",
 "## Precision rewriting\n\nIn the last level, there was `b + 0` and `c + 0`,\nand `rw [add_zero]` changed the first one it saw,\nwhich was `b + 0`. Let's learn how to tell Lean\nto change `c + 0` first by giving `add_zero` an\nexplicit input.":
 "## ç²¾å‡†é‡å†™\n\nåœ¨ä¸Šä¸€ä¸ªå±‚çº§ä¸­ï¼Œæœ‰ `b + 0` å’Œ `c + 0`ï¼Œ\nè€Œ `rw [add_zero]` æ”¹å˜äº†å®ƒçœ‹åˆ°çš„ç¬¬ä¸€ä¸ªåŠ 0ï¼Œ\nä¹Ÿå°±æ˜¯ `b + 0`ã€‚è®©æˆ‘ä»¬å­¦ä¹ å¦‚ä½•å‘Šè¯‰ Lean\né€šè¿‡ç»™ `add_zero` ä¸€ä¸ªæ˜ç¡®çš„è¾“å…¥æ¥é¦–å…ˆæ”¹å˜ `c + 0`ã€‚",
 "# Welcome to the Natural Number Game\n#### An introduction to mathematical proof.\n\nIn this game, we will build the basic theory of the natural\nnumbers `{0,1,2,3,4,...}` from scratch. Our first goal is to prove\nthat `2 + 2 = 4`. Next we'll prove that `x + y = y + x`.\nAnd at the end we'll see if we can prove Fermat's Last Theorem.\nWe'll do this by solving levels of a computer puzzle game called Lean.\n\n# Read this.\n\nLearning how to use an interactive theorem prover takes time.\nTests show that the people who get the most out of this game are\nthose who read the help texts like this one.\n\nTo start, click on \"Tutorial World\".\n\nNote: this is a new Lean 4 version of the game containing several\nworlds which were not present in the old Lean 3 version. A new version\nof Advanced Multiplication World is in preparation, and worlds\nsuch as Prime Number World and more will be appearing during October and\nNovember 2023.\n\n## More\n\nClick on the three lines in the top right and select \"Game Info\" for resources,\nlinks, and ways to interact with the Lean community.":
 "# æ¬¢è¿è¿›å…¥è‡ªç„¶æ•°æ¸¸æˆ\n### æ•°å­¦è¯æ˜çš„å¯è’™ã€‚\n\næœ¬æ¸¸æˆå°†å¸¦é¢†æˆ‘ä»¬ä»å¤´å¼€å§‹æ„å»ºè‡ªç„¶æ•° `{0,1,2,3,4,...}` çš„åŸºç¡€ç†è®ºä½“ç³»ã€‚æˆ‘ä»¬é¦–å…ˆè¦è¯æ˜çš„æ˜¯ `2 + 2 = 4`ã€‚ç´§æ¥ç€ï¼Œæˆ‘ä»¬ä¼šè¯æ˜ `x + y = y + x`ã€‚\næœ€ç»ˆï¼Œæˆ‘ä»¬å°†å°è¯•è¯æ˜è´¹é©¬å¤§å®šç†ã€‚\nè¯·é€šè¿‡å®Œæˆæœ¬æ¸¸æˆä¸­çš„å…³å¡æ¥å®Œæˆè¿™äº›æŒ‘æˆ˜ã€‚\n\n## é˜…è¯»æç¤º\n\næŒæ¡äº¤äº’å¼å®šç†è¯æ˜å·¥å…·éœ€è¦èŠ±è´¹æ—¶é—´ã€‚\nç»è¿‡æµ‹è¯•å‘ç°ï¼Œé‚£äº›é˜…è¯»äº†æœ¬å¸®åŠ©æŒ‡å—çš„ç©å®¶èƒ½å¤Ÿæ›´å¥½åœ°äº«å—æœ¬æ¸¸æˆå¹¶ä»ä¸­å—ç›Šã€‚\n\nå¼€å§‹æ¸¸æˆï¼Œè¯·ç‚¹å‡»â€œæ•™ç¨‹ä¸–ç•Œâ€ã€‚\n\nè¯·æ³¨æ„ï¼šè¿™æ˜¯åŸºäºå…¨æ–° Lean 4 å¼€å‘çš„æ¸¸æˆç‰ˆæœ¬ï¼Œæ–°å¢äº†è®¸å¤šæ—§ç‰ˆ Lean 3 ä¸­æœªåŒ…å«çš„ä¸–ç•Œã€‚é«˜çº§ä¹˜æ³•ä¸–ç•Œçš„æ–°ç‰ˆæœ¬æ­£åœ¨å¼€å‘ä¸­ï¼Œå…¶ä»–æ–°ä¸–ç•Œå¦‚ç´ æ•°ä¸–ç•Œç­‰å°†äº2023å¹´10æœˆè‡³11æœˆé™†ç»­æ¨å‡ºã€‚\n\n## æ›´å¤šä¿¡æ¯\n\nè¯·ç‚¹å‡»å±å¹•å³ä¸Šè§’çš„â€œâ˜°â€ï¼Œé€‰æ‹©â€œæ¸¸æˆä¿¡æ¯â€ï¼Œè¿™é‡Œæä¾›äº†èµ„æºé“¾æ¥ä»¥åŠå¦‚ä½•ä¸ Lean ç¤¾åŒºäº’åŠ¨çš„æ–¹æ³•ã€‚",
 "# Summary\nThe `right` tactic changes a goal of `P âˆ¨ Q` into a goal of `Q`.\nUse it when your hypotheses guarantee that the reason that `P âˆ¨ Q`\nis true is because in fact `Q` is true.\n\nInternally this tactic is just `apply`ing a theorem\nsaying that $Q \\implies P \\lor Q.$\n\nNote that this tactic can turn a solvable goal into an unsolvable\none.":
 "ï¼ƒ å°ç»“\n`right` ç­–ç•¥å°† `P âˆ¨ Q` çš„ç›®æ ‡æ›´æ”¹ä¸º `Q` çš„ç›®æ ‡ã€‚\nå½“æ‚¨çš„å‡è®¾`Q` ä¸ºçœŸæ˜¯ `P âˆ¨ Q`ä¸ºçœŸçš„åŸå› æ—¶ä½¿ç”¨å®ƒã€‚\n\nåœ¨ç­–ç•¥å†…éƒ¨ï¼Œå®ƒåªæ˜¯ `apply` ï¼ˆåº”ç”¨ï¼‰ äº† $Q \\implies P \\lor Q$ è¿™ä¸ªå®šç†\n\nè¯·æ³¨æ„ï¼Œè¿™ç§ç­–ç•¥å¯ä»¥å°†å¯è§£å†³çš„ç›®æ ‡å˜æˆæ— æ³•è§£å†³çš„ç›®æ ‡ã€‚",
 "# Summary\nThe `left` tactic changes a goal of `P âˆ¨ Q` into a goal of `P`.\nUse it when your hypotheses guarantee that the reason that `P âˆ¨ Q`\nis true is because in fact `P` is true.\n\nInternally this tactic is just `apply`ing a theorem\nsaying that $P \\implies P \\lor Q.$\n\nNote that this tactic can turn a solvable goal into an unsolvable\none.":
 "# å°ç»“\n`left` ç­–ç•¥å°†ç›®æ ‡ `P âˆ¨ Q` è½¬æ¢ä¸ºç›®æ ‡ `P`ã€‚å½“æ‚¨çš„å‡è®¾ä¿è¯ `P âˆ¨ Q` ä¸ºçœŸçš„åŸå› æ˜¯ç”±äº `P` ä¸ºçœŸæ—¶ï¼Œè¯·ä½¿ç”¨å®ƒã€‚\n\nåœ¨å†…éƒ¨ï¼Œè¿™ä¸ªç­–ç•¥åªæ˜¯åº”ç”¨äº†ä¸€ä¸ªå®šç†ï¼Œè¯¥å®šç†æ˜¯ $P\\implies P\\lor Q$ ã€‚\n\nè¯·æ³¨æ„ï¼Œæ­¤ç­–ç•¥å¯èƒ½ä¼šå°†ä¸€ä¸ªå¯è§£å†³çš„ç›®æ ‡è½¬æ¢ä¸ºä¸å¯è§£å†³çš„ç›®æ ‡ã€‚",
 "# Summary\n\n`trivial` will solve the goal `True`.":
 "ï¼ƒ å°ç»“\n\n`trivial` å°†è§£å†³ç›®æ ‡ `True`ã€‚",
 "# Summary\n\n`decide` will attempt to solve a goal if it can find an algorithm which it\ncan run to solve it.\n\n## Example\n\nA term of type `DecidableEq â„•` is an algorithm to decide whether two naturals\nare equal or different. Hence, once this term is made and made into an `instance`,\nthe `decide` tactic can use it to solve goals of the form `a = b` or `a â‰  b`.":
 "# å°ç»“\n\nå¦‚æœ `decide` å¯ä»¥æ‰¾åˆ°ä¸€ç§ç®—æ³•æ¥è§£å†³ç›®æ ‡ï¼Œå®ƒå°†å°è¯•è§£å†³è¯¥ç›®æ ‡ã€‚\n\n## ç¤ºä¾‹\n\nç±»å‹ä¸º `DecidableEq â„•` çš„é¡¹æ˜¯ç”¨äºåˆ¤æ–­ä¸¤ä¸ªè‡ªç„¶æ•°æ˜¯å¦ç›¸ç­‰æˆ–ä¸åŒçš„ç®—æ³•ï¼ˆçš„å®ç°å‡½æ•°ï¼‰ã€‚\nå› æ­¤ï¼Œä¸€æ—¦è¿™ä¸ªé¡¹è¢«åˆ›å»ºå¹¶æˆä¸ºä¸€ä¸ª `instance`ï¼Œ`decide` ç­–ç•¥å°±å¯ä»¥ä½¿ç”¨å®ƒæ¥è§£å†³å½¢å¼ä¸º `a = b` æˆ– `a â‰  b` çš„ç›®æ ‡ã€‚",
 "# Summary\n\nThe `tauto` tactic will solve any goal which can be solved purely by logic (that is, by\ntruth tables).\n\n## Example\n\nIf you have `False` as a hypothesis, then `tauto` will solve\nthe goal. This is because a false hypothesis implies any hypothesis.\n\n## Example\n\nIf your goal is `True`, then `tauto` will solve the goal.\n\n## Example\n\nIf you have two hypotheses `h1 : a = 37` and `h2 : a â‰  37` then `tauto` will\nsolve the goal because it can prove `False` from your hypotheses, and thus\nprove the goal (as `False` implies anything).\n\n## Example\n\nIf you have one hypothesis `h : a â‰  a` then `tauto` will solve the goal because\n`tauto` is smart enough to know that `a = a` is true, which gives the contradiction we seek.\n\n## Example\n\nIf you have a hypothesis of the form `a = 0 â†’ a * b = 0` and your goal is `a * b â‰  0 â†’ a â‰  0`, then\n`tauto` will solve the goal, because the goal is logically equivalent to the hypothesis.\nIf you switch the goal and hypothesis in this example, `tauto` would solve it too.":
 "# å°ç»“\n\n`tauto` ç­–ç•¥å°†è§£å†³ä»»ä½•å¯ä»¥çº¯ç²¹é€šè¿‡é€»è¾‘è§£å†³çš„ç›®æ ‡ï¼ˆå³ï¼Œé€šè¿‡çœŸå€¼è¡¨ï¼‰ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ä¸º `False`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ã€‚è¿™æ˜¯å› ä¸ºä¸€ä¸ªå‡çš„å‡è®¾æ„å‘³ç€ä»»ä½•å‡è®¾ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ çš„ç›®æ ‡æ˜¯ `True`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾ `h1 : a = 37` å’Œ `h2 : a â‰  37`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ï¼Œå› ä¸ºå®ƒå¯ä»¥ä»ä½ çš„å‡è®¾ä¸­è¯æ˜ `False`ï¼Œä»è€Œè¯æ˜ç›®æ ‡ï¼ˆå› ä¸º `False` æ„å‘³ç€ä»»ä½•äº‹æƒ…ï¼‰ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  a`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ï¼Œå› ä¸º `tauto` è¶³å¤Ÿèªæ˜ä»¥çŸ¥é“ `a = a` æ˜¯çœŸçš„ï¼Œè¿™æä¾›äº†æˆ‘ä»¬å¯»æ±‚çš„çŸ›ç›¾ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a = 0 â†’ a * b = 0` çš„å‡è®¾ï¼Œè€Œä½ çš„ç›®æ ‡æ˜¯ `a * b â‰  0 â†’ a â‰  0`ï¼Œé‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡ï¼Œå› ä¸ºç›®æ ‡åœ¨é€»è¾‘ä¸Šç­‰åŒäºå‡è®¾ã€‚\nå¦‚æœä½ åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­äº¤æ¢ç›®æ ‡å’Œå‡è®¾ï¼Œ`tauto` ä¹Ÿä¼šè§£å†³å®ƒã€‚\nå¦‚æœä½ æœ‰ä¸¤ä¸ªå‡è®¾ `h1 : a = 37` å’Œ `h2 : a â‰  37` é‚£ä¹ˆ `tauto` å°†è§£å†³ç›®æ ‡\nå°±èƒ½è§£å†³è¿™ä¸ªç›®æ ‡ï¼Œå› ä¸ºå®ƒèƒ½ä»ä½ çš„å‡è®¾ä¸­è¯æ˜ `False`ï¼Œä»è€Œ\nè¯æ˜ç›®æ ‡ï¼ˆå› ä¸º `False` æ„å‘³ç€ä»»ä½•äº‹æƒ…ï¼‰ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾ `h : a â‰  a` é‚£ä¹ˆ `tauto` å°±èƒ½è¯æ˜è¿™ä¸ªç›®æ ‡ï¼Œå› ä¸º\n`tauto` è¶³å¤Ÿèªæ˜ï¼ŒçŸ¥é“ `a = a` ä¸ºçœŸï¼Œè¿™å°±ç»™å‡ºäº†æˆ‘ä»¬æ‰€å¯»æ±‚çš„çŸ›ç›¾ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå½¢å¼ä¸º `a = 0 â†’ a * b = 0` çš„å‡è®¾ï¼Œè€Œä½ çš„ç›®æ ‡æ˜¯ `a * b â‰  0 â†’ a â‰  0`ï¼Œé‚£ä¹ˆ\n`tauto` å°†è¯æ˜ç›®æ ‡ï¼Œå› ä¸ºç›®æ ‡åœ¨é€»è¾‘ä¸Šç­‰åŒäºå‡è®¾ã€‚\nå¦‚æœæŠŠè¿™ä¸ªä¾‹å­ä¸­çš„ç›®æ ‡å’Œå‡è®¾æ¢ä¸€ä¸‹ï¼Œ`tauto` ä¹Ÿä¼šè§£å†³å®ƒã€‚",
 "# Summary\n\nThe `have` tactic can be used to add new hypotheses to a level, but of course\nyou have to prove them.\n\n\n## Example\n\nThe simplest usage is like this. If you have `a` in your context and you execute\n\n`have ha : a = 0`\n\nthen you will get a new goal `a = 0` to prove, and after you've proved\nit you will have a new hypothesis `ha : a = 0` in your original goal.\n\n## Example\n\nIf you already have a proof of what you want to `have`, you\ncan just create it immediately. For example, if you have `a` and `b`\nnumber objects, then\n\n`have h2 : succ a = succ b â†’ a = b := succ_inj a b`\n\nwill directly add a new hypothesis `h2 : succ a = succ b â†’ a = b`\nto the context, because you just supplied the proof of it (`succ_inj a b`).\n\n## Example\n\nIf you have a proof to hand, then you don't even need to state what you\nare proving. example\n\n`have h2 := succ_inj a b`\n\nwill add `h2 : succ a = succ b â†’ a = b` as a hypothesis.":
 "# å°ç»“\n\n`have` ç­–ç•¥å¯ä»¥ç”¨æ¥å‘ä¸€ä¸ªå±‚çº§æ·»åŠ æ–°çš„å‡è®¾ï¼Œä½†å½“ç„¶ï¼Œä½ å¿…é¡»è¯æ˜å®ƒä»¬ã€‚\n\n## ç¤ºä¾‹\n\næœ€ç®€å•çš„ä½¿ç”¨æ–¹å¼æ˜¯è¿™æ ·çš„ã€‚å¦‚æœä½ åœ¨ä½ çš„ä¸Šä¸‹æ–‡ä¸­æœ‰ `a` å¹¶ä¸”ä½ æ‰§è¡Œäº†\n\n`have ha : a = 0`\n\né‚£ä¹ˆä½ å°†å¾—åˆ°ä¸€ä¸ªæ–°çš„ç›®æ ‡ `a = 0` æ¥è¯æ˜ï¼Œä¸€æ—¦ä½ è¯æ˜äº†å®ƒï¼Œä½ å°†åœ¨ä½ åŸå§‹çš„ç›®æ ‡ä¸­æœ‰ä¸€ä¸ªæ–°çš„å‡è®¾ `ha : a = 0`ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ å·²ç»æœ‰äº†ä½ æƒ³è¦ `have` çš„è¯æ˜ï¼Œä½ å¯ä»¥ç«‹å³åˆ›å»ºå®ƒã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æœ‰ `a` å’Œ `b` è¿™ä¸¤ä¸ªæ•°å­—å¯¹è±¡ï¼Œé‚£ä¹ˆ\n\n`have h2 : succ a = succ b â†’ a = b := succ_inj a b`\n\nå°†ç›´æ¥å‘ä¸Šä¸‹æ–‡ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„å‡è®¾ `h2 : succ a = succ b â†’ a = b`ï¼Œå› ä¸ºä½ åˆšåˆšæä¾›äº†å®ƒçš„è¯æ˜ï¼ˆ`succ_inj a b`ï¼‰ã€‚\n\n## ç¤ºä¾‹\n\nå¦‚æœä½ æ‰‹å¤´æœ‰è¯æ˜ï¼Œé‚£ä¹ˆä½ ç”šè‡³ä¸éœ€è¦å£°æ˜ä½ åœ¨è¯æ˜ä»€ä¹ˆã€‚ä¾‹å¦‚\n\n`have h2 := succ_inj a b`\n\nå°†ä¼šæ·»åŠ å‡è®¾ `h2 : succ a = succ b â†’ a = b`ã€‚",
 "# Summary\n\nIf you have a hypothesis\n\n`h : a â‰  b`\n\nand goal\n\n`c â‰  d`\n\nthen `contrapose! h` replaces the set-up with its so-called \\\"contrapositive\\\":\na hypothesis\n\n`h : c = d`\n\nand goal\n\n`a = b`.":
 "# å°ç»“\n\nå¦‚æœä½ æœ‰ä¸€ä¸ªå‡è®¾\n\n`h : a â‰  b`\n\nå’Œç›®æ ‡\n\n`c â‰  d`\n\né‚£ä¹ˆ `contrapose! h` å°†è¿™ä¸ªå‘½é¢˜æ›¿æ¢ä¸ºæ‰€è°“çš„â€œé€†å¦å‘½é¢˜â€ï¼š\nä¸€ä¸ªå‡è®¾\n\n`h : c = d`\n\nå’Œç›®æ ‡\n\n`a = b`ã€‚",
 "# Statement\n\nIf $a$ and $b$ are numbers, then\n`succ_inj a b` is the proof that\n$ (\\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n\n## More technical details\n\nThere are other ways to think about `succ_inj`.\n\nYou can think about `succ_inj` itself as a function which takes two\nnumbers $$a$$ and $$b$$ as input, and outputs a proof of\n$ ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n\nYou can think of `succ_inj` itself as a proof; it is the proof\nthat `succ` is an injective function. In other words,\n`succ_inj` is a proof of\n$\\forall a, b \\in  \\mathbb{N}, ( \\operatorname{succ}(a) = \\operatorname{succ}(b)) \\implies a=b$.\n\n`succ_inj` was postulated as an axiom by Peano, but\nin Lean it can be proved using `pred`, a mathematically\npathological function.":
 "# é™ˆè¿°\n\nå¦‚æœ \\( a \\) å’Œ \\( b \\) æ˜¯æ•°å­—ï¼Œé‚£ä¹ˆ\n`succ_inj a b` æ˜¯\n$ (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ çš„è¯æ˜ã€‚\n\n## æ›´å¤šæŠ€æœ¯ç»†èŠ‚\n\nä½ å¯ä»¥ç”¨å…¶ä»–æ–¹å¼æ€è€ƒ `succ_inj`ã€‚\n\nä½ å¯ä»¥æŠŠ `succ_inj` æœ¬èº«æƒ³è±¡æˆä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ªæ•°å­— $$a$$ å’Œ $$b$$ ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¾“å‡º\n$ (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ çš„è¯æ˜ã€‚\n\nä½ å¯ä»¥æŠŠ `succ_inj` æœ¬èº«çœ‹ä½œæ˜¯ä¸€ä¸ªè¯æ˜ï¼›å®ƒæ˜¯ `succ` æ˜¯ä¸€ä¸ªå•å°„å‡½æ•°çš„è¯æ˜ã€‚æ¢å¥è¯è¯´ï¼Œ\n`succ_inj` æ˜¯\n$ \\forall a, b \\in \\mathbb{N}, (\\operatorname{succ}(a) = \\operatorname{succ}(b))\\implies a=b $ çš„è¯æ˜ã€‚\n\n`succ_inj` è¢«çš®äºšè¯ºå‡è®¾ä¸ºä¸€ä¸ªå…¬ç†ï¼Œä½†åœ¨ Lean ä¸­å¯ä»¥ä½¿ç”¨ `pred` æ¥è¯æ˜ï¼Œè¿™æ˜¯ä¸€ä¸ªåœ¨æ•°å­¦ä¸Šæœ‰ç—…æ€çš„å‡½æ•°ã€‚",
 "# Read this first\n\nEach level in this game involves proving a mathematical theorem (the \"Goal\").\nThe goal will be a statement about *numbers*. Some numbers in this game have known values.\nThose numbers have names like $37$. Other numbers will be secret. They're called things\nlike $x$ and $q$. We know $x$ is a number, we just don't know which one.\n\nIn this first level we're going to prove the theorem that $37x + q = 37x + q$.\nYou can see `x q : â„•` in the *Objects* below, which means that `x` and `q`\nare numbers.\n\nWe solve goals in Lean using *Tactics*, and the first tactic we're\ngoing to learn is called `rfl`, which proves all theorems of the form $X = X$.\n\nProve that $37x+q=37x+q$ by executing the `rfl` tactic.":
 "# æ¸¸æˆæŒ‡å—\n\nåœ¨è¿™ä¸ªæ¸¸æˆçš„æ¯ä¸ªå…³å¡ä¸­ï¼Œä½ éƒ½å°†æŒ‘æˆ˜è¯æ˜ä¸€ä¸ªæ•°å­¦å®šç†ï¼Œè¿™é‡Œç§°ä¹‹ä¸ºâ€œç›®æ ‡â€ã€‚è¿™äº›ç›®æ ‡ä¸»è¦ä¸*è‡ªç„¶æ•°*ç›¸å…³ã€‚æ¸¸æˆä¸­ï¼Œä¸€äº›æ•°å…·æœ‰æ˜ç¡®çš„å€¼ï¼Œä¾‹å¦‚ $37$ è¿™ç±»å…·ä½“çš„æ•°ã€‚ç„¶è€Œï¼Œè¿˜æœ‰ä¸€äº›æ•°æ˜¯æœªçŸ¥æ•°ï¼Œå®ƒä»¬è¢«ç§°ä¸º $x$ã€$q$ ç­‰ã€‚è™½ç„¶æˆ‘ä»¬ä¸çŸ¥é“ $x$ çš„å…·ä½“å€¼ï¼Œä½†æˆ‘ä»¬çŸ¥é“å®ƒä»£è¡¨ä¸€ä¸ªè‡ªç„¶æ•°ã€‚\n\nåœ¨æ¸¸æˆçš„ç¬¬ä¸€å…³ï¼Œæˆ‘ä»¬çš„ä»»åŠ¡æ˜¯è¯æ˜å®šç† $37x + q = 37x + q$ã€‚ä½ å°†åœ¨ä¸‹æ–¹çš„*å¯¹è±¡*ä¸­çœ‹åˆ° `x q : â„•`ï¼Œè¿™è¡¨ç¤º `x` å’Œ `q` éƒ½æ˜¯è‡ªç„¶æ•°ã€‚\n\nä¸ºäº†åœ¨ Lean ä¸­è¯æ˜è¿™äº›ç›®æ ‡ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å’Œä½¿ç”¨å„ç§*ç­–ç•¥*ã€‚é¦–å…ˆä»‹ç»çš„ç­–ç•¥æ˜¯ `rfl`ï¼Œå®ƒç”¨äºè¯æ˜æ‰€æœ‰å½¢å¼ä¸º $X = X$ çš„å®šç†ã€‚\n\nè¦è¯æ˜ $37x+q=37x+q$ï¼Œè¯·ä½¿ç”¨ `rfl` ç­–ç•¥ã€‚",
 "# Overview\n\nOur home-made tactic `simp_add` will solve arbitrary goals of\nthe form `a + (b + c) + (d + e) = e + (d + (c + b)) + a`.":
 "ï¼ƒ æ¦‚è¿°\n\næˆ‘ä»¬è‡ªåˆ¶çš„ç­–ç•¥ `simp_add` å°†è§£å†³ä»¥ä¸‹å½¢å¼çš„ä»»æ„ç›®æ ‡ï¼š\n `a + (b + c) + (d + e) = e + (d + (c + b)) + a`ã€‚",
 "# Overview\n\nLean's simplifier, `simp`, will rewrite every lemma\ntagged with `simp` and every lemma fed to it by the user, as much as it can.\nFurthermore, it will attempt to order variables into an internal order if fed\nlemmas such as `add_comm`, so that it does not go into an infinite loop.":
 "ï¼ƒ æ¦‚è¿°\n\nLean çš„ç®€åŒ–å™¨ `simp` å°†å®ƒå°†ç”¨æ¯ä¸ªç”¨æˆ·æä¾›ç»™å®ƒçš„å¼•ç†\nä»¥åŠæ‰€æœ‰æ ‡è®°ä¸º `simp` çš„å¼•ç†é‡å†™ç›®æ ‡ã€‚\næ­¤å¤–ï¼Œå¦‚æœæä¾›äº†å¦‚`add_comm`è¿™æ ·çš„å¼•ç†ï¼Œå®ƒå°†å°è¯•å°†å¯¹å˜é‡æ’åºï¼Œä»¥é¿å…é™·å…¥æ— é™å¾ªç¯ã€‚"}